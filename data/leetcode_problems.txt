## 1 - Two Sum
~1~  ['Array', 'Hash Table']
Given an array of integers, return indices of the two numbers such that they add up to a specific target.

You may assume that each input would have exactly one solution, and you may not use the same element twice.


Example:

Given nums = [2, 7, 11, 15], target = 9,

Because nums[0] + nums[1] = 2 + 7 = 9,
return [0, 1].










## 2 - Add Two Numbers
~2~  ['Linked List', 'Math']
You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.

You may assume the two numbers do not contain any leading zero, except the number 0 itself.


Input: (2 -> 4 -> 3) + (5 -> 6 -> 4)
Output: 7 -> 0 -> 8










## 3 - Longest Substring Without Repeating Characters
~2~  ['Hash Table', 'Two Pointers', 'String']
Given a string, find the length of the longest substring without repeating characters.

Examples:

Given "abcabcbb", the answer is "abc", which the length is 3.

Given "bbbbb", the answer is "b", with the length of 1.

Given "pwwkew", the answer is "wke", with the length of 3. Note that the answer must be a substring, "pwke" is a subsequence and not a substring.










## 4 - Median of Two Sorted Arrays
~3~  ['Array', 'Binary Search', 'Divide and Conquer']
There are two sorted arrays nums1 and nums2 of size m and n respectively.

Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).

Example 1:

nums1 = [1, 3]
nums2 = [2]

The median is 2.0



Example 2:

nums1 = [1, 2]
nums2 = [3, 4]

The median is (2 + 3)/2 = 2.5










## 5 - Longest Palindromic Substring
~2~  ['String']
Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.

Example:

Input: "babad"

Output: "bab"

Note: "aba" is also a valid answer.



Example:

Input: "cbbd"

Output: "bb"










## 6 - ZigZag Conversion
~2~  ['String']
The string "PAYPALISHIRING" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)

P   A   H   N
A P L S I I G
Y   I   R


And then read line by line: "PAHNAPLSIIGYIR"


Write the code that will take a string and make this conversion given a number of rows:

string convert(string text, int nRows);

convert("PAYPALISHIRING", 3) should return "PAHNAPLSIIGYIR".










## 7 - Reverse Integer
~1~  ['Math']
Given a 32-bit signed integer, reverse digits of an integer.

Example 1:

Input: 123
Output:  321



Example 2:

Input: -123
Output: -321



Example 3:

Input: 120
Output: 21



Note:
Assume we are dealing with an environment which could only hold integers within the 32-bit signed integer range. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.










## 8 - String to Integer (atoi)
~2~  ['Math', 'String']
Implement atoi to convert a string to an integer.

Hint: Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases.


Notes: 
It is intended for this problem to be specified vaguely (ie, no given input specs). You are responsible to gather all the input requirements up front. 


Update (2015-02-10):
The signature of the C++ function had been updated. If you still see your function signature accepts a const char * argument, please click the reload button  to reset your code definition.


spoilers alert... click to show requirements for atoi.

Requirements for atoi:

The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.

The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.

If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.

If no valid conversion could be performed, a zero value is returned. If the correct value is out of the range of representable values, INT_MAX (2147483647) or INT_MIN (-2147483648) is returned.










## 9 - Palindrome Number
~1~  ['Math']
Determine whether an integer is a palindrome. Do this without extra space.

click to show spoilers.

Some hints:

Could negative integers be palindromes? (ie, -1)

If you are thinking of converting the integer to string, note the restriction of using extra space.

You could also try reversing an integer. However, if you have solved the problem "Reverse Integer", you know that the reversed integer might overflow. How would you handle such case?

There is a more generic way of solving this problem.










## 10 - Regular Expression Matching
~3~  ['String', 'Dynamic Programming', 'Backtracking']
Implement regular expression matching with support for '.' and '*'.


'.' Matches any single character.
'*' Matches zero or more of the preceding element.

The matching should cover the entire input string (not partial).

The function prototype should be:
bool isMatch(const char *s, const char *p)

Some examples:
isMatch("aa","a") → false
isMatch("aa","aa") → true
isMatch("aaa","aa") → false
isMatch("aa", "a*") → true
isMatch("aa", ".*") → true
isMatch("ab", ".*") → true
isMatch("aab", "c*a*b") → true










## 11 - Container With Most Water
~2~  ['Array', 'Two Pointers']
Given n non-negative integers a1, a2, ..., an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.

Note: You may not slant the container and n is at least 2.










## 12 - Integer to Roman
~2~  ['Math', 'String']
Given an integer, convert it to a roman numeral.


Input is guaranteed to be within the range from 1 to 3999.










## 13 - Roman to Integer
~1~  ['Math', 'String']
Given a roman numeral, convert it to an integer.

Input is guaranteed to be within the range from 1 to 3999.










## 14 - Longest Common Prefix
~1~  ['String']
Write a function to find the longest common prefix string amongst an array of strings.










## 15 - 3Sum
~2~  ['Array', 'Two Pointers']
Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.

Note: The solution set must not contain duplicate triplets.


For example, given array S = [-1, 0, 1, 2, -1, -4],

A solution set is:
[
  [-1, 0, 1],
  [-1, -1, 2]
]










## 16 - 3Sum Closest
~2~  ['Array', 'Two Pointers']
Given an array S of n integers, find three integers in S such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution.


    For example, given array S = {-1 2 1 -4}, and target = 1.

    The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).










## 17 - Letter Combinations of a Phone Number
~2~  ['String', 'Backtracking']
Given a digit string, return all possible letter combinations that the number could represent.



A mapping of digit to letters (just like on the telephone buttons) is given below.



Input:Digit string "23"
Output: ["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].



Note:
Although the above answer is in lexicographical order, your answer could be in any order you want.










## 18 - 4Sum
~2~  ['Array', 'Hash Table', 'Two Pointers']
Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.

Note: The solution set must not contain duplicate quadruplets.



For example, given array S = [1, 0, -1, 0, -2, 2], and target = 0.

A solution set is:
[
  [-1,  0, 0, 1],
  [-2, -1, 1, 2],
  [-2,  0, 0, 2]
]










## 19 - Remove Nth Node From End of List
~2~  ['Linked List', 'Two Pointers']
Given a linked list, remove the nth node from the end of list and return its head.


For example,


   Given linked list: 1->2->3->4->5, and n = 2.

   After removing the second node from the end, the linked list becomes 1->2->3->5.



Note:
Given n will always be valid.
Try to do this in one pass.










## 20 - Valid Parentheses
~1~  ['String', 'Stack']
Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.

The brackets must close in the correct order, "()" and "()[]{}" are all valid but "(]" and "([)]" are not.










## 21 - Merge Two Sorted Lists
~1~  ['Linked List']
Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.










## 22 - Generate Parentheses
~2~  ['String', 'Backtracking']
Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.



For example, given n = 3, a solution set is:


[
  "((()))",
  "(()())",
  "(())()",
  "()(())",
  "()()()"
]










## 23 - Merge k Sorted Lists
~3~  ['Linked List', 'Divide and Conquer', 'Heap']
Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.










## 24 - Swap Nodes in Pairs
~2~  ['Linked List']
Given a linked list, swap every two adjacent nodes and return its head.



For example,
Given 1->2->3->4, you should return the list as 2->1->4->3.



Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed.










## 25 - Reverse Nodes in k-Group
~3~  ['Linked List']
Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.



k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.

You may not alter the values in the nodes, only nodes itself may be changed.

Only constant memory is allowed.


For example,
Given this linked list: 1->2->3->4->5



For k = 2, you should return: 2->1->4->3->5



For k = 3, you should return: 3->2->1->4->5










## 26 - Remove Duplicates from Sorted Array
~1~  ['Array', 'Two Pointers']
Given a sorted array, remove the duplicates in-place such that each element appear only once and return the new length.

Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.


Example:

Given nums = [1,1,2],

Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.
It doesn't matter what you leave beyond the new length.










## 27 - Remove Element
~1~  ['Array', 'Two Pointers']
Given an array and a value, remove all instances of that value in-place and return the new length.


Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.

The order of elements can be changed. It doesn't matter what you leave beyond the new length.


Example:

Given nums = [3,2,2,3], val = 3,

Your function should return length = 2, with the first two elements of nums being 2.










## 28 - Implement strStr()
~1~  ['Two Pointers', 'String']
Implement strStr().



Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.


Example 1:

Input: haystack = "hello", needle = "ll"
Output: 2



Example 2:

Input: haystack = "aaaaa", needle = "bba"
Output: -1










## 29 - Divide Two Integers
~2~  ['Math', 'Binary Search']
Divide two integers without using multiplication, division and mod operator.


If it is overflow, return MAX_INT.










## 30 - Substring with Concatenation of All Words
~3~  ['Hash Table', 'Two Pointers', 'String']
You are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters.



For example, given:
s: "barfoothefoobarman"
words: ["foo", "bar"]



You should return the indices: [0,9].
(order does not matter).










## 31 - Next Permutation
~2~  ['Array']
Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.


If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).


The replacement must be in-place, do not allocate extra memory.


Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.
1,2,3 → 1,3,2
3,2,1 → 1,2,3
1,1,5 → 1,5,1










## 32 - Longest Valid Parentheses
~3~  ['String', 'Dynamic Programming']
Given a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring.


For "(()", the longest valid parentheses substring is "()", which has length = 2.


Another example is ")()())", where the longest valid parentheses substring is "()()", which has length = 4.










## 33 - Search in Rotated Sorted Array
~2~  ['Array', 'Binary Search']
Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.

(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).

You are given a target value to search. If found in the array return its index, otherwise return -1.

You may assume no duplicate exists in the array.










## 34 - Search for a Range
~2~  ['Array', 'Binary Search']
Given an array of integers sorted in ascending order, find the starting and ending position of a given target value.

Your algorithm's runtime complexity must be in the order of O(log n).

If the target is not found in the array, return [-1, -1].


For example,
Given [5, 7, 7, 8, 8, 10] and target value 8,
return [3, 4].










## 35 - Search Insert Position
~1~  ['Array', 'Binary Search']
Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.

You may assume no duplicates in the array.

Example 1:

Input: [1,3,5,6], 5
Output: 2



Example 2:

Input: [1,3,5,6], 2
Output: 1



Example 3:

Input: [1,3,5,6], 7
Output: 4



Example 1:

Input: [1,3,5,6], 0
Output: 0










## 36 - Valid Sudoku
~2~  ['Hash Table']
Determine if a Sudoku is valid, according to: Sudoku Puzzles - The Rules.

The Sudoku board could be partially filled, where empty cells are filled with the character '.'.



A partially filled sudoku which is valid.


Note:
A valid Sudoku board (partially filled) is not necessarily solvable. Only the filled cells need to be validated.










## 37 - Sudoku Solver
~3~  ['Hash Table', 'Backtracking']
Write a program to solve a Sudoku puzzle by filling the empty cells.

Empty cells are indicated by the character '.'.

You may assume that there will be only one unique solution.



A sudoku puzzle...




...and its solution numbers marked in red.










## 38 - Count and Say
~1~  ['String']
The count-and-say sequence is the sequence of integers with the first five terms as following:

1.     1
2.     11
3.     21
4.     1211
5.     111221



1 is read off as "one 1" or 11.
11 is read off as "two 1s" or 21.
21 is read off as "one 2, then one 1" or 1211.



Given an integer n, generate the nth term of the count-and-say sequence.



Note: Each term of the sequence of integers will be represented as a string.


Example 1:

Input: 1
Output: "1"



Example 2:

Input: 4
Output: "1211"










## 39 - Combination Sum
~2~  ['Array', 'Backtracking']
Given a set of candidate numbers (C) (without duplicates) and a target number (T), find all unique combinations in C where the candidate numbers sums to T. 


The same repeated number may be chosen from C unlimited number of times.


Note:

All numbers (including target) will be positive integers.
The solution set must not contain duplicate combinations.




For example, given candidate set [2, 3, 6, 7] and target 7, 
A solution set is: 

[
  [7],
  [2, 2, 3]
]










## 40 - Combination Sum II
~2~  ['Array', 'Backtracking']
Given a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.


Each number in C may only be used once in the combination.

Note:

All numbers (including target) will be positive integers.
The solution set must not contain duplicate combinations.




For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8, 
A solution set is: 

[
  [1, 7],
  [1, 2, 5],
  [2, 6],
  [1, 1, 6]
]










## 41 - First Missing Positive
~3~  ['Array']
Given an unsorted integer array, find the first missing positive integer.



For example,
Given [1,2,0] return 3,
and [3,4,-1,1] return 2.



Your algorithm should run in O(n) time and uses constant space.










## 42 - Trapping Rain Water
~3~  ['Array', 'Two Pointers', 'Stack']
Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining. 



For example, 
Given [0,1,0,2,1,0,1,3,2,1,2,1], return 6.




The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image!










## 43 - Multiply Strings
~2~  ['Math', 'String']
Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2.

Note:

The length of both num1 and num2 is < 110.
Both num1 and num2 contains only digits 0-9.
Both num1 and num2 does not contain any leading zero.
You must not use any built-in BigInteger library or convert the inputs to integer directly.










## 44 - Wildcard Matching
~3~  ['String', 'Dynamic Programming', 'Backtracking', 'Greedy']
Implement wildcard pattern matching with support for '?' and '*'.


'?' Matches any single character.
'*' Matches any sequence of characters (including the empty sequence).

The matching should cover the entire input string (not partial).

The function prototype should be:
bool isMatch(const char *s, const char *p)

Some examples:
isMatch("aa","a") → false
isMatch("aa","aa") → true
isMatch("aaa","aa") → false
isMatch("aa", "*") → true
isMatch("aa", "a*") → true
isMatch("ab", "?*") → true
isMatch("aab", "c*a*b") → false










## 45 - Jump Game II
~3~  ['Array', 'Greedy']
Given an array of non-negative integers, you are initially positioned at the first index of the array.


Each element in the array represents your maximum jump length at that position. 


Your goal is to reach the last index in the minimum number of jumps.



For example:
Given array A = [2,3,1,1,4]


The minimum number of jumps to reach the last index is 2. (Jump 1 step from index 0 to 1, then 3 steps to the last index.)



Note:
You can assume that you can always reach the last index.










## 46 - Permutations
~2~  ['Backtracking']
Given a collection of distinct numbers, return all possible permutations.



For example,
[1,2,3] have the following permutations:

[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]










## 47 - Permutations II
~2~  ['Backtracking']
Given a collection of numbers that might contain duplicates, return all possible unique permutations.



For example,
[1,1,2] have the following unique permutations:

[
  [1,1,2],
  [1,2,1],
  [2,1,1]
]










## 48 - Rotate Image
~2~  ['Array']
You are given an n x n 2D matrix representing an image.

Rotate the image by 90 degrees (clockwise).

Note:
You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.


Example 1:

Given input matrix = 
[
  [1,2,3],
  [4,5,6],
  [7,8,9]
],

rotate the input matrix in-place such that it becomes:
[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]



Example 2:

Given input matrix =
[
  [ 5, 1, 9,11],
  [ 2, 4, 8,10],
  [13, 3, 6, 7],
  [15,14,12,16]
], 

rotate the input matrix in-place such that it becomes:
[
  [15,13, 2, 5],
  [14, 3, 4, 1],
  [12, 6, 8, 9],
  [16, 7,10,11]
]










## 49 - Group Anagrams
~2~  ['Hash Table', 'String']
Given an array of strings, group anagrams together.


For example, given: ["eat", "tea", "tan", "ate", "nat", "bat"], 
Return:

[
  ["ate", "eat","tea"],
  ["nat","tan"],
  ["bat"]
]

Note: All inputs will be in lower-case.










## 50 - Pow(x, n)
~2~  ['Math', 'Binary Search']
Implement pow(x, n).




Example 1:

Input: 2.00000, 10
Output: 1024.00000



Example 2:

Input: 2.10000, 3
Output: 9.26100










## 51 - N-Queens
~3~  ['Backtracking']
The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.



Given an integer n, return all distinct solutions to the n-queens puzzle.

Each solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space respectively.

For example,
There exist two distinct solutions to the 4-queens puzzle:

[
 [".Q..",  // Solution 1
  "...Q",
  "Q...",
  "..Q."],

 ["..Q.",  // Solution 2
  "Q...",
  "...Q",
  ".Q.."]
]










## 52 - N-Queens II
~3~  ['Backtracking']
Follow up for N-Queens problem.

Now, instead outputting board configurations, return the total number of distinct solutions.










## 53 - Maximum Subarray
~1~  ['Array', 'Divide and Conquer', 'Dynamic Programming']
Find the contiguous subarray within an array (containing at least one number) which has the largest sum.


For example, given the array [-2,1,-3,4,-1,2,1,-5,4],
the contiguous subarray [4,-1,2,1] has the largest sum = 6.


click to show more practice.

More practice:

If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.










## 54 - Spiral Matrix
~2~  ['Array']
Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.



For example,
Given the following matrix:


[
 [ 1, 2, 3 ],
 [ 4, 5, 6 ],
 [ 7, 8, 9 ]
]


You should return [1,2,3,6,9,8,7,4,5].










## 55 - Jump Game
~2~  ['Array', 'Greedy']
Given an array of non-negative integers, you are initially positioned at the first index of the array.


Each element in the array represents your maximum jump length at that position. 


Determine if you are able to reach the last index.



For example:
A = [2,3,1,1,4], return true.


A = [3,2,1,0,4], return false.










## 56 - Merge Intervals
~2~  ['Array', 'Sort']
Given a collection of intervals, merge all overlapping intervals.


For example,
Given [1,3],[2,6],[8,10],[15,18],
return [1,6],[8,10],[15,18].










## 57 - Insert Interval
~3~  ['Array', 'Sort']
Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).

You may assume that the intervals were initially sorted according to their start times.


Example 1:
Given intervals [1,3],[6,9], insert and merge [2,5] in as [1,5],[6,9].



Example 2:
Given [1,2],[3,5],[6,7],[8,10],[12,16], insert and merge [4,9] in as [1,2],[3,10],[12,16].



This is because the new interval [4,9] overlaps with [3,5],[6,7],[8,10].










## 58 - Length of Last Word
~1~  ['String']
Given a string s consists of upper/lower-case alphabets and empty space characters ' ', return the length of last word in the string.

If the last word does not exist, return 0.

Note: A word is defined as a character sequence consists of non-space characters only.

Example:

Input: "Hello World"
Output: 5










## 59 - Spiral Matrix II
~2~  ['Array']
Given an integer n, generate a square matrix filled with elements from 1 to n2 in spiral order.


For example,
Given n = 3,

You should return the following matrix:

[
 [ 1, 2, 3 ],
 [ 8, 9, 4 ],
 [ 7, 6, 5 ]
]










## 60 - Permutation Sequence
~2~  ['Math', 'Backtracking']
The set [1,2,3,…,n] contains a total of n! unique permutations.

By listing and labeling all of the permutations in order,
We get the following sequence (ie, for n = 3):

"123"
"132"
"213"
"231"
"312"
"321"



Given n and k, return the kth permutation sequence.

Note: Given n will be between 1 and 9 inclusive.










## 61 - Rotate List
~2~  ['Linked List', 'Two Pointers']
Given a list, rotate the list to the right by k places, where k is non-negative.



Example:

Given 1->2->3->4->5->NULL and k = 2,

return 4->5->1->2->3->NULL.










## 62 - Unique Paths
~2~  ['Array', 'Dynamic Programming']
A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).

The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).

How many possible unique paths are there?



Above is a 3 x 7 grid. How many possible unique paths are there?


Note: m and n will be at most 100.










## 63 - Unique Paths II
~2~  ['Array', 'Dynamic Programming']
Follow up for "Unique Paths":

Now consider if some obstacles are added to the grids. How many unique paths would there be?

An obstacle and empty space is marked as 1 and 0 respectively in the grid.

For example,
There is one obstacle in the middle of a 3x3 grid as illustrated below.

[
  [0,0,0],
  [0,1,0],
  [0,0,0]
]

The total number of unique paths is 2.

Note: m and n will be at most 100.










## 64 - Minimum Path Sum
~2~  ['Array', 'Dynamic Programming']
Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.

Note: You can only move either down or right at any point in time.

Example 1:

[[1,3,1],
 [1,5,1],
 [4,2,1]]

Given the above grid map, return 7. Because the path 1→3→1→1→1 minimizes the sum.










## 65 - Valid Number
~3~  ['Math', 'String']
Validate if a given string is numeric.


Some examples:
"0" => true
"   0.1  " => true
"abc" => false
"1 a" => false
"2e10" => true


Note: It is intended for the problem statement to be ambiguous. You should gather all requirements up front before implementing one.



Update (2015-02-10):
The signature of the C++ function had been updated. If you still see your function signature accepts a const char * argument, please click the reload button  to reset your code definition.










## 66 - Plus One
~1~  ['Array', 'Math']
Given a non-negative integer represented as a non-empty array of digits, plus one to the integer.

You may assume the integer do not contain any leading zero, except the number 0 itself.

The digits are stored such that the most significant digit is at the head of the list.










## 67 - Add Binary
~1~  ['Math', 'String']
Given two binary strings, return their sum (also a binary string).



For example,
a = "11"
b = "1"
Return "100".










## 68 - Text Justification
~3~  ['String']
Given an array of words and a length L, format the text such that each line has exactly L characters and is fully (left and right) justified.
 


You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces ' ' when necessary so that each line has exactly L characters.



Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.



For the last line of text, it should be left justified and no extra space is inserted between words.



For example,
words: ["This", "is", "an", "example", "of", "text", "justification."]
L: 16.



Return the formatted lines as:

[
   "This    is    an",
   "example  of text",
   "justification.  "
]




Note: Each word is guaranteed not to exceed L in length.



click to show corner cases.

Corner Cases:


A line other than the last line might contain only one word. What should you do in this case?
In this case, that line should be left-justified.










## 69 - Sqrt(x)
~1~  ['Math', 'Binary Search']
Implement int sqrt(int x).

Compute and return the square root of x.

x is guaranteed to be a non-negative integer.



Example 1:

Input: 4
Output: 2



Example 2:

Input: 8
Output: 2
Explanation: The square root of 8 is 2.82842..., and since we want to return an integer, the decimal part will be truncated.










## 70 - Climbing Stairs
~1~  ['Dynamic Programming']
You are climbing a stair case. It takes n steps to reach to the top.

Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?


Note: Given n will be a positive integer.




Example 1:

Input: 2
Output:  2
Explanation:  There are two ways to climb to the top.

1. 1 step + 1 step
2. 2 steps



Example 2:

Input: 3
Output:  3
Explanation:  There are three ways to climb to the top.

1. 1 step + 1 step + 1 step
2. 1 step + 2 steps
3. 2 steps + 1 step










## 71 - Simplify Path
~2~  ['String', 'Stack']
Given an absolute path for a file (Unix-style), simplify it.

For example,
path = "/home/", => "/home"
path = "/a/./b/../../c/", => "/c"


click to show corner cases.

Corner Cases:



Did you consider the case where path = "/../"?
In this case, you should return "/".
Another corner case is the path might contain multiple slashes '/' together, such as "/home//foo/".
In this case, you should ignore redundant slashes and return "/home/foo".










## 72 - Edit Distance
~3~  ['String', 'Dynamic Programming']
Given two words word1 and word2, find the minimum number of steps required to convert word1 to word2. (each operation is counted as 1 step.)



You have the following 3 operations permitted on a word:



a) Insert a character
b) Delete a character
c) Replace a character










## 73 - Set Matrix Zeroes
~2~  ['Array']
Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in place.


click to show follow up.

Follow up:


Did you use extra space?
A straight forward solution using O(mn) space is probably a bad idea.
A simple improvement uses O(m + n) space, but still not the best solution.
Could you devise a constant space solution?










## 74 - Search a 2D Matrix
~2~  ['Array', 'Binary Search']
Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:



Integers in each row are sorted from left to right.
The first integer of each row is greater than the last integer of the previous row.




For example,

Consider the following matrix:


[
  [1,   3,  5,  7],
  [10, 11, 16, 20],
  [23, 30, 34, 50]
]


Given target = 3, return true.










## 75 - Sort Colors
~2~  ['Array', 'Two Pointers', 'Sort']
Given an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue.



Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.



Note:
You are not suppose to use the library's sort function for this problem.


click to show follow up.


Follow up:
A rather straight forward solution is a two-pass algorithm using counting sort.
First, iterate the array counting number of 0's, 1's, and 2's, then overwrite array with total number of 0's, then 1's and followed by 2's.
Could you come up with an one-pass algorithm using only constant space?










## 76 - Minimum Window Substring
~3~  ['Hash Table', 'Two Pointers', 'String']
Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).



For example,
S = "ADOBECODEBANC"
T = "ABC"


Minimum window is "BANC".



Note:
If there is no such window in S that covers all characters in T, return the empty string "".


If there are multiple such windows, you are guaranteed that there will always be only one unique minimum window in S.










## 77 - Combinations
~2~  ['Backtracking']
Given two integers n and k, return all possible combinations of k numbers out of 1 ... n.


For example,
If n = 4 and k = 2, a solution is:



[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]










## 78 - Subsets
~2~  ['Array', 'Backtracking', 'Bit Manipulation']
Given a set of distinct integers, nums, return all possible subsets (the power set).

Note: The solution set must not contain duplicate subsets.


For example,
If nums = [1,2,3], a solution is:



[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]










## 79 - Word Search
~2~  ['Array', 'Backtracking']
Given a 2D board and a word, find if the word exists in the grid.


The word can be constructed from letters of sequentially adjacent cell, where "adjacent" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.



For example,
Given board = 

[
  ['A','B','C','E'],
  ['S','F','C','S'],
  ['A','D','E','E']
]


word = "ABCCED", -> returns true,
word = "SEE", -> returns true,
word = "ABCB", -> returns false.










## 80 - Remove Duplicates from Sorted Array II
~2~  ['Array', 'Two Pointers']
Follow up for "Remove Duplicates":
What if duplicates are allowed at most twice?


For example,
Given sorted array nums = [1,1,1,2,2,3],


Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3. It doesn't matter what you leave beyond the new length.










## 81 - Search in Rotated Sorted Array II
~2~  ['Array', 'Binary Search']
Follow up for "Search in Rotated Sorted Array":
What if duplicates are allowed?

Would this affect the run-time complexity? How and why?


Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.

(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).

Write a function to determine if a given target is in the array.

The array may contain duplicates.










## 82 - Remove Duplicates from Sorted List II
~2~  ['Linked List']
Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.


For example,
Given 1->2->3->3->4->4->5, return 1->2->5.
Given 1->1->1->2->3, return 2->3.










## 83 - Remove Duplicates from Sorted List
~1~  ['Linked List']
Given a sorted linked list, delete all duplicates such that each element appear only once.


For example,
Given 1->1->2, return 1->2.
Given 1->1->2->3->3, return 1->2->3.










## 84 - Largest Rectangle in Histogram
~3~  ['Array', 'Stack']
Given n non-negative integers representing the histogram's bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.




Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3].




The largest rectangle is shown in the shaded area, which has area = 10 unit.



For example,
Given heights = [2,1,5,6,2,3],
return 10.










## 85 - Maximal Rectangle
~3~  ['Array', 'Hash Table', 'Dynamic Programming', 'Stack']
Given a 2D binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area.


For example, given the following matrix:

1 0 1 0 0
1 0 1 1 1
1 1 1 1 1
1 0 0 1 0

Return 6.










## 86 - Partition List
~2~  ['Linked List', 'Two Pointers']
Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.


You should preserve the original relative order of the nodes in each of the two partitions.


For example,
Given 1->4->3->2->5->2 and x = 3,
return 1->2->2->4->3->5.










## 87 - Scramble String
~3~  ['String', 'Dynamic Programming']
Given a string s1, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively.


Below is one possible representation of s1 = "great":


    great
   /    \
  gr    eat
 / \    /  \
g   r  e   at
           / \
          a   t


To scramble the string, we may choose any non-leaf node and swap its two children.


For example, if we choose the node "gr" and swap its two children, it produces a scrambled string "rgeat".


    rgeat
   /    \
  rg    eat
 / \    /  \
r   g  e   at
           / \
          a   t


We say that "rgeat" is a scrambled string of "great".


Similarly, if we continue to swap the children of nodes "eat" and "at", it produces a scrambled string "rgtae".


    rgtae
   /    \
  rg    tae
 / \    /  \
r   g  ta  e
       / \
      t   a


We say that "rgtae" is a scrambled string of "great".


Given two strings s1 and s2 of the same length, determine if s2 is a scrambled string of s1.










## 88 - Merge Sorted Array
~1~  ['Array', 'Two Pointers']
Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.


Note:
You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. The number of elements initialized in nums1 and nums2 are m and n respectively.










## 89 - Gray Code
~2~  ['Backtracking']
The gray code is a binary numeral system where two successive values differ in only one bit.

Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0.

For example, given n = 2, return [0,1,3,2]. Its gray code sequence is:

00 - 0
01 - 1
11 - 3
10 - 2


Note:
For a given n, a gray code sequence is not uniquely defined.

For example, [0,2,3,1] is also a valid gray code sequence according to the above definition.

For now, the judge is able to judge based on one instance of gray code sequence. Sorry about that.










## 90 - Subsets II
~2~  ['Array', 'Backtracking']
Given a collection of integers that might contain duplicates, nums, return all possible subsets (the power set).

Note: The solution set must not contain duplicate subsets.


For example,
If nums = [1,2,2], a solution is:



[
  [2],
  [1],
  [1,2,2],
  [2,2],
  [1,2],
  []
]










## 91 - Decode Ways
~2~  ['String', 'Dynamic Programming']
A message containing letters from A-Z is being encoded to numbers using the following mapping:



'A' -> 1
'B' -> 2
...
'Z' -> 26



Given an encoded message containing digits, determine the total number of ways to decode it.



For example,
Given encoded message "12",
it could be decoded as "AB" (1 2) or "L" (12).



The number of ways decoding "12" is 2.










## 92 - Reverse Linked List II
~2~  ['Linked List']
Reverse a linked list from position m to n. Do it in-place and in one-pass.



For example:
Given 1->2->3->4->5->NULL, m = 2 and n = 4,


return 1->4->3->2->5->NULL.


Note:
Given m, n satisfy the following condition:
1 ≤ m ≤ n ≤ length of list.










## 93 - Restore IP Addresses
~2~  ['String', 'Backtracking']
Given a string containing only digits, restore it by returning all possible valid IP address combinations.


For example:
Given "25525511135",


return ["255.255.11.135", "255.255.111.35"]. (Order does not matter)










## 94 - Binary Tree Inorder Traversal
~2~  ['Hash Table', 'Stack', 'Tree']
Given a binary tree, return the inorder traversal of its nodes' values.


For example:
Given binary tree [1,null,2,3],

   1
    \
     2
    /
   3



return [1,3,2].


Note: Recursive solution is trivial, could you do it iteratively?










## 95 - Unique Binary Search Trees II
~2~  ['Dynamic Programming', 'Tree']
Given an integer n, generate all structurally unique BST's (binary search trees) that store values 1...n.


For example,
Given n = 3, your program should return all 5 unique BST's shown below.


   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3










## 96 - Unique Binary Search Trees
~2~  ['Dynamic Programming', 'Tree']
Given n, how many structurally unique BST's (binary search trees) that store values 1...n?


For example,
Given n = 3, there are a total of 5 unique BST's.


   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3










## 97 - Interleaving String
~3~  ['String', 'Dynamic Programming']
Given s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2.



For example,
Given:
s1 = "aabcc",
s2 = "dbbca",


When s3 = "aadbbcbcac", return true.
When s3 = "aadbbbaccc", return false.










## 98 - Validate Binary Search Tree
~2~  ['Tree', 'Depth-first Search']
Given a binary tree, determine if it is a valid binary search tree (BST).



Assume a BST is defined as follows:

The left subtree of a node contains only nodes with keys less than the node's key.
The right subtree of a node contains only nodes with keys greater than the node's key.
Both the left and right subtrees must also be binary search trees.



Example 1:

    2
   / \
  1   3

Binary tree [2,1,3], return true.


Example 2:

    1
   / \
  2   3

Binary tree [1,2,3], return false.










## 99 - Recover Binary Search Tree
~3~  ['Tree', 'Depth-first Search']
Two elements of a binary search tree (BST) are swapped by mistake.

Recover the tree without changing its structure.


Note:
A solution using O(n) space is pretty straight forward. Could you devise a constant space solution?










## 100 - Same Tree
~1~  ['Tree', 'Depth-first Search']
Given two binary trees, write a function to check if they are the same or not.


Two binary trees are considered the same if they are structurally identical and the nodes have the same value.




Example 1:

Input:     1         1
          / \       / \
         2   3     2   3

        [1,2,3],   [1,2,3]

Output: true



Example 2:

Input:     1         1
          /           \
         2             2

        [1,2],     [1,null,2]

Output: false



Example 3:

Input:     1         1
          / \       / \
         2   1     1   2

        [1,2,1],   [1,1,2]

Output: false










## 101 - Symmetric Tree
~1~  ['Tree', 'Depth-first Search', 'Breadth-first Search']
Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).


For example, this binary tree [1,2,2,3,4,4,3] is symmetric:

    1
   / \
  2   2
 / \ / \
3  4 4  3



But the following [1,2,2,null,3,null,3]  is not:

    1
   / \
  2   2
   \   \
   3    3




Note:
Bonus points if you could solve it both recursively and iteratively.










## 102 - Binary Tree Level Order Traversal
~2~  ['Tree', 'Breadth-first Search']
Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).


For example:
Given binary tree [3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7



return its level order traversal as:

[
  [3],
  [9,20],
  [15,7]
]










## 103 - Binary Tree Zigzag Level Order Traversal
~2~  ['Stack', 'Tree', 'Breadth-first Search']
Given a binary tree, return the zigzag level order traversal of its nodes' values. (ie, from left to right, then right to left for the next level and alternate between).


For example:
Given binary tree [3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7



return its zigzag level order traversal as:

[
  [3],
  [20,9],
  [15,7]
]










## 104 - Maximum Depth of Binary Tree
~1~  ['Tree', 'Depth-first Search']
Given a binary tree, find its maximum depth.

The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.










## 105 - Construct Binary Tree from Preorder and Inorder Traversal
~2~  ['Array', 'Tree', 'Depth-first Search']
Given preorder and inorder traversal of a tree, construct the binary tree.

Note:
You may assume that duplicates do not exist in the tree.










## 106 - Construct Binary Tree from Inorder and Postorder Traversal
~2~  ['Array', 'Tree', 'Depth-first Search']
Given inorder and postorder traversal of a tree, construct the binary tree.

Note:
You may assume that duplicates do not exist in the tree.










## 107 - Binary Tree Level Order Traversal II
~1~  ['Tree', 'Breadth-first Search']
Given a binary tree, return the bottom-up level order traversal of its nodes' values. (ie, from left to right, level by level from leaf to root).


For example:
Given binary tree [3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7



return its bottom-up level order traversal as:

[
  [15,7],
  [9,20],
  [3]
]










## 108 - Convert Sorted Array to Binary Search Tree
~1~  ['Tree', 'Depth-first Search']
Given an array where elements are sorted in ascending order, convert it to a height balanced BST.










## 109 - Convert Sorted List to Binary Search Tree
~2~  ['Linked List', 'Depth-first Search']
Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.










## 110 - Balanced Binary Tree
~1~  ['Tree', 'Depth-first Search']
Given a binary tree, determine if it is height-balanced.



For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.










## 111 - Minimum Depth of Binary Tree
~1~  ['Tree', 'Depth-first Search', 'Breadth-first Search']
Given a binary tree, find its minimum depth.

The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.










## 112 - Path Sum
~1~  ['Tree', 'Depth-first Search']
Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.


For example:
Given the below binary tree and sum = 22,

              5
             / \
            4   8
           /   / \
          11  13  4
         /  \      \
        7    2      1



return true, as there exist a root-to-leaf path 5->4->11->2 which sum is 22.










## 113 - Path Sum II
~2~  ['Tree', 'Depth-first Search']
Given a binary tree and a sum, find all root-to-leaf paths where each path's sum equals the given sum.


For example:
Given the below binary tree and sum = 22,

              5
             / \
            4   8
           /   / \
          11  13  4
         /  \    / \
        7    2  5   1



return

[
   [5,4,11,2],
   [5,8,4,5]
]










## 114 - Flatten Binary Tree to Linked List
~2~  ['Tree', 'Depth-first Search']
Given a binary tree, flatten it to a linked list in-place.



For example,
Given

         1
        / \
       2   5
      / \   \
     3   4   6



The flattened tree should look like:

   1
    \
     2
      \
       3
        \
         4
          \
           5
            \
             6


click to show hints.

Hints:
If you notice carefully in the flattened tree, each node's right child points to the next node of a pre-order traversal.










## 115 - Distinct Subsequences
~3~  ['String', 'Dynamic Programming']
Given a string S and a string T, count the number of distinct subsequences of S which equals T.



A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, "ACE" is a subsequence of "ABCDE" while "AEC" is not).



Here is an example:
S = "rabbbit", T = "rabbit"


Return 3.










## 116 - Populating Next Right Pointers in Each Node
~2~  ['Tree', 'Depth-first Search']
Given a binary tree

    struct TreeLinkNode {
      TreeLinkNode *left;
      TreeLinkNode *right;
      TreeLinkNode *next;
    }



Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.

Initially, all next pointers are set to NULL.


Note:

You may only use constant extra space.
You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children).




For example,
Given the following perfect binary tree,

         1
       /  \
      2    3
     / \  / \
    4  5  6  7



After calling your function, the tree should look like:

         1 -> NULL
       /  \
      2 -> 3 -> NULL
     / \  / \
    4->5->6->7 -> NULL










## 117 - Populating Next Right Pointers in Each Node II
~2~  ['Tree', 'Depth-first Search']
Follow up for problem "Populating Next Right Pointers in Each Node".
What if the given tree could be any binary tree? Would your previous solution still work?

Note:
You may only use constant extra space.


For example,
Given the following binary tree,

         1
       /  \
      2    3
     / \    \
    4   5    7



After calling your function, the tree should look like:

         1 -> NULL
       /  \
      2 -> 3 -> NULL
     / \    \
    4-> 5 -> 7 -> NULL










## 118 - Pascal's Triangle
~1~  ['Array']
Given numRows, generate the first numRows of Pascal's triangle.


For example, given numRows = 5,
Return

[
     [1],
    [1,1],
   [1,2,1],
  [1,3,3,1],
 [1,4,6,4,1]
]










## 119 - Pascal's Triangle II
~1~  ['Array']
Given an index k, return the kth row of the Pascal's triangle.


For example, given k = 3,
Return [1,3,3,1].



Note:
Could you optimize your algorithm to use only O(k) extra space?










## 120 - Triangle
~2~  ['Array', 'Dynamic Programming']
Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.


For example, given the following triangle

[
     [2],
    [3,4],
   [6,5,7],
  [4,1,8,3]
]



The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11).



Note:
Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle.










## 121 - Best Time to Buy and Sell Stock
~1~  ['Array', 'Dynamic Programming']
Say you have an array for which the ith element is the price of a given stock on day i.

If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.

Example 1:

Input: [7, 1, 5, 3, 6, 4]
Output: 5

max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price)



Example 2:

Input: [7, 6, 4, 3, 1]
Output: 0

In this case, no transaction is done, i.e. max profit = 0.










## 122 - Best Time to Buy and Sell Stock II
~1~  ['Array', 'Greedy']
Say you have an array for which the ith element is the price of a given stock on day i.

Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).










## 123 - Best Time to Buy and Sell Stock III
~3~  ['Array', 'Dynamic Programming']
Say you have an array for which the ith element is the price of a given stock on day i.

Design an algorithm to find the maximum profit. You may complete at most two transactions.

Note:
You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).










## 124 - Binary Tree Maximum Path Sum
~3~  ['Tree', 'Depth-first Search']
Given a binary tree, find the maximum path sum.


For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root.


For example:
Given the below binary tree,

       1
      / \
     2   3



Return 6.










## 125 - Valid Palindrome
~1~  ['Two Pointers', 'String']
Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.



For example,
"A man, a plan, a canal: Panama" is a palindrome.
"race a car" is not a palindrome.



Note:
Have you consider that the string might be empty? This is a good question to ask during an interview.

For the purpose of this problem, we define empty string as valid palindrome.










## 126 - Word Ladder II
~3~  ['Array', 'String', 'Backtracking', 'Breadth-first Search']
Given two words (beginWord and endWord), and a dictionary's word list, find all shortest transformation sequence(s) from beginWord to endWord, such that:


Only one letter can be changed at a time
Each transformed word must exist in the word list. Note that beginWord is not a transformed word.



For example,


Given:
beginWord = "hit"
endWord = "cog"
wordList = ["hot","dot","dog","lot","log","cog"]


Return

  [
    ["hit","hot","dot","dog","cog"],
    ["hit","hot","lot","log","cog"]
  ]




Note:

Return an empty list if there is no such transformation sequence.
All words have the same length.
All words contain only lowercase alphabetic characters.
You may assume no duplicates in the word list.
You may assume beginWord and endWord are non-empty and are not the same.




UPDATE (2017/1/20):
The wordList parameter had been changed to a list of strings (instead of a set of strings). Please reload the code definition to get the latest changes.










## 127 - Word Ladder
~2~  []
Given two words (beginWord and endWord), and a dictionary's word list, find the length of shortest transformation sequence from beginWord to endWord, such that:


Only one letter can be changed at a time.
Each transformed word must exist in the word list. Note that beginWord is not a transformed word.



For example,


Given:
beginWord = "hit"
endWord = "cog"
wordList = ["hot","dot","dog","lot","log","cog"]


As one shortest transformation is "hit" -> "hot" -> "dot" -> "dog" -> "cog",
return its length 5.



Note:

Return 0 if there is no such transformation sequence.
All words have the same length.
All words contain only lowercase alphabetic characters.
You may assume no duplicates in the word list.
You may assume beginWord and endWord are non-empty and are not the same.




UPDATE (2017/1/20):
The wordList parameter had been changed to a list of strings (instead of a set of strings). Please reload the code definition to get the latest changes.










## 128 - Longest Consecutive Sequence
~3~  ['Array', 'Union Find']
Given an unsorted array of integers, find the length of the longest consecutive elements sequence.


For example,
Given [100, 4, 200, 1, 3, 2],
The longest consecutive elements sequence is [1, 2, 3, 4]. Return its length: 4.


Your algorithm should run in O(n) complexity.










## 129 - Sum Root to Leaf Numbers
~2~  ['Tree', 'Depth-first Search']
Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number.
An example is the root-to-leaf path 1->2->3 which represents the number 123.

Find the total sum of all root-to-leaf numbers.

For example,

    1
   / \
  2   3



The root-to-leaf path 1->2 represents the number 12.
The root-to-leaf path 1->3 represents the number 13.


Return the sum = 12 + 13 = 25.










## 130 - Surrounded Regions
~2~  ['Breadth-first Search', 'Union Find']
Given a 2D board containing 'X' and 'O' (the letter O), capture all regions surrounded by 'X'.

A region is captured by flipping all 'O's into 'X's in that surrounded region.



For example,

X X X X
X O O X
X X O X
X O X X




After running your function, the board should be:

X X X X
X X X X
X X X X
X O X X










## 131 - Palindrome Partitioning
~2~  ['Backtracking']
Given a string s, partition s such that every substring of the partition is a palindrome.


Return all possible palindrome partitioning of s.


For example, given s = "aab",

Return

[
  ["aa","b"],
  ["a","a","b"]
]










## 132 - Palindrome Partitioning II
~3~  ['Dynamic Programming']
Given a string s, partition s such that every substring of the partition is a palindrome.


Return the minimum cuts needed for a palindrome partitioning of s.


For example, given s = "aab",
Return 1 since the palindrome partitioning ["aa","b"] could be produced using 1 cut.










## 133 - Clone Graph
~2~  ['Depth-first Search', 'Breadth-first Search', 'Graph']
Clone an undirected graph. Each node in the graph contains a label and a list of its neighbors.




OJ's undirected graph serialization:


Nodes are labeled uniquely.


We use # as a separator for each node, and , as a separator for node label and each neighbor of the node.




As an example, consider the serialized graph {0,1,2#1,2#2,2}.



The graph has a total of three nodes, and therefore contains three parts as separated by #.

First node is labeled as 0. Connect node 0 to both nodes 1 and 2.
Second node is labeled as 1. Connect node 1 to node 2.
Third node is labeled as 2. Connect node 2 to node 2 (itself), thus forming a self-cycle.




Visually, the graph looks like the following:

       1
      / \
     /   \
    0 --- 2
         / \
         \_/










## 134 - Gas Station
~2~  ['Greedy']
There are N gas stations along a circular route, where the amount of gas at station i is gas[i].



You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations.



Return the starting gas station's index if you can travel around the circuit once, otherwise return -1.



Note:
The solution is guaranteed to be unique.










## 135 - Candy
~3~  ['Greedy']
There are N children standing in a line. Each child is assigned a rating value. 


You are giving candies to these children subjected to the following requirements:


Each child must have at least one candy.
Children with a higher rating get more candies than their neighbors.


What is the minimum candies you must give?










## 136 - Single Number
~1~  ['Hash Table', 'Bit Manipulation']
Given an array of integers, every element appears twice except for one. Find that single one.


Note:
Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?










## 137 - Single Number II
~2~  ['Bit Manipulation']
Given an array of integers, every element appears three times except for one, which appears exactly once. Find that single one.



Note:
Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?










## 138 - Copy List with Random Pointer
~2~  ['Hash Table', 'Linked List']
A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.



Return a deep copy of the list.










## 139 - Word Break
~2~  ['Dynamic Programming']
Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words. You may assume the dictionary does not contain duplicate words.


For example, given
s = "leetcode",
dict = ["leet", "code"].



Return true because "leetcode" can be segmented as "leet code".



UPDATE (2017/1/4):
The wordDict parameter had been changed to a list of strings (instead of a set of strings). Please reload the code definition to get the latest changes.










## 140 - Word Break II
~3~  ['Dynamic Programming', 'Backtracking']
Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, add spaces in s to construct a sentence where each word is a valid dictionary word. You may assume the dictionary does not contain duplicate words.



Return all such possible sentences.



For example, given
s = "catsanddog",
dict = ["cat", "cats", "and", "sand", "dog"].



A solution is ["cats and dog", "cat sand dog"].



UPDATE (2017/1/4):
The wordDict parameter had been changed to a list of strings (instead of a set of strings). Please reload the code definition to get the latest changes.










## 141 - Linked List Cycle
~1~  ['Linked List', 'Two Pointers']
Given a linked list, determine if it has a cycle in it.



Follow up:
Can you solve it without using extra space?










## 142 - Linked List Cycle II
~2~  ['Linked List', 'Two Pointers']
Given a linked list, return the node where the cycle begins. If there is no cycle, return null.



Note: Do not modify the linked list.


Follow up:
Can you solve it without using extra space?










## 143 - Reorder List
~2~  ['Linked List']
Given a singly linked list L: L0→L1→…→Ln-1→Ln,
reorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→…


You must do this in-place without altering the nodes' values.


For example,
Given {1,2,3,4}, reorder it to {1,4,2,3}.










## 144 - Binary Tree Preorder Traversal
~2~  ['Stack', 'Tree']
Given a binary tree, return the preorder traversal of its nodes' values.


For example:
Given binary tree [1,null,2,3],

   1
    \
     2
    /
   3



return [1,2,3].


Note: Recursive solution is trivial, could you do it iteratively?










## 145 - Binary Tree Postorder Traversal
~3~  ['Stack', 'Tree']
Given a binary tree, return the postorder traversal of its nodes' values.


For example:
Given binary tree {1,#,2,3},

   1
    \
     2
    /
   3



return [3,2,1].


Note: Recursive solution is trivial, could you do it iteratively?










## 146 - LRU Cache
~3~  ['Design']
Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put.



get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.
put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.


Follow up:
Could you do both operations in O(1) time complexity?

Example:

LRUCache cache = new LRUCache( 2 /* capacity */ );

cache.put(1, 1);
cache.put(2, 2);
cache.get(1);       // returns 1
cache.put(3, 3);    // evicts key 2
cache.get(2);       // returns -1 (not found)
cache.put(4, 4);    // evicts key 1
cache.get(1);       // returns -1 (not found)
cache.get(3);       // returns 3
cache.get(4);       // returns 4










## 147 - Insertion Sort List
~2~  ['Linked List', 'Sort']
Sort a linked list using insertion sort.










## 148 - Sort List
~2~  ['Linked List', 'Sort']
Sort a linked list in O(n log n) time using constant space complexity.










## 149 - Max Points on a Line
~3~  ['Hash Table', 'Math']
Given n points on a 2D plane, find the maximum number of points that lie on the same straight line.










## 150 - Evaluate Reverse Polish Notation
~2~  ['Stack']
Evaluate the value of an arithmetic expression in Reverse Polish Notation.



Valid operators are +, -, *, /. Each operand may be an integer or another expression.



Some examples:

  ["2", "1", "+", "3", "*"] -> ((2 + 1) * 3) -> 9
  ["4", "13", "5", "/", "+"] -> (4 + (13 / 5)) -> 6










## 151 - Reverse Words in a String
~2~  ['String']
Given an input string, reverse the string word by word.



For example,
Given s = "the sky is blue",
return "blue is sky the".



Update (2015-02-12):
For C programmers: Try to solve it in-place in O(1) space.


click to show clarification.

Clarification:



What constitutes a word?
A sequence of non-space characters constitutes a word.
Could the input string contain leading or trailing spaces?
Yes. However, your reversed string should not contain leading or trailing spaces.
How about multiple spaces between two words?
Reduce them to a single space in the reversed string.










## 152 - Maximum Product Subarray
~2~  ['Array', 'Dynamic Programming']
Find the contiguous subarray within an array (containing at least one number) which has the largest product.



For example, given the array [2,3,-2,4],
the contiguous subarray [2,3] has the largest product = 6.










## 153 - Find Minimum in Rotated Sorted Array
~2~  ['Array', 'Binary Search']
Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.

(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).

Find the minimum element.

You may assume no duplicate exists in the array.










## 154 - Find Minimum in Rotated Sorted Array II
~3~  ['Array', 'Binary Search']
Follow up for "Find Minimum in Rotated Sorted Array":
What if duplicates are allowed?

Would this affect the run-time complexity? How and why?


Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.

(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).

Find the minimum element.

The array may contain duplicates.










## 155 - Min Stack
~1~  ['Stack', 'Design']
Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.


push(x) -- Push element x onto stack.


pop() -- Removes the element on top of the stack.


top() -- Get the top element.


getMin() -- Retrieve the minimum element in the stack.




Example:

MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> Returns -3.
minStack.pop();
minStack.top();      --> Returns 0.
minStack.getMin();   --> Returns -2.










## 156 - Binary Tree Upside Down
~2~  []
Given a binary tree where all the right nodes are either leaf nodes with a
sibling (a left node that shares the same parent node) or empty, flip it
upside down and turn it into a tree where the original right nodes turned into
left leaf nodes. Return the new root.

For example:

Given a binary tree {1,2,3,4,5},

    1

   / \

  2   3

 / \

4   5

return the root of the binary tree [4,5,2,#,#,3,1].

   4

  / \

 5   2

    / \

   3   1










## 157 - Read N Characters Given Read4
~1~  []
The API: int read4(char *buf) reads 4 characters at a time from a file.
The return value is the actual number of characters read. For example, it
returns 3 if there is only 3 characters left in the file.
By using the read4 API, implement the function int read(char *buf, int n) that
reads n characters from the file.
Note:
The read function will only be called once for each test case.










## 158 - Read N Characters Given Read4 II - Call multiple times
~3~  []
The API: int read4(char *buf) reads 4 characters at a time from a file.

The return value is the actual number of characters read. For example, it
returns 3 if there is only 3 characters left in the file.

By using the read4 API, implement the function int read(char *buf, int n) that
reads n characters from the file.

Note:
The read function may be called multiple times.










## 159 - Longest Substring with At Most Two Distinct Characters
~3~  []
Given a string S, find the length of the longest substring T that contains at
most two distinct characters.
For example,
Given S = "eceba",
T is "ece" which its length is 3.










## 160 - Intersection of Two Linked Lists
~1~  ['Linked List']
Write a program to find the node at which the intersection of two singly linked lists begins.

For example, the following two linked lists: 

A:          a1 → a2
                   ↘
                     c1 → c2 → c3
                   ↗            
B:     b1 → b2 → b3

begin to intersect at node c1.

Notes:

If the two linked lists have no intersection at all, return null.
The linked lists must retain their original structure after the function returns. 
You may assume there are no cycles anywhere in the entire linked structure.
Your code should preferably run in O(n) time and use only O(1) memory.



Credits:Special thanks to @stellari for adding this problem and creating all test cases.










## 161 - One Edit Distance
~2~  []
Given two strings S and T, determine if they are both one edit distance apart.










## 162 - Find Peak Element
~2~  ['Array', 'Binary Search']
A peak element is an element that is greater than its neighbors.

Given an input array where num[i] ≠ num[i+1], find a peak element and return its index.

The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.

You may imagine that num[-1] = num[n] = -∞.

For example, in array [1, 2, 3, 1], 3 is a peak element and your function should return the index number 2.

click to show spoilers.

Note:
Your solution should be in logarithmic complexity.


Credits:Special thanks to @ts for adding this problem and creating all test cases.










## 163 - Missing Ranges
~2~  []
Given a sorted integer array where the range of elements are [0, 99]
inclusive, return its missing ranges.
For example, given [0, 1, 3, 50, 75], return ["2", "4->49", "51->74",
"76->99"]










## 164 - Maximum Gap
~3~  ['Sort']
Given an unsorted array, find the maximum difference between the successive elements in its sorted form.

Try to solve it in linear time/space.

Return 0 if the array contains less than 2 elements.

You may assume all elements in the array are non-negative integers and fit in the 32-bit signed integer range.

Credits:Special thanks to @porker2008 for adding this problem and creating all test cases.










## 165 - Compare Version Numbers
~2~  ['String']
Compare two version numbers version1 and version2.
If version1 > version2 return 1, if version1 < version2 return -1, otherwise return 0.

You may assume that the version strings are non-empty and contain only digits and the . character.
The . character does not represent a decimal point and is used to separate number sequences.
For instance, 2.5 is not "two and a half" or "half way to version three", it is the fifth second-level revision of the second first-level revision.

Here is an example of version numbers ordering:
0.1 < 1.1 < 1.2 < 13.37

Credits:Special thanks to @ts for adding this problem and creating all test cases.










## 166 - Fraction to Recurring Decimal
~2~  ['Hash Table', 'Math']
Given two integers representing the numerator and denominator of a fraction, return the fraction in string format.

If the fractional part is repeating, enclose the repeating part in parentheses.

For example,

Given numerator = 1, denominator = 2, return "0.5".
Given numerator = 2, denominator = 1, return "2".
Given numerator = 2, denominator = 3, return "0.(6)".



Credits:Special thanks to @Shangrila for adding this problem and creating all test cases.










## 167 - Two Sum II - Input array is sorted
~1~  ['Array', 'Two Pointers', 'Binary Search']
Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number.

The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.

You may assume that each input would have exactly one solution and you may not use the same element twice.


Input: numbers={2, 7, 11, 15}, target=9
Output: index1=1, index2=2










## 168 - Excel Sheet Column Title
~1~  ['Math']
Given a positive integer, return its corresponding column title as appear in an Excel sheet.

For example:

    1 -> A
    2 -> B
    3 -> C
    ...
    26 -> Z
    27 -> AA
    28 -> AB 

Credits:Special thanks to @ifanchu for adding this problem and creating all test cases.










## 169 - Majority Element
~1~  ['Array', 'Divide and Conquer', 'Bit Manipulation']
Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.

You may assume that the array is non-empty and the majority element always exist in the array.

Credits:Special thanks to @ts for adding this problem and creating all test cases.










## 170 - Two Sum III - Data structure design
~1~  []
Design and implement a TwoSum class. It should support the following
operations:add and find.

add - Add the number to an internal data structure.
find - Find if there exists any pair of numbers which sum is equal to the
value.

For example,
add(1); add(3); add(5);
find(4) -> true
find(7) -> false










## 171 - Excel Sheet Column Number
~1~  ['Math']
Related to question Excel Sheet Column Title
Given a column title as appear in an Excel sheet, return its corresponding column number.

For example:
    A -> 1
    B -> 2
    C -> 3
    ...
    Z -> 26
    AA -> 27
    AB -> 28 

Credits:Special thanks to @ts for adding this problem and creating all test cases.










## 172 - Factorial Trailing Zeroes
~1~  ['Math']
Given an integer n, return the number of trailing zeroes in n!.

Note: Your solution should be in logarithmic time complexity.

Credits:Special thanks to @ts for adding this problem and creating all test cases.










## 173 - Binary Search Tree Iterator
~2~  ['Stack', 'Tree', 'Design']
Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.

Calling next() will return the next smallest number in the BST.

Note: next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree. 

Credits:Special thanks to @ts for adding this problem and creating all test cases.










## 174 - Dungeon Game
~3~  ['Binary Search', 'Dynamic Programming']
table.dungeon, .dungeon th, .dungeon td {
  border:3px solid black;
}

 .dungeon th, .dungeon td {
    text-align: center;
    height: 70px;
    width: 70px;
}


The demons had captured the princess (P) and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of M x N rooms laid out in a 2D grid. Our valiant knight (K) was initially positioned in the top-left room and must fight his way through the dungeon to rescue the princess. 
The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately. 
Some of the rooms are guarded by demons, so the knight loses health (negative integers) upon entering these rooms; 
other rooms are either empty (0's) or contain magic orbs that increase the knight's health (positive integers).
In order to reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step. 


Write a function to determine the knight's minimum initial health so that he is able to rescue the princess.
For example, given the dungeon below, the initial health of the knight must be at least 7 if he follows the optimal path RIGHT-> RIGHT -> DOWN -> DOWN.


 
-2 (K) 
-3 
3 
 
 
-5 
-10 
1 
 
 
10 
30 
-5 (P) 
 




Notes:

The knight's health has no upper bound.
Any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned.  



Credits:Special thanks to @stellari for adding this problem and creating all test cases.










## 175 - Combine Two Tables
~1~  []
Table: Person


+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| PersonId    | int     |
| FirstName   | varchar |
| LastName    | varchar |
+-------------+---------+
PersonId is the primary key column for this table.



Table: Address

+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| AddressId   | int     |
| PersonId    | int     |
| City        | varchar |
| State       | varchar |
+-------------+---------+
AddressId is the primary key column for this table.




Write a SQL query for a report that provides the following information for 
each person in the Person table, regardless if there is an address for each 
of those people:



FirstName, LastName, City, State










## 176 - Second Highest Salary
~1~  []
Write a SQL query to get the second highest salary from the Employee table.



+----+--------+
| Id | Salary |
+----+--------+
| 1  | 100    |
| 2  | 200    |
| 3  | 300    |
+----+--------+


For example, given the above Employee table, the query should return 200 as the second highest salary. If there is no second highest salary, then the query should return null.


+---------------------+
| SecondHighestSalary |
+---------------------+
| 200                 |
+---------------------+










## 177 - Nth Highest Salary
~2~  []
Write a SQL query to get the nth highest salary from the Employee table.



+----+--------+
| Id | Salary |
+----+--------+
| 1  | 100    |
| 2  | 200    |
| 3  | 300    |
+----+--------+


For example, given the above Employee table, the nth highest salary where n = 2 is 200. If there is no nth highest salary, then the query should return null.


+------------------------+
| getNthHighestSalary(2) |
+------------------------+
| 200                    |
+------------------------+










## 178 - Rank Scores
~2~  []
Write a SQL query to rank scores. If there is a tie between two scores, both should have the same ranking. Note that after a tie, the next ranking number should be the next consecutive integer value. In other words, there should be no "holes" between ranks.



+----+-------+
| Id | Score |
+----+-------+
| 1  | 3.50  |
| 2  | 3.65  |
| 3  | 4.00  |
| 4  | 3.85  |
| 5  | 4.00  |
| 6  | 3.65  |
+----+-------+


For example, given the above Scores table, your query should generate the following report (order by highest score):


+-------+------+
| Score | Rank |
+-------+------+
| 4.00  | 1    |
| 4.00  | 1    |
| 3.85  | 2    |
| 3.65  | 3    |
| 3.65  | 3    |
| 3.50  | 4    |
+-------+------+










## 179 - Largest Number
~2~  ['Sort']
Given a list of non negative integers, arrange them such that they form the largest number.

For example, given [3, 30, 34, 5, 9], the largest formed number is 9534330.

Note: The result may be very large, so you need to return a string instead of an integer.

Credits:Special thanks to @ts for adding this problem and creating all test cases.










## 180 - Consecutive Numbers
~2~  []
Write a SQL query to find all numbers that appear at least three times consecutively.


+----+-----+
| Id | Num |
+----+-----+
| 1  |  1  |
| 2  |  1  |
| 3  |  1  |
| 4  |  2  |
| 5  |  1  |
| 6  |  2  |
| 7  |  2  |
+----+-----+


For example, given the above Logs table, 1 is the only number that appears consecutively for at least three times.


+-----------------+
| ConsecutiveNums |
+-----------------+
| 1               |
+-----------------+










## 181 - Employees Earning More Than Their Managers
~1~  []
The Employee table holds all employees including their managers. Every employee has an Id, and there is also a column for the manager Id.


+----+-------+--------+-----------+
| Id | Name  | Salary | ManagerId |
+----+-------+--------+-----------+
| 1  | Joe   | 70000  | 3         |
| 2  | Henry | 80000  | 4         |
| 3  | Sam   | 60000  | NULL      |
| 4  | Max   | 90000  | NULL      |
+----+-------+--------+-----------+


Given the Employee table, write a SQL query that finds out employees who earn more than their managers. For the above table, Joe is the only employee who earns more than his manager.


+----------+
| Employee |
+----------+
| Joe      |
+----------+










## 182 - Duplicate Emails
~1~  []
Write a SQL query to find all duplicate emails in a table named Person.


+----+---------+
| Id | Email   |
+----+---------+
| 1  | a@b.com |
| 2  | c@d.com |
| 3  | a@b.com |
+----+---------+


For example, your query should return the following for the above table:

+---------+
| Email   |
+---------+
| a@b.com |
+---------+


Note: All emails are in lowercase.










## 183 - Customers Who Never Order
~1~  []
Suppose that a website contains two tables, the Customers table and the Orders table. Write a SQL query to find all customers who never order anything.


Table: Customers.

+----+-------+
| Id | Name  |
+----+-------+
| 1  | Joe   |
| 2  | Henry |
| 3  | Sam   |
| 4  | Max   |
+----+-------+



Table: Orders.

+----+------------+
| Id | CustomerId |
+----+------------+
| 1  | 3          |
| 2  | 1          |
+----+------------+


Using the above tables as example, return the following:

+-----------+
| Customers |
+-----------+
| Henry     |
| Max       |
+-----------+










## 184 - Department Highest Salary
~2~  []
The Employee table holds all employees. Every employee has an Id, a salary, and there is also a column for the department Id.


+----+-------+--------+--------------+
| Id | Name  | Salary | DepartmentId |
+----+-------+--------+--------------+
| 1  | Joe   | 70000  | 1            |
| 2  | Henry | 80000  | 2            |
| 3  | Sam   | 60000  | 2            |
| 4  | Max   | 90000  | 1            |
+----+-------+--------+--------------+



The Department table holds all departments of the company.

+----+----------+
| Id | Name     |
+----+----------+
| 1  | IT       |
| 2  | Sales    |
+----+----------+


Write a SQL query to find employees who have the highest salary in each of the departments. For the above tables, Max has the highest salary in the IT department and Henry has the highest salary in the Sales department.


+------------+----------+--------+
| Department | Employee | Salary |
+------------+----------+--------+
| IT         | Max      | 90000  |
| Sales      | Henry    | 80000  |
+------------+----------+--------+










## 185 - Department Top Three Salaries
~3~  []
The Employee table holds all employees. Every employee has an Id, and there is also a column for the department Id.


+----+-------+--------+--------------+
| Id | Name  | Salary | DepartmentId |
+----+-------+--------+--------------+
| 1  | Joe   | 70000  | 1            |
| 2  | Henry | 80000  | 2            |
| 3  | Sam   | 60000  | 2            |
| 4  | Max   | 90000  | 1            |
| 5  | Janet | 69000  | 1            |
| 6  | Randy | 85000  | 1            |
+----+-------+--------+--------------+



The Department table holds all departments of the company.

+----+----------+
| Id | Name     |
+----+----------+
| 1  | IT       |
| 2  | Sales    |
+----+----------+


Write a SQL query to find employees who earn the top three salaries in each of the department. For the above tables, your SQL query should return the following rows.


+------------+----------+--------+
| Department | Employee | Salary |
+------------+----------+--------+
| IT         | Max      | 90000  |
| IT         | Randy    | 85000  |
| IT         | Joe      | 70000  |
| Sales      | Henry    | 80000  |
| Sales      | Sam      | 60000  |
+------------+----------+--------+










## 186 - Reverse Words in a String II
~2~  []
Given an input string, reverse the string word by word. A word is defined as a
sequence of non-space characters.
The input string does not contain leading or trailing spaces and the words are
always separated by a single space.
For example,
Given s = "the sky is blue",
return "blue is sky the".
Could you do it in-place without allocating extra space?










## 187 - Repeated DNA Sequences
~2~  ['Hash Table', 'Bit Manipulation']
All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: "ACGAATTCCG". When studying DNA, it is sometimes useful to identify repeated sequences within the DNA.

Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule.


For example,

Given s = "AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT",

Return:
["AAAAACCCCC", "CCCCCAAAAA"].










## 188 - Best Time to Buy and Sell Stock IV
~3~  ['Dynamic Programming']
Say you have an array for which the ith element is the price of a given stock on day i.

Design an algorithm to find the maximum profit. You may complete at most k transactions.

Note:
You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).

Credits:Special thanks to @Freezen for adding this problem and creating all test cases.










## 189 - Rotate Array
~1~  ['Array']
Rotate an array of n elements to the right by k steps.
For example, with n = 7 and k = 3, the array [1,2,3,4,5,6,7] is rotated to [5,6,7,1,2,3,4]. 

Note:
Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.


[show hint]
Hint:
Could you do it in-place with O(1) extra space?


Related problem: Reverse Words in a String II

Credits:Special thanks to @Freezen for adding this problem and creating all test cases.










## 190 - Reverse Bits
~1~  ['Bit Manipulation']
Reverse bits of a given 32 bits unsigned integer.

For example, given input 43261596 (represented in binary as 00000010100101000001111010011100), return 964176192 (represented in binary as 00111001011110000010100101000000).


Follow up:
If this function is called many times, how would you optimize it?


Related problem: Reverse Integer

Credits:Special thanks to @ts for adding this problem and creating all test cases.










## 191 - Number of 1 Bits
~1~  ['Bit Manipulation']
Write a function that takes an unsigned integer and returns the number of ’1' bits it has (also known as the Hamming weight).

For example, the 32-bit integer ’11' has binary representation 00000000000000000000000000001011, so the function should return 3.

Credits:Special thanks to @ts for adding this problem and creating all test cases.










## 192 - Word Frequency
~2~  []
Write a bash script to calculate the frequency of each word in a text file words.txt.

For simplicity sake, you may assume:

words.txt contains only lowercase characters and space ' ' characters.
Each word must consist of lowercase characters only.
Words are separated by one or more whitespace characters.



For example, assume that words.txt has the following content:
the day is sunny the the
the sunny is is


Your script should output the following, sorted by descending frequency:

the 4
is 3
sunny 2
day 1



Note:
Don't worry about handling ties, it is guaranteed that each word's frequency count is unique.


[show hint]
Hint:
Could you write it in one-line using Unix pipes?










## 193 - Valid Phone Numbers
~1~  []
Given a text file file.txt that contains list of phone numbers (one per line), write a one liner bash script to print all valid phone numbers.

You may assume that a valid phone number must appear in one of the following two formats: (xxx) xxx-xxxx or xxx-xxx-xxxx. (x means a digit)

You may also assume each line in the text file must not contain leading or trailing white spaces.

For example, assume that file.txt has the following content:

987-123-4567
123 456 7890
(123) 456-7890


Your script should output the following valid phone numbers:

987-123-4567
(123) 456-7890










## 194 - Transpose File
~2~  []
Given a text file file.txt, transpose its content.

You may assume that each row has the same number of columns and each field is separated by the ' ' character.


For example, if file.txt has the following content:

name age
alice 21
ryan 30




Output the following:

name alice ryan
age 21 30










## 195 - Tenth Line
~1~  []
How would you print just the 10th line of a file?

For example, assume that file.txt has the following content:

Line 1
Line 2
Line 3
Line 4
Line 5
Line 6
Line 7
Line 8
Line 9
Line 10


Your script should output the tenth line, which is:

Line 10


[show hint]
Hint:
1. If the file contains less than 10 lines, what should you output?
2. There's at least three different solutions. Try to explore all possibilities.










## 196 - Delete Duplicate Emails
~1~  []
Write a SQL query to delete all duplicate email entries in a table named Person, keeping only unique emails based on its smallest Id.


+----+------------------+
| Id | Email            |
+----+------------------+
| 1  | john@example.com |
| 2  | bob@example.com  |
| 3  | john@example.com |
+----+------------------+
Id is the primary key column for this table.


For example, after running your query, the above Person table should have the following rows:

+----+------------------+
| Id | Email            |
+----+------------------+
| 1  | john@example.com |
| 2  | bob@example.com  |
+----+------------------+










## 197 - Rising Temperature
~1~  []
Given a Weather table, write a SQL query to find all dates' Ids with higher temperature compared to its previous (yesterday's) dates.


+---------+------------+------------------+
| Id(INT) | Date(DATE) | Temperature(INT) |
+---------+------------+------------------+
|       1 | 2015-01-01 |               10 |
|       2 | 2015-01-02 |               25 |
|       3 | 2015-01-03 |               20 |
|       4 | 2015-01-04 |               30 |
+---------+------------+------------------+


For example, return the following Ids for the above Weather table:

+----+
| Id |
+----+
|  2 |
|  4 |
+----+










## 198 - House Robber
~1~  ['Dynamic Programming']
You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.

Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.

Credits:Special thanks to @ifanchu for adding this problem and creating all test cases. Also thanks to @ts for adding additional test cases.










## 199 - Binary Tree Right Side View
~2~  ['Tree', 'Depth-first Search', 'Breadth-first Search']
Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.


For example:
Given the following binary tree,

   1            <---
 /   \
2     3         <---
 \     \
  5     4       <---



You should return [1, 3, 4].


Credits:Special thanks to @amrsaqr for adding this problem and creating all test cases.










## 200 - Number of Islands
~2~  ['Depth-first Search', 'Breadth-first Search', 'Union Find']
Given a 2d grid map of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.

Example 1:
11110110101100000000
Answer: 1
Example 2:
11000110000010000011
Answer: 3

Credits:Special thanks to @mithmatt for adding this problem and creating all test cases.










## 201 - Bitwise AND of Numbers Range
~2~  ['Bit Manipulation']
Given a range [m, n] where 0 <= m <= n <= 2147483647, return the bitwise AND of all numbers in this range, inclusive.


For example, given the range [5, 7], you should return 4.


Credits:Special thanks to @amrsaqr for adding this problem and creating all test cases.










## 202 - Happy Number
~1~  ['Hash Table', 'Math']
Write an algorithm to determine if a number is "happy".

A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.

Example: 19 is a happy number


12 + 92 = 82
82 + 22 = 68
62 + 82 = 100
12 + 02 + 02 = 1


Credits:Special thanks to @mithmatt and @ts for adding this problem and creating all test cases.










## 203 - Remove Linked List Elements
~1~  ['Linked List']
Remove all elements from a linked list of integers that have value val.

Example
Given: 1 --> 2 --> 6 --> 3 --> 4 --> 5 --> 6,  val = 6
Return: 1 --> 2 --> 3 --> 4 --> 5


Credits:Special thanks to @mithmatt for adding this problem and creating all test cases.










## 204 - Count Primes
~1~  ['Hash Table', 'Math']
Description:
Count the number of prime numbers less than a non-negative number, n.

Credits:Special thanks to @mithmatt for adding this problem and creating all test cases.










## 205 - Isomorphic Strings
~1~  ['Hash Table']
Given two strings s and t, determine if they are isomorphic.

Two strings are isomorphic if the characters in s can be replaced to get t.

All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself.

For example,
Given "egg", "add", return true.

Given "foo", "bar", return false.

Given "paper", "title", return true.

Note:
You may assume both s and t have the same length.










## 206 - Reverse Linked List
~1~  ['Linked List']
Reverse a singly linked list.

click to show more hints.

Hint:
A linked list can be reversed either iteratively or recursively. Could you implement both?










## 207 - Course Schedule
~2~  ['Depth-first Search', 'Breadth-first Search', 'Graph', 'Topological Sort']
There are a total of n courses you have to take, labeled from 0 to n - 1.

Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]


Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?


For example:
2, [[1,0]]
There are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible.

2, [[1,0],[0,1]]
There are a total of 2 courses to take. To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.

Note:

The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented.
You may assume that there are no duplicate edges in the input prerequisites.



click to show more hints.

Hints:

This problem is equivalent to finding if a cycle exists in a directed graph. If a cycle exists, no topological ordering exists and therefore it will be impossible to take all courses.
Topological Sort via DFS - A great video tutorial (21 minutes) on Coursera explaining the basic concepts of Topological Sort.
Topological sort could also be done via BFS.










## 208 - Implement Trie (Prefix Tree)
~2~  ['Design', 'Trie']
Implement a trie with insert, search, and startsWith methods.



Note:
You may assume that all inputs are consist of lowercase letters a-z.










## 209 - Minimum Size Subarray Sum
~2~  ['Array', 'Two Pointers', 'Binary Search']
Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum ≥ s. If there isn't one, return 0 instead.


For example, given the array [2,3,1,2,4,3] and s = 7,
the subarray [4,3] has the minimal length under the problem constraint.


click to show more practice.

More practice:

If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log n).


Credits:Special thanks to @Freezen for adding this problem and creating all test cases.










## 210 - Course Schedule II
~2~  ['Depth-first Search', 'Breadth-first Search', 'Graph', 'Topological Sort']
There are a total of n courses you have to take, labeled from 0 to n - 1.

Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]


Given the total number of courses and a list of prerequisite pairs, return the ordering of courses you should take to finish all courses.

There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array.


For example:
2, [[1,0]]
There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1]

4, [[1,0],[2,0],[3,1],[3,2]]
There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0. So one correct course order is [0,1,2,3]. Another correct ordering is[0,2,1,3].

Note:

The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented.
You may assume that there are no duplicate edges in the input prerequisites.



click to show more hints.

Hints:

This problem is equivalent to finding the topological order in a directed graph. If a cycle exists, no topological ordering exists and therefore it will be impossible to take all courses.
Topological Sort via DFS - A great video tutorial (21 minutes) on Coursera explaining the basic concepts of Topological Sort.
Topological sort could also be done via BFS.










## 211 - Add and Search Word - Data structure design
~2~  ['Backtracking', 'Design', 'Trie']
Design a data structure that supports the following two operations:


void addWord(word)
bool search(word)



search(word) can search a literal word or a regular expression string containing only letters a-z or .. A . means it can represent any one letter.


For example:

addWord("bad")
addWord("dad")
addWord("mad")
search("pad") -> false
search("bad") -> true
search(".ad") -> true
search("b..") -> true



Note:
You may assume that all words are consist of lowercase letters a-z.


click to show hint.

You should be familiar with how a Trie works. If not, please work on this problem: Implement Trie (Prefix Tree) first.










## 212 - Word Search II
~3~  ['Backtracking', 'Trie']
Given a 2D board and a list of words from the dictionary, find all words in the board.


Each word must be constructed from letters of sequentially adjacent cell, where "adjacent" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.



For example,
Given words = ["oath","pea","eat","rain"] and board = 

[
  ['o','a','a','n'],
  ['e','t','a','e'],
  ['i','h','k','r'],
  ['i','f','l','v']
]


Return ["eat","oath"].



Note:
You may assume that all inputs are consist of lowercase letters a-z.


click to show hint.

You would need to optimize your backtracking to pass the larger test. Could you stop backtracking earlier?

If the current candidate does not exist in all words' prefix, you could stop backtracking immediately. What kind of data structure could answer such query efficiently? Does a hash table work? Why or why not? How about a Trie? If you would like to learn how to implement a basic trie, please work on this problem: Implement Trie (Prefix Tree) first.










## 213 - House Robber II
~2~  ['Dynamic Programming']
Note: This is an extension of House Robber.

After robbing those houses on that street, the thief has found himself a new place for his thievery so that he will not get too much attention. This time, all houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, the security system for these houses remain the same as for those in the previous street. 

Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.

Credits:Special thanks to @Freezen for adding this problem and creating all test cases.










## 214 - Shortest Palindrome
~3~  ['String']
Given a string S, you are allowed to convert it to a palindrome by adding characters in front of it. Find and return the shortest palindrome you can find by performing this transformation.


For example: 
Given "aacecaaa", return "aaacecaaa".
Given "abcd", return "dcbabcd".

Credits:Special thanks to @ifanchu for adding this problem and creating all test cases. Thanks to @Freezen for additional test cases.










## 215 - Kth Largest Element in an Array
~2~  ['Divide and Conquer', 'Heap']
Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.

For example,
Given [3,2,1,5,6,4] and k = 2, return 5.


Note: 
You may assume k is always valid, 1 ≤ k ≤ array's length.

Credits:Special thanks to @mithmatt for adding this problem and creating all test cases.










## 216 - Combination Sum III
~2~  ['Array', 'Backtracking']
Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.



 Example 1:
Input:  k = 3,  n = 7
Output: 

[[1,2,4]]


 Example 2:
Input:  k = 3,  n = 9
Output: 

[[1,2,6], [1,3,5], [2,3,4]]



Credits:Special thanks to @mithmatt for adding this problem and creating all test cases.










## 217 - Contains Duplicate
~1~  ['Array', 'Hash Table']
Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.










## 218 - The Skyline Problem
~3~  ['Divide and Conquer', 'Heap', 'Binary Indexed Tree', 'Segment Tree']
A city's skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Now suppose you are given the locations and height of all the buildings as shown on a cityscape photo (Figure A), write a program to output the skyline formed by these buildings collectively (Figure B).



    




    





The geometric information of each building is represented by a triplet of integers [Li, Ri, Hi], where Li and Ri are the x coordinates of the left and right edge of the ith building, respectively, and Hi is its height. It is guaranteed that 0 ≤ Li, Ri ≤ INT_MAX, 0 < Hi ≤ INT_MAX, and Ri - Li > 0. You may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height 0.

For instance, the dimensions of all buildings in Figure A are recorded as: [ [2 9 10], [3 7 15], [5 12 12], [15 20 10], [19 24 8] ] .

The output is a list of "key points" (red dots in Figure B) in the format of [ [x1,y1], [x2, y2], [x3, y3], ... ] that uniquely defines a skyline. A key point is the left endpoint of a horizontal line segment. Note that the last key point, where the rightmost building ends, is merely used to mark the termination of the skyline, and always has zero height. Also, the ground in between any two adjacent buildings should be considered part of the skyline contour.

For instance, the skyline in Figure B should be represented as:[ [2 10], [3 15], [7 12], [12 0], [15 10], [20 8], [24, 0] ].

Notes:

 The number of buildings in any input list is guaranteed to be in the range [0, 10000].
 The input list is already sorted in ascending order by the left x position Li. 
 The output list must be sorted by the x position. 
 There must be no consecutive horizontal lines of equal height in the output skyline. For instance, [...[2 3], [4 5], [7 5], [11 5], [12 7]...] is not acceptable; the three lines of height 5 should be merged into one in the final output as such: [...[2 3], [4 5], [12 7], ...]



Credits:Special thanks to @stellari for adding this problem, creating these two awesome images and all test cases.










## 219 - Contains Duplicate II
~1~  ['Array', 'Hash Table']
Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the absolute difference between i and j is at most k.










## 220 - Contains Duplicate III
~2~  ['Binary Search Tree']
Given an array of integers, find out whether there are two distinct indices i and j in the array such that the absolute difference between nums[i] and nums[j] is at most t and the absolute difference between i and j is at most k.










## 221 - Maximal Square
~2~  ['Dynamic Programming']
Given a 2D binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area.


For example, given the following matrix:

1 0 1 0 0
1 0 1 1 1
1 1 1 1 1
1 0 0 1 0

Return 4.


Credits:Special thanks to @Freezen for adding this problem and creating all test cases.










## 222 - Count Complete Tree Nodes
~2~  ['Binary Search', 'Tree']
Given a complete binary tree, count the number of nodes.

Definition of a complete binary tree from Wikipedia:
In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.










## 223 - Rectangle Area
~2~  ['Math']
Find the total area covered by two rectilinear rectangles in a 2D plane.
Each rectangle is defined by its bottom left corner and top right corner as shown in the figure.




Assume that the total area is never beyond the maximum possible value of int.


Credits:Special thanks to @mithmatt for adding this problem, creating the above image and all test cases.










## 224 - Basic Calculator
~3~  ['Math', 'Stack']
Implement a basic calculator to evaluate a simple expression string.

The expression string may contain open ( and closing parentheses ), the plus + or minus sign -, non-negative integers and empty spaces  .

You may assume that the given expression is always valid.

Some examples:

"1 + 1" = 2
" 2-1 + 2 " = 3
"(1+(4+5+2)-3)+(6+8)" = 23




Note: Do not use the eval built-in library function.










## 225 - Implement Stack using Queues
~1~  ['Stack', 'Design']
Implement the following operations of a stack using queues.


push(x) -- Push element x onto stack.


pop() -- Removes the element on top of the stack.


top() -- Get the top element.


empty() -- Return whether the stack is empty.


Notes:

You must use only standard operations of a queue -- which means only push to back, peek/pop from front, size, and is empty operations are valid.
Depending on your language, queue may not be supported natively. You may simulate a queue by using a list or deque (double-ended queue), as long as you use only standard operations of a queue.
You may assume that all operations are valid (for example, no pop or top operations will be called on an empty stack).



Credits:Special thanks to @jianchao.li.fighter for adding this problem and all test cases.










## 226 - Invert Binary Tree
~1~  ['Tree']
Invert a binary tree.
     4
   /   \
  2     7
 / \   / \
1   3 6   9

to
     4
   /   \
  7     2
 / \   / \
9   6 3   1

Trivia:
This problem was inspired by this original tweet by Max Howell:
Google: 90% of our engineers use the software you wrote (Homebrew), but you can’t invert a binary tree on a whiteboard so fuck off.










## 227 - Basic Calculator II
~2~  ['String']
Implement a basic calculator to evaluate a simple expression string.

The expression string contains only non-negative integers, +, -, *, / operators and empty spaces  . The integer division should truncate toward zero.

You may assume that the given expression is always valid.

Some examples:

"3+2*2" = 7
" 3/2 " = 1
" 3+5 / 2 " = 5




Note: Do not use the eval built-in library function.


Credits:Special thanks to @ts for adding this problem and creating all test cases.










## 228 - Summary Ranges
~2~  ['Array']
Given a sorted integer array without duplicates, return the summary of its ranges.

Example 1:

Input: [0,1,2,4,5,7]
Output: ["0->2","4->5","7"]



Example 2:

Input: [0,2,3,4,6,8,9]
Output: ["0","2->4","6","8->9"]



Credits:Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.










## 229 - Majority Element II
~2~  ['Array']
Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times. The algorithm should run in linear time and in O(1) space.










## 230 - Kth Smallest Element in a BST
~2~  ['Binary Search', 'Tree']
Given a binary search tree, write a function kthSmallest to find the kth smallest element in it.

Note: 
You may assume k is always valid, 1 ≤ k ≤ BST's total elements.

Follow up:
What if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?

Credits:Special thanks to @ts for adding this problem and creating all test cases.










## 231 - Power of Two
~1~  ['Math', 'Bit Manipulation']
Given an integer, write a function to determine if it is a power of two.


Credits:Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.










## 232 - Implement Queue using Stacks
~1~  ['Stack', 'Design']
Implement the following operations of a queue using stacks.


push(x) -- Push element x to the back of queue.


pop() -- Removes the element from in front of queue.


peek() -- Get the front element.


empty() -- Return whether the queue is empty.


Notes:

You must use only standard operations of a stack -- which means only push to top, peek/pop from top, size, and is empty operations are valid.
Depending on your language, stack may not be supported natively. You may simulate a stack by using a list or deque (double-ended queue), as long as you use only standard operations of a stack.
You may assume that all operations are valid (for example, no pop or peek operations will be called on an empty queue).










## 233 - Number of Digit One
~3~  ['Math']
Given an integer n, count the total number of digit 1 appearing in all non-negative integers less than or equal to n.


For example: 
Given n = 13,
Return 6, because digit 1 occurred in the following numbers: 1, 10, 11, 12, 13.










## 234 - Palindrome Linked List
~1~  ['Linked List', 'Two Pointers']
Given a singly linked list, determine if it is a palindrome.

Follow up:
Could you do it in O(n) time and O(1) space?










## 235 - Lowest Common Ancestor of a Binary Search Tree
~1~  ['Tree']
Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.



According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).”



        _______6______
       /              \
    ___2__          ___8__
   /      \        /      \
   0      _4       7       9
         /  \
         3   5



For example, the lowest common ancestor (LCA) of nodes 2 and 8 is 6. Another example is LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.










## 236 - Lowest Common Ancestor of a Binary Tree
~2~  ['Tree']
Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.



According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).”



        _______3______
       /              \
    ___5__          ___1__
   /      \        /      \
   6      _2       0       8
         /  \
         7   4



For example, the lowest common ancestor (LCA) of nodes 5 and 1 is 3. Another example is LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.










## 237 - Delete Node in a Linked List
~1~  ['Linked List']
Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.



Supposed the linked list is 1 -> 2 -> 3 -> 4 and you are given the third node with value 3, the linked list should become 1 -> 2 -> 4 after calling your function.










## 238 - Product of Array Except Self
~2~  ['Array']
Given an array of n integers where n > 1, nums, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i].

Solve it without division and in O(n).

For example, given [1,2,3,4], return [24,12,8,6].

Follow up:
Could you solve it with constant space complexity? (Note: The output array does not count as extra space for the purpose of space complexity analysis.)










## 239 - Sliding Window Maximum
~3~  ['Heap']
Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.

For example,
Given nums = [1,3,-1,-3,5,3,6,7], and k = 3.


Window position                Max
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7


Therefore, return the max sliding window as [3,3,5,5,6,7].

Note: 
You may assume k is always valid, ie: 1 ≤ k ≤ input array's size for non-empty array.

Follow up:
Could you solve it in linear time?










## 240 - Search a 2D Matrix II
~2~  ['Binary Search', 'Divide and Conquer']
Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:



Integers in each row are sorted in ascending from left to right.
Integers in each column are sorted in ascending from top to bottom.




For example,

Consider the following matrix:


[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]


Given target = 5, return true.
Given target = 20, return false.










## 241 - Different Ways to Add Parentheses
~2~  ['Divide and Conquer']
Given a string of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. The valid operators are +, - and *.

Example 1
Input: "2-1-1". 
((2-1)-1) = 0
(2-(1-1)) = 2
Output: [0, 2]

Example 2
Input: "2*3-4*5" 
(2*(3-(4*5))) = -34
((2*3)-(4*5)) = -14
((2*(3-4))*5) = -10
(2*((3-4)*5)) = -10
(((2*3)-4)*5) = 10
Output: [-34, -14, -10, -10, 10] 

Credits:Special thanks to @mithmatt for adding this problem and creating all test cases.










## 242 - Valid Anagram
~1~  ['Hash Table', 'Sort']
Given two strings s and t, write a function to determine if t is an anagram of s. 

For example,
s = "anagram", t = "nagaram", return true.
s = "rat", t = "car", return false.


Note:
You may assume the string contains only lowercase alphabets.

Follow up:
What if the inputs contain unicode characters? How would you adapt your solution to such case?










## 243 - Shortest Word Distance
~1~  []
Given a list of words and two words _word1_ and _word2_, return the shortest
distance between these two words in the list.

For example,
Assume that words = `["practice", "makes", "perfect", "coding", "makes"]`.

Given _word1_ = `"coding"`, _word2_ = `"practice"`, return 3.
Given _word1_ = `"makes"`, _word2_ = `"coding"`, return 1.

Note:
You may assume that _word1_ does not equal to _word2_, and _word1_ and _word2_
are both in the list.










## 244 - Shortest Word Distance II
~2~  []
This is a follow up of [Shortest Word
Distance](https://leetcode.com/problems/shortest-word-distance). The only
difference is now you are given the list of words and your method will be
called _repeatedly_ many times with different parameters. How would you
optimize it?

Design a class which receives a list of words in the constructor, and
implements a method that takes two words _word1_ and _word2_ and return the
shortest distance between these two words in the list.

For example,
Assume that words = `["practice", "makes", "perfect", "coding", "makes"]`.

Given _word1_ = `"coding"`, _word2_ = `"practice"`, return 3.
Given _word1_ = `"makes"`, _word2_ = `"coding"`, return 1.

Note:
You may assume that _word1_ does not equal to _word2_, and _word1_ and _word2_
are both in the list.










## 245 - Shortest Word Distance III
~2~  []
This is a follow up of Shortest Word Distance. The only difference is now
word1 could be the same as word2.

Given a list of words and two words word1 and word2, return the shortest
distance between these two words in the list.

word1 and word2 may be the same and they represent two individual words in the
list.

For example,
Assume that words = ["practice", "makes", "perfect", "coding", "makes"].

Given word1 = "makes", word2 = "coding", return 1.
Given word1 = "makes", word2 = "makes", return 3.

Note:
You may assume word1 and word2 are both in the list.










## 246 - Strobogrammatic Number
~1~  []
A strobogrammatic number is a number that looks the same when rotated 180
degrees (looked at upside down).

Write a function to determine if a number is strobogrammatic. The number is
represented as a string.

For example, the numbers "69", "88", and "818" are all strobogrammatic.










## 247 - Strobogrammatic Number II
~2~  []
A strobogrammatic number is a number that looks the same when rotated 180
degrees (looked at upside down).

Find all strobogrammatic numbers that are of length = n.

For example,
Given n = 2, return `["11","69","88","96"]`.

Hint:

  1. Try to use recursion and notice that it should recurse with _n_ \- 2 instead of _n_ \- 1.










## 248 - Strobogrammatic Number III
~3~  []
A strobogrammatic number is a number that looks the same when rotated 180
degrees (looked at upside down).

Write a function to count the total strobogrammatic numbers that exist in the
range of low <= num <= high.

For example,
Given low = "50", high = "100", return 3. Because 69, 88, and 96 are three
strobogrammatic numbers.

Note:
Because the range might be a large number, the _low_ and _high_ numbers are
represented as string.



Show Tags

Show Similar Problems










## 249 - Group Shifted Strings
~2~  []
Given a string, we can "shift" each of its letter to its successive letter,
for example: `"abc" -> "bcd"`. We can keep "shifting" which forms the
sequence:



    "abc" -> "bcd" -> ... -> "xyz"

Given a list of strings which contains only lowercase alphabets, group all
strings that belong to the same shifting sequence.

For example, given: `["abc", "bcd", "acef", "xyz", "az", "ba", "a", "z"]`,
Return:



    [  ["abc","bcd","xyz"],  ["az","ba"],  ["acef"],  ["a","z"]]



Note: For the return value, each _inner_ list's elements must follow the
lexicographic order.










## 250 - Count Univalue Subtrees
~2~  []
Given a binary tree, count the number of uni-value subtrees.

A Uni-value subtree means all nodes of the subtree have the same value.

For example:
Given binary tree,



                  5             / \            1   5           / \   \          5   5   5



return `4`.










## 251 - Flatten 2D Vector
~2~  []
Implement an iterator to flatten a 2d vector.

For example,
Given 2d vector =



    [  [1,2],  [3],  [4,5,6]]



By calling _next_ repeatedly until _hasNext_ returns false, the order of
elements returned by _next_ should be: `[1,2,3,4,5,6]`.

Hint:

  1. How many variables do you need to keep track?
  2. Two variables is all you need. Try with `x` and `y`.
  3. Beware of empty rows. It could be the first few rows.
  4. To write correct code, think about the [invariant](https://en.wikipedia.org/wiki/Invariant_\(computer_science\)) to maintain. What is it?
  5. The invariant is `x` and `y` must always point to a valid point in the 2d vector. Should you maintain your invariant _ahead of time_ or _right when you need it_?
  6. Not sure? Think about how you would implement `hasNext()`. Which is more complex?
  7. Common logic in two different places should be refactored into a common method.

Follow up:
As an added challenge, try to code it using only [iterators in
C++](http://www.cplusplus.com/reference/iterator/iterator/) or [iterators in
Java](http://docs.oracle.com/javase/7/docs/api/java/util/Iterator.html).










## 252 - Meeting Rooms
~1~  []
Given an array of meeting time intervals consisting of start and end times
`[[s1,e1],[s2,e2],...]` (si < ei), determine if a person could attend all
meetings.

For example,
Given `[[0, 30],[5, 10],[15, 20]]`,
return `false`.










## 253 - Meeting Rooms II
~2~  []
Given an array of meeting time intervals consisting of start and end times
`[[s1,e1],[s2,e2],...]` (si < ei), find the minimum number of conference
rooms required.

For example,
Given `[[0, 30],[5, 10],[15, 20]]`,
return `2`.










## 254 - Factor Combinations
~2~  []
Numbers can be regarded as product of its factors. For example,



    8 = 2 x 2 x 2;  = 2 x 4.

Write a function that takes an integer _n_ and return all possible
combinations of its factors.

Note:

  1. Each combination's factors must be sorted ascending, for example: The factors of 2 and 6 is `[2, 6]`, not `[6, 2]`.
  2. You may assume that _n_ is always positive.
  3. Factors should be greater than 1 and less than _n_.



Examples:
input: `1`
output:



    []

input: `37`
output:



    []

input: `12`
output:



    [  [2, 6],  [2, 2, 3],  [3, 4]]

input: `32`
output:



    [  [2, 16],  [2, 2, 8],  [2, 2, 2, 4],  [2, 2, 2, 2, 2],  [2, 4, 4],  [4, 8]]










## 255 - Verify Preorder Sequence in Binary Search Tree
~2~  []
Given an array of numbers, verify whether it is the correct preorder traversal
sequence of a binary search tree.

You may assume each number in the sequence is unique.

**Follow up:**
Could you do it using only constant space complexity?










## 256 - Paint House
~1~  []
There are a row of _n_ houses, each house can be painted with one of the three
colors: red, blue or green. The cost of painting each house with a certain
color is different. You have to paint all the houses such that no two adjacent
houses have the same color.

The cost of painting each house with a certain color is represented by a `_n_
x _3_` cost matrix. For example, `costs[0][0]` is the cost of painting house 0
with color red; `costs[1][2]` is the cost of painting house 1 with color
green, and so on... Find the minimum cost to paint all houses.

Note:
All costs are positive integers.










## 257 - Binary Tree Paths
~1~  ['Tree', 'Depth-first Search']
Given a binary tree, return all root-to-leaf paths.


For example, given the following binary tree:



   1
 /   \
2     3
 \
  5



All root-to-leaf paths are:
["1->2->5", "1->3"]


Credits:Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.










## 258 - Add Digits
~1~  ['Math']
Given a non-negative integer num, repeatedly add all its digits until the result has only one digit. 



For example:


Given num = 38, the process is like: 3 + 8 = 11, 1 + 1 = 2. Since 2 has only one digit, return it.


Follow up:
Could you do it without any loop/recursion in O(1) runtime?


Credits:Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.










## 259 - 3Sum Smaller
~2~  []
Given an array of _n_ integers _nums_ and a _target_, find the number of index
triplets `i, j, k` with `0 <= i < j < k < n` that satisfy the condition
`nums[i] + nums[j] + nums[k] < target`.

For example, given _nums_ = `[-2, 0, 1, 3]`, and _target_ = 2.

Return 2. Because there are two triplets which sums are less than 2:



    [-2, 0, 1][-2, 0, 3]

Follow up:
Could you solve it in _O_(_n_2) runtime?










## 260 - Single Number III
~2~  ['Bit Manipulation']
Given an array of numbers nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once.


For example:


Given nums = [1, 2, 1, 3, 2, 5], return [3, 5].


Note:

The order of the result is not important. So in the above example, [5, 3] is also correct.
Your algorithm should run in linear runtime complexity. Could you implement it using only constant space complexity?



Credits:Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.










## 261 - Graph Valid Tree
~2~  []
Given `n` nodes labeled from `0` to `n - 1` and a list of undirected edges
(each edge is a pair of nodes), write a function to check whether these edges
make up a valid tree.

For example:

Given `n = 5` and `edges = [[0, 1], [0, 2], [0, 3], [1, 4]]`, return `true`.

Given `n = 5` and `edges = [[0, 1], [1, 2], [2, 3], [1, 3], [1, 4]]`, return
`false`.

Hint:

  1. Given `n = 5` and `edges = [[0, 1], [1, 2], [3, 4]]`, what should your return? Is this case a valid tree?
  2. According to the [definition of tree on Wikipedia](https://en.wikipedia.org/wiki/Tree_\(graph_theory\)): "a tree is an undirected graph in which any two vertices are connected by _exactly_ one path. In other words, any connected graph without simple cycles is a tree."

Note: you can assume that no duplicate edges will appear in `edges`. Since all
edges are undirected, `[0, 1]` is the same as `[1, 0]` and thus will not
appear together in `edges`.










## 262 - Trips and Users
~3~  []
The Trips table holds all taxi trips. Each trip has a unique Id, while Client_Id and Driver_Id are both foreign keys to the Users_Id at the Users table. Status is an ENUM type of (‘completed’, ‘cancelled_by_driver’, ‘cancelled_by_client’).


+----+-----------+-----------+---------+--------------------+----------+
| Id | Client_Id | Driver_Id | City_Id |        Status      |Request_at|
+----+-----------+-----------+---------+--------------------+----------+
| 1  |     1     |    10     |    1    |     completed      |2013-10-01|
| 2  |     2     |    11     |    1    | cancelled_by_driver|2013-10-01|
| 3  |     3     |    12     |    6    |     completed      |2013-10-01|
| 4  |     4     |    13     |    6    | cancelled_by_client|2013-10-01|
| 5  |     1     |    10     |    1    |     completed      |2013-10-02|
| 6  |     2     |    11     |    6    |     completed      |2013-10-02|
| 7  |     3     |    12     |    6    |     completed      |2013-10-02|
| 8  |     2     |    12     |    12   |     completed      |2013-10-03|
| 9  |     3     |    10     |    12   |     completed      |2013-10-03| 
| 10 |     4     |    13     |    12   | cancelled_by_driver|2013-10-03|
+----+-----------+-----------+---------+--------------------+----------+



The Users table holds all users. Each user has an unique Users_Id, and Role is an ENUM type of (‘client’, ‘driver’, ‘partner’).

+----------+--------+--------+
| Users_Id | Banned |  Role  |
+----------+--------+--------+
|    1     |   No   | client |
|    2     |   Yes  | client |
|    3     |   No   | client |
|    4     |   No   | client |
|    10    |   No   | driver |
|    11    |   No   | driver |
|    12    |   No   | driver |
|    13    |   No   | driver |
+----------+--------+--------+


Write a SQL query to find the cancellation rate of requests made by unbanned clients between Oct 1, 2013 and Oct 3, 2013. For the above tables, your SQL query should return the following rows with the cancellation rate being rounded to two decimal places.

+------------+-------------------+
|     Day    | Cancellation Rate |
+------------+-------------------+
| 2013-10-01 |       0.33        |
| 2013-10-02 |       0.00        |
| 2013-10-03 |       0.50        |
+------------+-------------------+


Credits:Special thanks to @cak1erlizhou for contributing this question, writing the problem description and adding part of the test cases.










## 263 - Ugly Number
~1~  ['Math']
Write a program to check whether a given number is an ugly number.



Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 6, 8 are ugly while 14 is not ugly since it includes another prime factor 7.



Note that 1 is typically treated as an ugly number.


Credits:Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.










## 264 - Ugly Number II
~2~  ['Math', 'Dynamic Programming', 'Heap']
Write a program to find the n-th ugly number.



Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 10 ugly numbers.



Note that 1 is typically treated as an ugly number, and n does not exceed 1690.


Credits:Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.










## 265 - Paint House II
~3~  []
There are a row of _n_ houses, each house can be painted with one of the _k_
colors. The cost of painting each house with a certain color is different. You
have to paint all the houses such that no two adjacent houses have the same
color.

The cost of painting each house with a certain color is represented by a `_n_
x _k_` cost matrix. For example, `costs[0][0]` is the cost of painting house 0
with color 0; `costs[1][2]`is the cost of painting house 1 with color 2, and
so on... Find the minimum cost to paint all houses.

Note:
All costs are positive integers.

Follow up:
Could you solve it in _O_(_nk_) runtime?










## 266 - Palindrome Permutation
~1~  []
Given a string, determine if a permutation of the string could form a
palindrome.

For example,
`"code"` -> False, `"aab"` -> True, `"carerac"` -> True.

Hint:

  1. Consider the palindromes of odd vs even length. What difference do you notice?
  2. Count the frequency of each character.
  3. If each character occurs even number of times, then it must be a palindrome. How about character which occurs odd number of times?










## 267 - Palindrome Permutation II
~2~  []
Given a string `s`, return all the palindromic permutations (without
duplicates) of it. Return an empty list if no palindromic permutation could be
form.

For example:

Given `s = "aabb"`, return `["abba", "baab"]`.

Given `s = "abc"`, return `[]`.

Hint:

  1. If a palindromic permutation exists, we just need to generate the first half of the string.
  2. To generate all distinct permutations of a (half of) string, use a similar approach from: [Permutations II](https://leetcode.com/problems/permutations-ii) or [Next Permutation](https://leetcode.com/problems/next-permutation).










## 268 - Missing Number
~1~  ['Array', 'Math', 'Bit Manipulation']
Given an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one that is missing from the array.


For example,
Given nums = [0, 1, 3] return 2.



Note:
Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity?


Credits:Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.










## 269 - Alien Dictionary
~3~  []
There is a new alien language which uses the latin alphabet. However, the
order among letters are unknown to you. You receive a list of words from the
dictionary, where words are sorted lexicographically by the rules of this new
language. Derive the order of letters in this language.

For example,
Given the following words in dictionary,



    [  "wrt",  "wrf",  "er",  "ett",  "rftt"]



The correct order is: `"wertf"`.

Note:

  1. You may assume all letters are in lowercase.
  2. If the order is invalid, return an empty string.
  3. There may be multiple valid order of letters, return any one of them is fine.










## 270 - Closest Binary Search Tree Value
~1~  []
Given a non-empty binary search tree and a target value, find the value in the
BST that is closest to the target.

Note:

  * Given target value is a floating point.
  * You are guaranteed to have only one unique value in the BST that is closest to the target.










## 271 - Encode and Decode Strings
~2~  []
Design an algorithm to encode a list of strings to a string. The encoded
string is then sent over the network and is decoded back to the original list
of strings.

Machine 1 (sender) has the function:



    string encode(vector<string> strs) {  // ... your code  return encoded_string;}

Machine 2 (receiver) has the function:



    vector<string> decode(string s) {  //... your code  return strs;}



So Machine 1 does:



    string encoded_string = encode(strs);



and Machine 2 does:



    vector<string> strs2 = decode(encoded_string);



`strs2` in Machine 2 should be the same as `strs` in Machine 1.

Implement the `encode` and `decode` methods.

Note:

  * The string may contain any possible characters out of 256 valid ascii characters. Your algorithm should be generalized enough to work on any possible characters.
  * Do not use class member/global/static variables to store states. Your encode and decode algorithms should be stateless.
  * Do not rely on any library method such as `eval` or serialize methods. You should implement your own encode/decode algorithm.










## 272 - Closest Binary Search Tree Value II
~3~  []
Given a non-empty binary search tree and a target value, find _k_ values in
the BST that are closest to the target.

Note:

  * Given target value is a floating point.
  * You may assume _k_ is always valid, that is: _k_ ≤ total nodes.
  * You are guaranteed to have only one unique set of _k_ values in the BST that are closest to the target.



Follow up:
Assume that the BST is balanced, could you solve it in less than _O_(_n_)
runtime (where _n_ = total nodes)?

Hint:

1\. Consider implement these two helper functions:
i. getPredecessor(N), which returns the next smaller node to N.
ii. getSuccessor(N), which returns the next larger node to N.
2\. Try to assume that each node has a parent pointer, it makes the problem
much easier.
3\. Without parent pointer we just need to keep track of the path from the
root to the current node using a stack.
4\. You would need two stacks to track the path in finding predecessor and
successor node separately.










## 273 - Integer to English Words
~3~  ['Math', 'String']
Convert a non-negative integer to its english words representation. Given input is guaranteed to be less than 231 - 1.


For example,

123 -> "One Hundred Twenty Three"
12345 -> "Twelve Thousand Three Hundred Forty Five"
1234567 -> "One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven"










## 274 - H-Index
~2~  ['Hash Table', 'Sort']
Given an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the researcher's h-index.



According to the definition of h-index on Wikipedia: "A scientist has index h if h of his/her N papers have at least h citations each, and the other N − h papers have no more than h citations each."



For example, given citations = [3, 0, 6, 1, 5], which means the researcher has 5 papers in total and each of them had received 3, 0, 6, 1, 5 citations respectively. Since the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, his h-index is 3.



Note: If there are several possible values for h, the maximum one is taken as the h-index.


Credits:Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.










## 275 - H-Index II
~2~  ['Binary Search']
Follow up for H-Index: What if the citations array is sorted in ascending order? Could you optimize your algorithm?










## 276 - Paint Fence
~1~  []
There is a fence with n posts, each post can be painted with one of the k
colors.

You have to paint all the posts such that no more than two adjacent fence
posts have the same color.

Return the total number of ways you can paint the fence.

Note:
n and k are non-negative integers.










## 277 - Find the Celebrity
~2~  []
Suppose you are at a party with `n` people (labeled from `0` to `n - 1`) and
among them, there may exist one celebrity. The definition of a celebrity is
that all the other `n - 1`people know him/her but he/she does not know any of
them.

Now you want to find out who the celebrity is or verify that there is not one.
The only thing you are allowed to do is to ask questions like: "Hi, A. Do you
know B?" to get information of whether A knows B. You need to find out the
celebrity (or verify there is not one) by asking as few questions as possible
(in the asymptotic sense).

You are given a helper function `bool knows(a, b)` which tells you whether A
knows B. Implement a function `int findCelebrity(n)`, your function should
minimize the number of calls to `knows`.

Note: There will be exactly one celebrity if he/she is in the party. Return
the celebrity's label if there is a celebrity in the party. If there is no
celebrity, return `-1`.










## 278 - First Bad Version
~1~  ['Binary Search']
You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad. 



Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.



You are given an API bool isBadVersion(version) which will return whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.


Credits:Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.










## 279 - Perfect Squares
~2~  ['Math', 'Dynamic Programming', 'Breadth-first Search']
Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, ...) which sum to n.



For example, given n = 12, return 3 because 12 = 4 + 4 + 4; given n = 13, return 2 because 13 = 4 + 9.


Credits:Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.










## 280 - Wiggle Sort
~2~  []
Given an unsorted array nums, reorder it in-place such that nums[0] <=
nums[1] >= nums[2] <= nums[3]....

For example, given nums = [3, 5, 2, 1, 6, 4], one possible answer is [1, 6, 2,
5, 3, 4].










## 281 - Zigzag Iterator
~2~  []
Given two 1d vectors, implement an iterator to return their elements
alternately.

For example, given two 1d vectors:



    v1 = [1, 2]v2 = [3, 4, 5, 6]

By calling _next_ repeatedly until _hasNext_ returns `false`, the order of
elements returned by _next_ should be: `[1, 3, 2, 4, 5, 6]`.

**Follow up**: What if you are given `k` 1d vectors? How well can your code be extended to such cases?

**Clarification for the follow up question - Update (2015-09-18):**
The "Zigzag" order is not clearly defined and is ambiguous for `k > 2` cases.
If "Zigzag" does not look right to you, replace "Zigzag" with "Cyclic". For
example, given the following input:



    [1,2,3][4,5,6,7][8,9]

It should return `[1,4,8,2,5,9,3,6,7]`.










## 282 - Expression Add Operators
~3~  ['Divide and Conquer']
Given a string that contains only digits 0-9 and a target value, return all possibilities to add binary operators (not unary) +, -, or * between the digits so they evaluate to the target value.


Examples: 
"123", 6 -> ["1+2+3", "1*2*3"] 
"232", 8 -> ["2*3+2", "2+3*2"]
"105", 5 -> ["1*0+5","10-5"]
"00", 0 -> ["0+0", "0-0", "0*0"]
"3456237490", 9191 -> []


Credits:Special thanks to @davidtan1890 for adding this problem and creating all test cases.










## 283 - Move Zeroes
~1~  ['Array', 'Two Pointers']
Given an array nums, write a function to move all 0's to the end of it while maintaining the relative order of the non-zero elements.



For example, given nums  = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0].



Note:

You must do this in-place without making a copy of the array.
Minimize the total number of operations.



Credits:Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.










## 284 - Peeking Iterator
~2~  ['Design']
Given an Iterator class interface with methods: next() and hasNext(), design and implement a PeekingIterator that support the peek() operation -- it essentially peek() at the element that will be returned by the next call to next().


Here is an example. Assume that the iterator is initialized to the beginning of the list: [1, 2, 3].

Call next() gets you 1, the first element in the list.

Now you call peek() and it returns 2, the next element. Calling next() after that still return 2.

You call next() the final time and it returns 3, the last element. Calling hasNext() after that should return false.


Follow up: How would you extend your design to be generic and work with all types, not just integer?

Credits:Special thanks to @porker2008 for adding this problem and creating all test cases.










## 285 - Inorder Successor in BST
~2~  []
Given a binary search tree and a node in it, find the in-order successor of
that node in the BST.

Note: If the given node has no in-order successor in the tree, return `null`.










## 286 - Walls and Gates
~2~  []
You are given a _m x n_ 2D grid initialized with these three possible values.

  1. `-1` \- A wall or an obstacle.
  2. `0` \- A gate.
  3. `INF` \- Infinity means an empty room. We use the value `231 - 1 = 2147483647` to represent `INF` as you may assume that the distance to a gate is less than `2147483647`.

Fill each empty room with the distance to its _nearest_ gate. If it is
impossible to reach a gate, it should be filled with `INF`.

For example, given the 2D grid:


    INF  -1  0  INFINF INF INF  -1INF  -1 INF  -1  0  -1 INF INF

After running your function, the 2D grid should be:


      3  -1   0   1  2   2   1  -1  1  -1   2  -1  0  -1   3   4










## 287 - Find the Duplicate Number
~2~  ['Array', 'Two Pointers', 'Binary Search']
Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.



Note:

You must not modify the array (assume the array is read only).
You must use only constant, O(1) extra space.
Your runtime complexity should be less than O(n2).
There is only one duplicate number in the array, but it could be repeated more than once.



Credits:Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.










## 288 - Unique Word Abbreviation
~2~  []
An abbreviation of a word follows the form <first
letter><number><last letter>. Below are some examples of word
abbreviations:



    a) it                      --> it    (no abbreviation)     1b) d|o|g                   --> d1g              1    1  1     1---5----0----5--8c) i|nternationalizatio|n  --> i18n              1     1---5----0d) l|ocalizatio|n          --> l10n

Assume you have a dictionary and given a word, find whether its abbreviation
is unique in the dictionary. A word's abbreviation is unique if no _other_
word from the dictionary has the same abbreviation.

Example:



    Given dictionary = [ "deer", "door", "cake", "card" ]isUnique("dear") -> falseisUnique("cart") -> trueisUnique("cane") -> falseisUnique("make") -> true










## 289 - Game of Life
~2~  ['Array']
According to the Wikipedia's article: "The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970."



Given a board with m by n cells, each cell has an initial state live (1) or dead (0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):




Any live cell with fewer than two live neighbors dies, as if caused by under-population.
Any live cell with two or three live neighbors lives on to the next generation.
Any live cell with more than three live neighbors dies, as if by over-population..
Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.




Write a function to compute the next state (after one update) of the board given its current state.


Follow up: 

Could you solve it in-place? Remember that the board needs to be updated at the same time: You cannot update some cells first and then use their updated values to update other cells.
In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems?



Credits:Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.










## 290 - Word Pattern
~1~  ['Hash Table']
Given a pattern and a string str, find if str follows the same pattern.
 Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in str.

Examples:

pattern = "abba", str = "dog cat cat dog" should return true.
pattern = "abba", str = "dog cat cat fish" should return false.
pattern = "aaaa", str = "dog cat cat dog" should return false.
pattern = "abba", str = "dog dog dog dog" should return false.




Notes:
You may assume pattern contains only lowercase letters, and str contains lowercase letters separated by a single space.


Credits:Special thanks to @minglotus6 for adding this problem and creating all test cases.










## 291 - Word Pattern II
~3~  []
Given a `pattern` and a string `str`, find if `str` follows the same pattern.

Here follow means a full match, such that there is a bijection between a
letter in `pattern` and a non-empty substring in `str`.

Examples:

  1. pattern = `"abab"`, str = `"redblueredblue"` should return true.
  2. pattern = `"aaaa"`, str = `"asdasdasdasd"` should return true.
  3. pattern = `"aabb"`, str = `"xyzabcxzyabc"` should return false.



Notes:
You may assume both `pattern` and `str` contains only lowercase letters.










## 292 - Nim Game
~1~  ['Brainteaser']
You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones.



Both of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap.



For example, if there are 4 stones in the heap, then you will never win the game: no matter 1, 2, or 3 stones you remove, the last stone will always be removed by your friend.


Credits:Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.










## 293 - Flip Game
~1~  []
You are playing the following Flip Game with your friend: Given a string that
contains only these two characters: `+` and `-`, you and your friend take
turns to flip twoconsecutive `"++"` into `"--"`. The game ends when a person
can no longer make a move and therefore the other person will be the winner.

Write a function to compute all possible states of the string after one valid
move.

For example, given `s = "++++"`, after one move, it may become one of the
following states:



    [  "--++",  "+--+",  "++--"]



If there is no valid move, return an empty list `[]`.










## 294 - Flip Game II
~2~  []
You are playing the following Flip Game with your friend: Given a string that
contains only these two characters: `+` and `-`, you and your friend take
turns to flip twoconsecutive `"++"` into `"--"`. The game ends when a person
can no longer make a move and therefore the other person will be the winner.

Write a function to determine if the starting player can guarantee a win.

For example, given `s = "++++"`, return true. The starting player can
guarantee a win by flipping the middle `"++"` to become `"+--+"`.

Follow up:
Derive your algorithm's runtime complexity.










## 295 - Find Median from Data Stream
~3~  ['Heap', 'Design']
Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value.
Examples: 
[2,3,4] , the median is 3
[2,3], the median is (2 + 3) / 2 = 2.5 


Design a data structure that supports the following two operations:


void addNum(int num) - Add a integer number from the data stream to the data structure.
double findMedian() - Return the median of all elements so far.



For example:

addNum(1)
addNum(2)
findMedian() -> 1.5
addNum(3) 
findMedian() -> 2


Credits:Special thanks to @Louis1992 for adding this problem and creating all test cases.










## 296 - Best Meeting Point
~3~  []
A group of two or more people wants to meet and minimize the total travel
distance. You are given a 2D grid of values 0 or 1, where each 1 marks the
home of someone in the group. The distance is calculated using [Manhattan
Distance](http://en.wikipedia.org/wiki/Taxicab_geometry), where distance(p1,
p2) = `|p2.x - p1.x| + |p2.y - p1.y|`.

For example, given three people living at `(0,0)`, `(0,4)`, and `(2,2)`:



    1 - 0 - 0 - 0 - 1|   |   |   |   |0 - 0 - 0 - 0 - 0|   |   |   |   |0 - 0 - 1 - 0 - 0

The point `(0,2)` is an ideal meeting point, as the total travel distance of
2+2+2=6 is minimal. So return 6.

**Hint:**

  1. Try to solve it in one dimension first. How can this solution apply to the two dimension case?










## 297 - Serialize and Deserialize Binary Tree
~3~  ['Tree', 'Design']
Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment. 

Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.


For example, you may serialize the following tree

    1
   / \
  2   3
     / \
    4   5

as "[1,2,3,null,null,4,5]", just the same as how LeetCode OJ serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.



Note: Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.


Credits:Special thanks to @Louis1992 for adding this problem and creating all test cases.










## 298 - Binary Tree Longest Consecutive Sequence
~2~  []
Given a binary tree, find the length of the longest consecutive sequence path.



The path refers to any sequence of nodes from some starting node to any node
in the tree along the parent-child connections. The longest consecutive path
need to be from parent to child (cannot be the reverse).

For example,



       1    \     3    / \   2   4        \         5

Longest consecutive sequence path is `3-4-5`, so return `3`.



       2    \     3    /    2      /  1

Longest consecutive sequence path is `2-3`,not`3-2-1`, so return `2`.










## 299 - Bulls and Cows
~2~  ['Hash Table']
You are playing the following Bulls and Cows game with your friend: You write down a number and ask your friend to guess what the number is. Each time your friend makes a guess, you provide a hint that indicates how many digits in said guess match your secret number exactly in both digit and position (called "bulls") and how many digits match the secret number but locate in the wrong position (called "cows"). Your friend will use successive guesses and hints to eventually derive the secret number.


For example:

Secret number:  "1807"
Friend's guess: "7810"

Hint: 1 bull and 3 cows. (The bull is 8, the cows are 0, 1 and 7.)


Write a function to return a hint according to the secret number and friend's guess, use A to indicate the bulls and B to indicate the cows. In the above example, your function should return "1A3B". 

Please note that both secret number and friend's guess may contain duplicate digits, for example:

Secret number:  "1123"
Friend's guess: "0111"

In this case, the 1st 1 in friend's guess is a bull, the 2nd or 3rd 1 is a cow, and your function should return "1A1B".


You may assume that the secret number and your friend's guess only contain digits, and their lengths are always equal.

Credits:Special thanks to @jeantimex for adding this problem and creating all test cases.










## 300 - Longest Increasing Subsequence
~2~  ['Binary Search', 'Dynamic Programming']
Given an unsorted array of integers, find the length of longest increasing subsequence.


For example,
Given [10, 9, 2, 5, 3, 7, 101, 18],
The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4. Note that there may be more than one LIS combination, it is only necessary for you to return the length.


Your algorithm should run in O(n2) complexity.


Follow up: Could you improve it to O(n log n) time complexity? 

Credits:Special thanks to @pbrother for adding this problem and creating all test cases.










## 301 - Remove Invalid Parentheses
~3~  ['Depth-first Search', 'Breadth-first Search']
Remove the minimum number of invalid parentheses in order to make the input string valid. Return all possible results.

Note: The input string may contain letters other than the parentheses ( and ). 



Examples:

"()())()" -> ["()()()", "(())()"]
"(a)())()" -> ["(a)()()", "(a())()"]
")(" -> [""]



Credits:Special thanks to @hpplayer for adding this problem and creating all test cases.










## 302 - Smallest Rectangle Enclosing Black Pixels
~3~  []
An image is represented by a binary matrix with `0` as a white pixel and `1`
as a black pixel. The black pixels are connected, i.e., there is only one
black region. Pixels are connected horizontally and vertically. Given the
location `(x, y)` of one of the black pixels, return the area of the smallest
(axis-aligned) rectangle that encloses all black pixels.

For example, given the following image:



    [  "0010",  "0110",  "0100"]

and `x = 0`, `y = 2`,



Return `6`.










## 303 - Range Sum Query - Immutable
~1~  ['Dynamic Programming']
Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive.

Example:

Given nums = [-2, 0, 3, -5, 2, -1]

sumRange(0, 2) -> 1
sumRange(2, 5) -> -1
sumRange(0, 5) -> -3



Note:

You may assume that the array does not change.
There are many calls to sumRange function.










## 304 - Range Sum Query 2D - Immutable
~2~  ['Dynamic Programming']
Given a 2D matrix matrix, find the sum of the elements inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).



The above rectangle (with the red border) is defined by (row1, col1) = (2, 1) and (row2, col2) = (4, 3), which contains sum = 8.


Example:

Given matrix = [
  [3, 0, 1, 4, 2],
  [5, 6, 3, 2, 1],
  [1, 2, 0, 1, 5],
  [4, 1, 0, 1, 7],
  [1, 0, 3, 0, 5]
]

sumRegion(2, 1, 4, 3) -> 8
sumRegion(1, 1, 2, 2) -> 11
sumRegion(1, 2, 2, 4) -> 12



Note:

You may assume that the matrix does not change.
There are many calls to sumRegion function.
You may assume that row1 ≤ row2 and col1 ≤ col2.










## 305 - Number of Islands II
~3~  []
A 2d grid map of `m` rows and `n` columns is initially filled with water. We
may perform an _addLand_ operation which turns the water at position (row,
col) into a land. Given a list of positions to operate, count the number of
islands after each _addLand_ operation. An island is surrounded by water and
is formed by connecting adjacent lands horizontally or vertically. You may
assume all four edges of the grid are all surrounded by water.

Example:

Given `m = 3, n = 3`, `positions = [[0,0], [0,1], [1,2], [2,1]]`.
Initially, the 2d grid `grid` is filled with water. (Assume 0 represents water
and 1 represents land).



    0 0 00 0 00 0 0

Operation #1: addLand(0, 0) turns the water at grid[0][0] into a land.



    1 0 00 0 0   Number of islands = 10 0 0

Operation #2: addLand(0, 1) turns the water at grid[0][1] into a land.



    1 1 00 0 0   Number of islands = 10 0 0

Operation #3: addLand(1, 2) turns the water at grid[1][2] into a land.



    1 1 00 0 1   Number of islands = 20 0 0

Operation #4: addLand(2, 1) turns the water at grid[2][1] into a land.



    1 1 00 0 1   Number of islands = 30 1 0

We return the result as an array: `[1, 1, 2, 3]`

Challenge:

Can you do it in time complexity O(k log mn), where k is the length of the
`positions`?










## 306 - Additive Number
~2~  []
Additive number is a string whose digits can form additive sequence.

A valid additive sequence should contain at least three numbers. Except for the first two numbers, each subsequent number in the sequence must be the sum of the preceding two.


For example:
"112358" is an additive number because the digits can form an additive sequence: 1, 1, 2, 3, 5, 8.
1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8
"199100199" is also an additive number, the additive sequence is: 1, 99, 100, 199.
1 + 99 = 100, 99 + 100 = 199



Note: Numbers in the additive sequence cannot have leading zeros, so sequence 1, 2, 03 or 1, 02, 3 is invalid.


Given a string containing only digits '0'-'9', write a function to determine if it's an additive number.


Follow up:
How would you handle overflow for very large input integers?


Credits:Special thanks to @jeantimex for adding this problem and creating all test cases.










## 307 - Range Sum Query - Mutable
~2~  ['Binary Indexed Tree', 'Segment Tree']
Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive.

The update(i, val) function modifies nums by updating the element at index i to val.

Example:

Given nums = [1, 3, 5]

sumRange(0, 2) -> 9
update(1, 2)
sumRange(0, 2) -> 8



Note:

The array is only modifiable by the update function.
You may assume the number of calls to update and sumRange function is distributed evenly.










## 308 - Range Sum Query 2D - Mutable
~3~  []
Given a 2D matrix _matrix_, find the sum of the elements inside the rectangle
defined by its upper left corner (_row_1, _col_1) and lower right corner
(_row_2, _col_2).

![Range Sum Query
2D](https://leetcode.com/static/images/courses/range_sum_query_2d.png)
The above rectangle (with the red border) is defined by (row1, col1) = **(2,
1)** and (row2, col2) = **(4, 3)**, which contains sum = **8**.

**Example:**


    Given matrix = [  [3, 0, 1, 4, 2],  [5, 6, 3, 2, 1],  [1, 2, 0, 1, 5],  [4, 1, 0, 1, 7],  [1, 0, 3, 0, 5]]sumRegion(2, 1, 4, 3) -> 8update(3, 2, 2)sumRegion(2, 1, 4, 3) -> 10

**Note:**
  1. The matrix is only modifiable by the _update_ function.
  2. You may assume the number of calls to _update_ and _sumRegion_ function is distributed evenly.
  3. You may assume that _row_1 ≤ _row_2 and _col_1 ≤ _col_2.










## 309 - Best Time to Buy and Sell Stock with Cooldown
~2~  ['Dynamic Programming']
Say you have an array for which the ith element is the price of a given stock on day i.

Design an algorithm to find the maximum profit. You may complete as many transactions as you like
(ie, buy one and sell one share of the stock multiple times) with the following restrictions:


    You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).
    After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day)


Example:

prices = [1, 2, 3, 0, 2]
maxProfit = 3
transactions = [buy, sell, cooldown, buy, sell]


Credits:Special thanks to @dietpepsi for adding this problem and creating all test cases.










## 310 - Minimum Height Trees
~2~  ['Breadth-first Search', 'Graph']
For a undirected graph with tree characteristics, we can choose any node as the root. The result graph is then a rooted tree. Among all possible rooted trees, those with minimum height are called minimum height trees (MHTs).
    Given such a graph, write a function to find all the MHTs and return a list of their root labels.



    Format
    The graph contains n nodes which are labeled from 0 to n - 1.
    You will be given the number n and a list of undirected edges (each edge is a pair of labels).

 
You can assume that no duplicate edges will appear in edges. Since all edges are
    undirected, [0, 1] is the same as [1, 0] and thus will not appear together in
    edges.


    Example 1:


    Given n = 4, edges = [[1, 0], [1, 2], [1, 3]]



        0
        |
        1
       / \
      2   3


    return  [1]



    Example 2:


    Given n = 6, edges = [[0, 3], [1, 3], [2, 3], [4, 3], [5, 4]]


     0  1  2
      \ | /
        3
        |
        4
        |
        5


    return  [3, 4]



    Note:


    (1) According to the definition
    of tree on Wikipedia: “a tree is an undirected graph in which any two vertices are connected by
    exactly one path. In other words, any connected graph without simple cycles is a tree.”


    (2) The height of a rooted tree is the number of edges on the longest downward path between the root and a
    leaf.


Credits:Special thanks to @dietpepsi for adding this problem and creating all test cases.










## 311 - Sparse Matrix Multiplication
~2~  []
Given two [sparse matrices](https://en.wikipedia.org/wiki/Sparse_matrix) **A**
and **B**, return the result of **AB**.

You may assume that **A**'s column number is equal to **B**'s row number.

**Example:**


    **A** = [  [ 1, 0, 0],  [-1, 0, 3]]**B** = [  [ 7, 0, 0 ],  [ 0, 0, 0 ],  [ 0, 0, 1 ]]     |  1 0 0 |   | 7 0 0 |   |  7 0 0 |**AB** = | -1 0 3 | x | 0 0 0 | = | -7 0 3 |                  | 0 0 1 |










## 312 - Burst Balloons
~3~  ['Divide and Conquer', 'Dynamic Programming']
Given n balloons, indexed from 0 to n-1. Each balloon is painted with a
    number on it represented by array nums.

    You are asked to burst all the balloons. If the you burst
    balloon i you will get nums[left] * nums[i] * nums[right] coins. Here left
    and right are adjacent indices of i. After the burst, the left and right
    then becomes adjacent.


    Find the maximum coins you can collect by bursting the balloons wisely.


    Note: 
    (1) You may imagine nums[-1] = nums[n] = 1. They are not real therefore you can not burst them.
    (2) 0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100




    Example:


    Given [3, 1, 5, 8]


    Return 167


    nums = [3,1,5,8] --> [3,5,8] -->   [3,8]   -->  [8]  --> []
   coins =  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   = 167


Credits:Special thanks to @dietpepsi for adding this problem and creating all test cases.










## 313 - Super Ugly Number
~2~  ['Math', 'Heap']
Write a program to find the nth super ugly number.



    Super ugly numbers are positive numbers whose all prime factors are in the given prime list
    primes of size k. For example, [1, 2, 4, 7, 8, 13, 14, 16, 19, 26, 28, 32]
 is the sequence of the first 12 super ugly numbers given primes
    = [2, 7, 13, 19] of size 4.



    Note:
    (1) 1 is a super ugly number for any given primes.
    (2) The given numbers in primes are in ascending order.
    (3) 0 < k ≤ 100, 0 < n ≤ 106, 0 < primes[i] < 1000.
    (4) The nth super ugly number is guaranteed to fit in a 32-bit signed integer.


Credits:Special thanks to @dietpepsi for adding this problem and creating all test cases.










## 314 - Binary Tree Vertical Order Traversal
~2~  []
Given a binary tree, return the _vertical order_ traversal of its nodes'
values. (ie, from top to bottom, column by column).

If two nodes are in the same row and column, the order should be from **left
to right**.

**Examples:**
Given binary tree `[3,9,20,null,null,15,7]`,


        3   / \  9  20    /  \   15   7

return its vertical order traversal as:


    [  [9],  [3,15],  [20],  [7]]

Given binary tree `[3,9,20,4,5,2,7]`,


        _3_   /   \  9    20 / \   / \4   5 2   7

return its vertical order traversal as:


    [  [4],  [9],  [3,5,2],  [20],  [7]]










## 315 - Count of Smaller Numbers After Self
~3~  ['Divide and Conquer', 'Binary Indexed Tree', 'Segment Tree', 'Binary Search Tree']
You are given an integer array nums and you have to return a new counts array.
The counts array has the property where counts[i] is 
the number of smaller elements to the right of nums[i].


Example:


Given nums = [5, 2, 6, 1]

To the right of 5 there are 2 smaller elements (2 and 1).
To the right of 2 there is only 1 smaller element (1).
To the right of 6 there is 1 smaller element (1).
To the right of 1 there is 0 smaller element.



Return the array [2, 1, 1, 0].










## 316 - Remove Duplicate Letters
~3~  ['Stack', 'Greedy']
Given a string which contains only lowercase letters, remove duplicate letters so that every letter appear once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.



Example:


Given "bcabc"
Return "abc"


Given "cbacdcbc"
Return "acdb"


Credits:Special thanks to @dietpepsi for adding this problem and creating all test cases.










## 317 - Shortest Distance from All Buildings
~3~  []
You want to build a house on an _empty_ land which reaches all buildings in
the shortest amount of distance. You can only move up, down, left and right.
You are given a 2D grid of values 0, 1 or 2, where:

  * Each 0 marks an empty land which you can pass by freely.
  * Each 1 marks a building which you cannot pass through.
  * Each 2 marks an obstacle which you cannot pass through.

For example, given three buildings at `(0,0)`, `(0,4)`, `(2,2)`, and an
obstacle at `(0,2)`:



    1 - 0 - 2 - 0 - 1|   |   |   |   |0 - 0 - 0 - 0 - 0|   |   |   |   |0 - 0 - 1 - 0 - 0

The point `(1,2)` is an ideal empty land to build a house, as the total travel
distance of 3+3+1=7 is minimal. So return 7.

Note:
There will be at least one building. If it is not possible to build such house
according to the above rules, return -1.










## 318 - Maximum Product of Word Lengths
~2~  ['Bit Manipulation']
Given a string array words, find the maximum value of length(word[i]) * length(word[j]) where the two words do not share common letters.
    You may assume that each word will contain only lower case letters.
    If no such two words exist, return 0.



    Example 1:


    Given ["abcw", "baz", "foo", "bar", "xtfn", "abcdef"]
    Return 16
    The two words can be "abcw", "xtfn".


    Example 2:


    Given ["a", "ab", "abc", "d", "cd", "bcd", "abcd"]
    Return 4
    The two words can be "ab", "cd".


    Example 3:


    Given ["a", "aa", "aaa", "aaaa"]
    Return 0
    No such pair of words.    


Credits:Special thanks to @dietpepsi for adding this problem and creating all test cases.










## 319 - Bulb Switcher
~2~  ['Math', 'Brainteaser']
There are n bulbs that are initially off. You first turn on all the bulbs. Then, you turn off every second bulb. On the third round, you toggle every third bulb (turning on if it's off or turning off if it's on). For the ith round, you toggle every i bulb. For the nth round, you only toggle the last bulb.

Find how many bulbs are on after n rounds.



Example:

Given n = 3. 
At first, the three bulbs are [off, off, off].
After first round, the three bulbs are [on, on, on].
After second round, the three bulbs are [on, off, on].
After third round, the three bulbs are [on, off, off]. 
So you should return 1, because there is only one bulb is on.










## 320 - Generalized Abbreviation
~2~  []
Write a function to generate the generalized abbreviations of a word.

Example:

Given word = `"word"`, return the following list (order does not matter):



    ["word", "1ord", "w1rd", "wo1d", "wor1", "2rd", "w2d", "wo2", "1o1d", "1or1", "w1r1", "1o2", "2r1", "3d", "w3", "4"]










## 321 - Create Maximum Number
~3~  ['Dynamic Programming', 'Greedy']
Given two arrays of length m and n with digits 0-9 representing two numbers.
    Create the maximum number of length k <= m + n from digits of the two. The relative order of the digits
    from the same array must be preserved. Return an array of the k digits. You should try to optimize your time and space complexity.



    Example 1:


    nums1 = [3, 4, 6, 5]
    nums2 = [9, 1, 2, 5, 8, 3]
    k = 5
    return [9, 8, 6, 5, 3]


    Example 2:


    nums1 = [6, 7]
    nums2 = [6, 0, 4]
    k = 5
    return [6, 7, 6, 0, 4]


    Example 3:


    nums1 = [3, 9]
    nums2 = [8, 9]
    k = 3
    return [9, 8, 9]


Credits:Special thanks to @dietpepsi for adding this problem and creating all test cases.










## 322 - Coin Change
~2~  ['Dynamic Programming']
You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.



Example 1:
coins = [1, 2, 5], amount = 11
return 3 (11 = 5 + 5 + 1)



Example 2:
coins = [2], amount = 3
return -1.



Note:
You may assume that you have an infinite number of each kind of coin.


Credits:Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.










## 323 - Number of Connected Components in an Undirected Graph
~2~  []
Given n nodes labeled from 0 to n - 1 and a list of undirected edges (each
edge is a pair of nodes), write a function to find the number of connected
components in an undirected graph.

Example 1:

     0          3

     |          |

     1 --- 2    4

Given n = 5 and edges = [[0, 1], [1, 2], [3, 4]], return 2.

Example 2:

     0           4

     |           |

     1 --- 2 --- 3

Given n = 5 and edges = [[0, 1], [1, 2], [2, 3], [3, 4]], return 1.

 Note:

You can assume that no duplicate edges will appear in edges. Since all edges
are undirected, [0, 1] is the same as [1, 0] and thus will not appear together
in edges.










## 324 - Wiggle Sort II
~2~  ['Sort']
Given an unsorted array nums, reorder it such that
    nums[0] < nums[1] > nums[2] < nums[3]....



    Example:
    (1) Given nums = [1, 5, 1, 1, 6, 4], one possible answer is [1, 4, 1, 5, 1, 6]. 
    (2) Given nums = [1, 3, 2, 2, 3, 1], one possible answer is [2, 3, 1, 3, 1, 2].



    Note:
    You may assume all input has valid answer.



    Follow Up:
    Can you do it in O(n) time and/or in-place with O(1) extra space?


Credits:Special thanks to @dietpepsi for adding this problem and creating all test cases.










## 325 - Maximum Size Subarray Sum Equals k
~2~  []
Given an array _nums_ and a target value _k_, find the maximum length of a
subarray that sums to _k_. If there isn't one, return 0 instead.

**Example 1:**
Given _nums_ = `[1, -1, 5, -2, 3]`, _k_ = `3`,
return `4`. (because the subarray `[1, -1, 5, -2]` sums to 3 and is the
longest)

**Example 2:**
Given _nums_ = `[-2, -1, 2, 1]`, _k_ = `1`,
return `2`. (because the subarray `[-1, 2]` sums to 1 and is the longest)

**Follow Up:**
Can you do it in O(_n_) time?










## 326 - Power of Three
~1~  ['Math']
Given an integer, write a function to determine if it is a power of three.


    Follow up:
    Could you do it without using any loop / recursion?


Credits:Special thanks to @dietpepsi for adding this problem and creating all test cases.










## 327 - Count of Range Sum
~3~  ['Divide and Conquer', 'Binary Search Tree']
Given an integer array nums, return the number of range sums that lie in [lower, upper] inclusive.

    Range sum S(i, j) is defined as the sum of the elements in nums between indices i and 
    j (i ≤ j), inclusive.



    Note:
    A naive algorithm of O(n2) is trivial. You MUST do better than that.


    Example:
    Given nums = [-2, 5, -1], lower = -2, upper = 2,
    Return 3.
    The three ranges are : [0, 0], [2, 2], [0, 2] and their respective sums are: -2, -1, 2.


Credits:Special thanks to @dietpepsi for adding this problem and creating all test cases.










## 328 - Odd Even Linked List
~2~  ['Linked List']
Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.

You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.


Example:
Given 1->2->3->4->5->NULL,
return 1->3->5->2->4->NULL.


Note:
The relative order inside both the even and odd groups should remain as it was in the input. 
The first node is considered odd, the second node even and so on ...


Credits:Special thanks to @DjangoUnchained for adding this problem and creating all test cases.










## 329 - Longest Increasing Path in a Matrix
~3~  ['Depth-first Search', 'Topological Sort', 'Memoization']
Given an integer matrix, find the length of the longest increasing path.


From each cell, you can either move to four directions: left, right, up or down. You may NOT move diagonally or move outside of the boundary (i.e. wrap-around is not allowed).


Example 1:

nums = [
  [9,9,4],
  [6,6,8],
  [2,1,1]
]




Return 4

The longest increasing path is [1, 2, 6, 9].


Example 2:

nums = [
  [3,4,5],
  [3,2,6],
  [2,2,1]
]




Return 4

The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed.

Credits:Special thanks to @dietpepsi for adding this problem and creating all test cases.










## 330 - Patching Array
~3~  ['Greedy']
Given a sorted positive integer array nums and an integer n, add/patch elements to the array such that any number in range [1, n] inclusive can be formed by the sum of some elements in the array. Return the minimum number of patches required.


Example 1:
nums = [1, 3], n = 6
Return 1.

Combinations of nums are [1], [3], [1,3], which form possible sums of: 1, 3, 4.
Now if we add/patch 2 to nums, the combinations are: [1], [2], [3], [1,3], [2,3], [1,2,3].
Possible sums are 1, 2, 3, 4, 5, 6, which now covers the range [1, 6].
So we only need 1 patch.

Example 2:
nums = [1, 5, 10], n = 20
Return 2.
The two patches can be [2, 4].

Example 3:
nums = [1, 2, 2], n = 5
Return 0.

Credits:Special thanks to @dietpepsi for adding this problem and creating all test cases.










## 331 - Verify Preorder Serialization of a Binary Tree
~2~  ['Stack']
One way to serialize a binary tree is to use pre-order traversal. When we encounter a non-null node, we record the node's value. If it is a null node, we record using a sentinel value such as #.


     _9_
    /   \
   3     2
  / \   / \
 4   1  #  6
/ \ / \   / \
# # # #   # #


For example, the above binary tree can be serialized to the string "9,3,4,#,#,1,#,#,2,#,6,#,#", where # represents a null node.


Given a string of comma separated values, verify whether it is a correct preorder traversal serialization of a binary tree. Find an algorithm without reconstructing the tree.

Each comma separated value in the string must be either an integer or a character '#' representing null pointer.

You may assume that the input format is always valid, for example it could never contain two consecutive commas such as "1,,3".

Example 1:
"9,3,4,#,#,1,#,#,2,#,6,#,#"
Return true
Example 2:
"1,#"
Return false
Example 3:
"9,#,#,1"
Return false

Credits:Special thanks to @dietpepsi for adding this problem and creating all test cases.










## 332 - Reconstruct Itinerary
~2~  ['Depth-first Search', 'Graph']
Given a list of airline tickets represented by pairs of departure and arrival airports [from, to], reconstruct the itinerary in order. All of the tickets belong to a man who departs from JFK. Thus, the itinerary must begin with JFK.


Note:

If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string. For example, the itinerary ["JFK", "LGA"] has a smaller lexical order than ["JFK", "LGB"].
All airports are represented by three capital letters (IATA code).
You may assume all tickets form at least one valid itinerary.




    Example 1:
    tickets = [["MUC", "LHR"], ["JFK", "MUC"], ["SFO", "SJC"], ["LHR", "SFO"]]
    Return ["JFK", "MUC", "LHR", "SFO", "SJC"].


    Example 2:
    tickets = [["JFK","SFO"],["JFK","ATL"],["SFO","ATL"],["ATL","JFK"],["ATL","SFO"]]
    Return ["JFK","ATL","JFK","SFO","ATL","SFO"].
    Another possible reconstruction is ["JFK","SFO","ATL","JFK","ATL","SFO"]. But it is larger in lexical order.


Credits:Special thanks to @dietpepsi for adding this problem and creating all test cases.










## 333 - Largest BST Subtree
~2~  []
Given a binary tree, find the largest subtree which is a Binary Search Tree
(BST), where largest means subtree with largest number of nodes in it.

Note:
A subtree must include all of its descendants.
Here's an example:



        10    / \   5  15  / \   \  1   8   7

The Largest BST Subtree in this case is the highlighted one.
The return value is the subtree's size, which is 3.



Hint:

  1. You can recursively use algorithm similar to [98\. Validate Binary Search Tree](https://leetcode.com/problems/validate-binary-search-tree/) at each node of the tree, which will result in O(nlogn) time complexity.

Follow up:
Can you figure out ways to solve it with O(n) time complexity?










## 334 - Increasing Triplet Subsequence
~2~  []
Given an unsorted array return whether an increasing subsequence of length 3 exists or not in the array.


Formally the function should:
Return true if there exists i, j, k  
such that arr[i] < arr[j] < arr[k] given 0 ≤ i < j < k ≤ n-1 
else return false.



Your algorithm should run in O(n) time complexity and O(1) space complexity.


Examples:
Given [1, 2, 3, 4, 5],
return true.


Given [5, 4, 3, 2, 1],
return false.


Credits:Special thanks to @DjangoUnchained for adding this problem and creating all test cases.










## 335 - Self Crossing
~3~  ['Math']
You are given an array x of n positive numbers. You start at point (0,0) and moves x[0] metres to the north, then x[1] metres to the west,
    x[2] metres to the south,
    x[3] metres to the east and so on. In other words, after each move your direction changes
    counter-clockwise.


    Write a one-pass algorithm with O(1) extra space to determine, if your path crosses itself, or not.



Example 1:

Given x = [2, 1, 1, 2],
?????
?   ?
???????>
    ?

Return true (self crossing)




Example 2:

Given x = [1, 2, 3, 4],
????????
?      ?
?
?
?????????????>

Return false (not self crossing)




Example 3:

Given x = [1, 1, 1, 1],
?????
?   ?
?????>

Return true (self crossing)



Credits:Special thanks to @dietpepsi for adding this problem and creating all test cases.










## 336 - Palindrome Pairs
~3~  ['Hash Table', 'String', 'Trie']
Given a list of unique words, find all pairs of distinct indices (i, j) in the given list, so that the concatenation of the two words, i.e. words[i] + words[j] is a palindrome.



    Example 1:
    Given words = ["bat", "tab", "cat"]
    Return [[0, 1], [1, 0]]
    The palindromes are ["battab", "tabbat"]


    Example 2:
    Given words = ["abcd", "dcba", "lls", "s", "sssll"]
    Return [[0, 1], [1, 0], [3, 2], [2, 4]]
    The palindromes are ["dcbaabcd", "abcddcba", "slls", "llssssll"]


Credits:Special thanks to @dietpepsi for adding this problem and creating all test cases.










## 337 - House Robber III
~2~  ['Tree', 'Depth-first Search']
The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the "root." Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that "all houses in this place forms a binary tree". It will automatically contact the police if two directly-linked houses were broken into on the same night.



Determine the maximum amount of money the thief can rob tonight without alerting the police.


Example 1:

     3
    / \
   2   3
    \   \ 
     3   1

Maximum amount of money the thief can rob = 3 + 3 + 1 = 7.


Example 2:

     3
    / \
   4   5
  / \   \ 
 1   3   1

Maximum amount of money the thief can rob = 4 + 5 = 9.


Credits:Special thanks to @dietpepsi for adding this problem and creating all test cases.










## 338 - Counting Bits
~2~  ['Dynamic Programming', 'Bit Manipulation']
Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1's in their binary representation and return them as an array.


Example:
For num = 5 you should return [0,1,1,2,1,2].


Follow up:

It is very easy to come up with a solution with run time O(n*sizeof(integer)). But can you do it in linear time O(n) /possibly in a single pass?
Space complexity should be O(n).
Can you do it like a boss? Do it without using any builtin function like __builtin_popcount  in c++ or in any other language.



Credits:Special thanks to @ syedee  for adding this problem and creating all test cases.










## 339 - Nested List Weight Sum
~1~  []
Given a nested list of integers, return the sum of all integers in the list
weighted by their depth.

Each element is either an integer, or a list -- whose elements may also be
integers or other lists.

**Example 1:**
Given the list `[[1,1],2,[1,1]]`, return **10**. (four 1's at depth 2, one 2
at depth 1)

**Example 2:**
Given the list `[1,[4,[6]]]`, return **27**. (one 1 at depth 1, one 4 at depth
2, and one 6 at depth 3; 1 + 4*2 + 6*3 = 27)










## 340 - Longest Substring with At Most K Distinct Characters
~3~  []
Given a string, find the length of the longest substring T that contains at
most _k_ distinct characters.

For example, Given s = `"eceba"` and k = 2,

T is "ece" which its length is 3.










## 341 - Flatten Nested List Iterator
~2~  ['Stack', 'Design']
Given a nested list of integers, implement an iterator to flatten it.

Each element is either an integer, or a list -- whose elements may also be integers or other lists.

Example 1:
Given the list [[1,1],2,[1,1]],

By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,1,2,1,1].



Example 2:
Given the list [1,[4,[6]]],

By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,4,6].










## 342 - Power of Four
~1~  ['Bit Manipulation']
Given an integer (signed 32 bits), write a function to check whether it is a power of 4.

Example:
Given num = 16, return true.
Given num = 5, return false.


Follow up: Could you solve it without loops/recursion?

Credits:Special thanks to @yukuairoy  for adding this problem and creating all test cases.










## 343 - Integer Break
~2~  ['Math', 'Dynamic Programming']
Given a positive integer n, break it into the sum of at least two positive integers and maximize the product of those integers. Return the maximum product you can get.



For example, given n = 2, return 1 (2 = 1 + 1); given n = 10, return 36 (10 = 3 + 3 + 4).



Note: You may assume that n is not less than 2 and not larger than 58.


Credits:Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.










## 344 - Reverse String
~1~  ['Two Pointers', 'String']
Write a function that takes a string as input and returns the string reversed.


Example:
Given s = "hello", return "olleh".










## 345 - Reverse Vowels of a String
~1~  ['Two Pointers', 'String']
Write a function that takes a string as input and reverse only the vowels of a string.


Example 1:
Given s = "hello", return "holle".



Example 2:
Given s = "leetcode", return "leotcede".



Note:
The vowels does not include the letter "y".










## 346 - Moving Average from Data Stream
~1~  []
Given a stream of integers and a window size, calculate the moving average of
all integers in the sliding window.

For example,
MovingAverage m = new MovingAverage(3);
m.next(1) = 1
m.next(10) = (1 + 10) / 2
m.next(3) = (1 + 10 + 3) / 3
m.next(5) = (10 + 3 + 5) / 3










## 347 - Top K Frequent Elements
~2~  ['Hash Table', 'Heap']
Given a non-empty array of integers, return the k most frequent elements.

For example,
Given [1,1,1,2,2,3] and k = 2, return [1,2].


Note: 

You may assume k is always valid, 1 ≤ k ≤ number of unique elements.
Your algorithm's time complexity must be better than O(n log n), where n is the array's size.










## 348 - Design Tic-Tac-Toe
~2~  []
Design a Tic-tac-toe game that is played between two players on a n x n grid.

You may assume the following rules:

A move is guaranteed to be valid and is placed on an empty block.
Once a winning condition is reached, no more moves is allowed.
A player who succeeds in placing n of their marks in a horizontal, vertical,
or diagonal row wins the game.
Example:
Given n = 3, assume that player 1 is "X" and player 2 is "O" in the board.

TicTacToe toe = new TicTacToe(3);

toe.move(0, 0, 1); -> Returns 0 (no one wins)
|X| | |
| | | | // Player 1 makes a move at (0, 0).
| | | |

toe.move(0, 2, 2); -> Returns 0 (no one wins)
|X| |O|
| | | | // Player 2 makes a move at (0, 2).
| | | |

toe.move(2, 2, 1); -> Returns 0 (no one wins)
|X| |O|
| | | | // Player 1 makes a move at (2, 2).
| | |X|

toe.move(1, 1, 2); -> Returns 0 (no one wins)
|X| |O|
| |O| | // Player 2 makes a move at (1, 1).
| | |X|

toe.move(2, 0, 1); -> Returns 0 (no one wins)
|X| |O|
| |O| | // Player 1 makes a move at (2, 0).
|X| |X|

toe.move(1, 0, 2); -> Returns 0 (no one wins)
|X| |O|
|O|O| | // Player 2 makes a move at (1, 0).
|X| |X|

toe.move(2, 1, 1); -> Returns 1 (player 1 wins)
|X| |O|
|O|O| | // Player 1 makes a move at (2, 1).
|X|X|X|
Follow up:
Could you do better than O(n2) per move() operation?

Hint:

Could you trade extra space such that move() operation can be done in O(1)?
You need two arrays: int rows[n], int cols[n], plus two variables: diagonal,
anti_diagonal.










## 349 - Intersection of Two Arrays
~1~  ['Hash Table', 'Two Pointers', 'Binary Search', 'Sort']
Given two arrays, write a function to compute their intersection.


Example:
Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2].


Note:

Each element in the result must be unique.
The result can be in any order.










## 350 - Intersection of Two Arrays II
~1~  ['Hash Table', 'Two Pointers', 'Binary Search', 'Sort']
Given two arrays, write a function to compute their intersection.


Example:
Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2, 2].


Note:

Each element in the result should appear as many times as it shows in both arrays.
The result can be in any order.



Follow up:

What if the given array is already sorted? How would you optimize your algorithm?
What if nums1's size is small compared to nums2's size? Which algorithm is better?
What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?










## 351 - Android Unlock Patterns
~2~  []
Given an Android 3x3 key lock screen and two integers m and n, where 1 ≤ m ≤ n
≤ 9, count the total number of unlock patterns of the Android lock screen,
which consist of minimum of m keys and maximum n keys.

Rules for a valid pattern:

  1. Each pattern must connect at least m keys and at most n keys.
  2. All the keys must be distinct.
  3. If the line connecting two consecutive keys in the pattern passes through any other keys, the other keys must have previously selected in the pattern. No jumps through non selected key is allowed.
  4. The order of keys used matters.



![](https://discuss.leetcode.com/uploads/files/1461680355228-cptqh.png)

Explanation:



    | 1 | 2 | 3 || 4 | 5 | 6 || 7 | 8 | 9 |



Invalid move: `4 - 1 - 3 - 6 `
Line 1 - 3 passes through key 2 which had not been selected in the pattern.

Invalid move: `4 - 1 - 9 - 2`
Line 1 - 9 passes through key 5 which had not been selected in the pattern.

Valid move: `2 - 4 - 1 - 3 - 6`
Line 1 - 3 is valid because it passes through key 2, which had been selected
in the pattern

Valid move: `6 - 5 - 4 - 1 - 9 - 2`
Line 1 - 9 is valid because it passes through key 5, which had been selected
in the pattern.

Example:
Given m = 1, n = 1, return 9.

Credits:
Special thanks to [@elmirap](https://discuss.leetcode.com/user/elmirap) for
adding this problem and creating all test cases.










## 352 - Data Stream as Disjoint Intervals
~3~  ['Binary Search Tree']
Given a data stream input of non-negative integers a1, a2, ..., an, ..., summarize the numbers seen so far as a list of disjoint intervals.

For example, suppose the integers from the data stream are 1, 3, 7, 2, 6, ..., then the summary will be:

[1, 1]
[1, 1], [3, 3]
[1, 1], [3, 3], [7, 7]
[1, 3], [7, 7]
[1, 3], [6, 7]


Follow up:
What if there are lots of merges and the number of disjoint intervals are small compared to the data stream's size?


Credits:Special thanks to @yunhong for adding this problem and creating most of the test cases.










## 353 - Design Snake Game
~2~  []
Design a [Snake game](https://en.wikipedia.org/wiki/Snake_%28video_game%29)
that is played on a device with screen size = _width_ x _height_. [Play the
game online](http://patorjk.com/games/snake/) if you are not familiar with the
game.

The snake is initially positioned at the top left corner (0,0) with length = 1
unit.

You are given a list of food's positions in row-column order. When a snake
eats the food, its length and the game's score both increase by 1.

Each food appears one by one on the screen. For example, the second food will
not appear until the first food was eaten by the snake.

When a food does appear on the screen, it is guaranteed that it will not
appear on a block occupied by the snake.

**Example:**


    Given width = 3, height = 2, and food = [[1,2],[0,1]].Snake snake = new Snake(width, height, food);Initially the snake appears at position (0,0) and the food at (1,2).|S| | || | |F|snake.move("R"); -> Returns 0| |S| || | |F|snake.move("D"); -> Returns 0| | | || |S|F|snake.move("R"); -> Returns 1 (Snake eats the first food and right after that, the second food appears at (0,1) )| |F| || |S|S|snake.move("U"); -> Returns 1| |F|S|| | |S|snake.move("L"); -> Returns 2 (Snake eats the second food)| |S|S|| | |S|snake.move("U"); -> Returns -1 (Game over because snake collides with border)

**Credits:**
Special thanks to [@elmirap](https://discuss.leetcode.com/user/elmirap) for
adding this problem and creating all test cases.










## 354 - Russian Doll Envelopes
~3~  ['Binary Search', 'Dynamic Programming']
You have a number of envelopes with widths and heights given as a pair of integers (w, h). One envelope can fit into another if and only if both the width and height of one envelope is greater than the width and height of the other envelope.


What is the maximum number of envelopes can you Russian doll? (put one inside other)


Example:
Given envelopes = [[5,4],[6,4],[6,7],[2,3]], the maximum number of envelopes you can Russian doll is 3 ([2,3] => [5,4] => [6,7]).










## 355 - Design Twitter
~2~  ['Hash Table', 'Heap', 'Design']
Design a simplified version of Twitter where users can post tweets, follow/unfollow another user and is able to see the 10 most recent tweets in the user's news feed. Your design should support the following methods:



postTweet(userId, tweetId): Compose a new tweet.
getNewsFeed(userId): Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent.
follow(followerId, followeeId): Follower follows a followee.
unfollow(followerId, followeeId): Follower unfollows a followee.



Example:

Twitter twitter = new Twitter();

// User 1 posts a new tweet (id = 5).
twitter.postTweet(1, 5);

// User 1's news feed should return a list with 1 tweet id -> [5].
twitter.getNewsFeed(1);

// User 1 follows user 2.
twitter.follow(1, 2);

// User 2 posts a new tweet (id = 6).
twitter.postTweet(2, 6);

// User 1's news feed should return a list with 2 tweet ids -> [6, 5].
// Tweet id 6 should precede tweet id 5 because it is posted after tweet id 5.
twitter.getNewsFeed(1);

// User 1 unfollows user 2.
twitter.unfollow(1, 2);

// User 1's news feed should return a list with 1 tweet id -> [5],
// since user 1 is no longer following user 2.
twitter.getNewsFeed(1);










## 356 - Line Reflection
~2~  []
Given n points on a 2D plane, find if there is such a line parallel to y-axis
that reflect the given set of points.

**Example 1:**
Given _points_ = `[[1,1],[-1,1]]`, return `true`.

**Example 2:**
Given _points_ = `[[1,1],[-1,-1]]`, return `false`.

**Follow up:**
Could you do better than O(_n_2)?

**Hint:**

  1. Find the smallest and largest x-value for all points.
  2. If there is a line then it should be at y = (minX + maxX) / 2.
  3. For each point, make sure that it has a reflected point in the opposite side.

**Credits:**
Special thanks to [@memoryless](https://discuss.leetcode.com/user/memoryless)
for adding this problem and creating all test cases.










## 357 - Count Numbers with Unique Digits
~2~  ['Math', 'Dynamic Programming', 'Backtracking']
Given a non-negative integer n, count all numbers with unique digits, x, where 0 ≤ x < 10n.


    Example:
Given n = 2, return 91. (The answer should be the total numbers in the range of 0 ≤ x < 100, excluding [11,22,33,44,55,66,77,88,99])


Credits:Special thanks to @memoryless for adding this problem and creating all test cases.










## 358 - Rearrange String k Distance Apart
~3~  []
Given a non-empty string **str** and an integer **k**, rearrange the string
such that the same characters are at least distance **k** from each other.

All input strings are given in lowercase letters. If it is not possible to
rearrange the string, return an empty string `""`.

**Example 1:**


    str = "aabbcc", k = 3Result: "abcabc"The same letters are at least distance 3 from each other.

**Example 2:**


    str = "aaabc", k = 3 Answer: ""It is not possible to rearrange the string.

**Example 3:**


    str = "aaadbbcc", k = 2Answer: "abacabcd"Another possible answer is: "abcabcda"The same letters are at least distance 2 from each other.

**Credits:**
Special thanks to [@elmirap](https://discuss.leetcode.com/user/elmirap) for
adding this problem and creating all test cases.










## 359 - Logger Rate Limiter
~1~  []
Design a logger system that receive stream of messages along with its
timestamps, each message should be printed if and only if it is not printed in
the last 10 seconds.

Given a message and a timestamp (in seconds granularity), return true if the
message should be printed in the given timestamp, otherwise returns false.

It is possible that several messages arrive roughly at the same time.

Example:

Logger logger = new Logger();

// logging string "foo" at timestamp 1
logger.shouldPrintMessage(1, "foo"); returns true;

// logging string "bar" at timestamp 2
logger.shouldPrintMessage(2,"bar"); returns true;

// logging string "foo" at timestamp 3
logger.shouldPrintMessage(3,"foo"); returns false;

// logging string "bar" at timestamp 8
logger.shouldPrintMessage(8,"bar"); returns false;

// logging string "foo" at timestamp 10
logger.shouldPrintMessage(10,"foo"); returns false;

// logging string "foo" at timestamp 11
logger.shouldPrintMessage(11,"foo"); returns true;

Credits:
Special thanks to @memoryless for adding this problem and creating all test
cases.










## 360 - Sort Transformed Array
~2~  []
Given a **sorted** array of integers _nums_ and integer values _a_, _b_ and
_c_. Apply a function of the form f(_x_) = _ax_2 \+ _bx_ \+ _c_ to each
element _x_ in the array.

The returned array must be in **sorted order**.

Expected time complexity: **O(_n_)**

**Example:**


    nums = [-4, -2, 2, 4], a = 1, b = 3, c = 5,Result: [3, 9, 15, 33]nums = [-4, -2, 2, 4], a = -1, b = 3, c = 5Result: [-23, -5, 1, 7]

**Credits:**
Special thanks to [@elmirap](https://discuss.leetcode.com/user/elmirap) for
adding this problem and creating all test cases.










## 361 - Bomb Enemy
~2~  []
Given a 2D grid, each cell is either a wall `'W'`, an enemy `'E'` or empty
`'0'` (the number zero), return the maximum enemies you can kill using one
bomb.
The bomb kills all the enemies in the same row and column from the planted
point until it hits the wall since the wall is too strong to be destroyed.
Note that you can only put the bomb at an empty cell.

**Example:**


    For the given grid0 E 0 0E 0 W E0 E 0 0return 3. (Placing a bomb at (1,1) kills 3 enemies)

**Credits:**
Special thanks to [@memoryless](https://discuss.leetcode.com/user/memoryless)
for adding this problem and creating all test cases.










## 362 - Design Hit Counter
~2~  []
Design a hit counter which counts the number of hits received in the past 5
minutes.

Each function accepts a timestamp parameter (in seconds granularity) and you
may assume that calls are being made to the system in chronological order (ie,
the timestamp is monotonically increasing). You may assume that the earliest
timestamp starts at 1.

It is possible that several hits arrive roughly at the same time.

**Example:**


    HitCounter counter = new HitCounter();// hit at timestamp 1.counter.hit(1);// hit at timestamp 2.counter.hit(2);// hit at timestamp 3.counter.hit(3);// get hits at timestamp 4, should return 3.counter.getHits(4);// hit at timestamp 300.counter.hit(300);// get hits at timestamp 300, should return 4.counter.getHits(300);// get hits at timestamp 301, should return 3.counter.getHits(301); 

**Follow up:**
What if the number of hits per second could be very large? Does your design
scale?

**Credits:**
Special thanks to [@elmirap](https://discuss.leetcode.com/user/elmirap) for
adding this problem and creating all test cases.










## 363 - Max Sum of Rectangle No Larger Than K
~3~  ['Binary Search', 'Dynamic Programming', 'Queue']
Given a non-empty 2D matrix matrix and an integer k, find the max sum of a rectangle in the matrix such that its sum is no larger than k.

Example:
Given matrix = [
  [1,  0, 1],
  [0, -2, 3]
]
k = 2



The answer is 2. Because the sum of rectangle [[0, 1], [-2, 3]] is 2 and 2 is the max number no larger than k (k = 2).

Note:

The rectangle inside the matrix must have an area > 0.
What if the number of rows is much larger than the number of columns?



Credits:Special thanks to @fujiaozhu for adding this problem and creating all test cases.










## 364 - Nested List Weight Sum II
~2~  []
Given a nested list of integers, return the sum of all integers in the list
weighted by their depth.

Each element is either an integer, or a list -- whose elements may also be
integers or other lists.

Different from the previous question where weight is increasing from root to
leaf, now the weight is defined from bottom up. i.e., the leaf level integers
have weight 1, and the root level integers have the largest weight.

Example 1:
Given the list [[1,1],2,[1,1]], return 8. (four 1's at depth 1, one 2 at depth
2)

Example 2:
Given the list [1,[4,[6]]], return 17. (one 1 at depth 3, one 4 at depth 2,
and one 6 at depth 1; 1*3 + 4*2 + 6*1 = 17)










## 365 - Water and Jug Problem
~2~  ['Math']
You are given two jugs with capacities x and y litres. There is an infinite amount of water supply available.
You need to determine whether it is possible to measure exactly z litres using these two jugs.

If z liters of water is measurable, you must have z liters of water contained within one or both buckets by the end.


Operations allowed:

Fill any of the jugs completely with water.
Empty any of the jugs.
Pour water from one jug into another till the other jug is completely full or the first jug itself is empty.



Example 1: (From the famous "Die Hard" example)

Input: x = 3, y = 5, z = 4
Output: True



Example 2:

Input: x = 2, y = 6, z = 5
Output: False



Credits:Special thanks to @vinod23 for adding this problem and creating all test cases.










## 366 - Find Leaves of Binary Tree
~2~  []
Given a binary tree, find all leaves and then remove those leaves. Then repeat
the previous steps until the tree is empty.

**Example:**
Given binary tree


              1         / \        2   3       / \           4   5    

Returns `[4, 5, 3], [2], [1]`.

**Explanation:**
1\. Remove the leaves `[4, 5, 3]` from the tree



              1         /         2          

2\. Remove the leaf `[2]` from the tree



              1          

3\. Remove the leaf `[1]` from the tree



              []         

Returns `[4, 5, 3], [2], [1]`.



**Credits:**
Special thanks to [@elmirap](https://discuss.leetcode.com/user/elmirap) for
adding this problem and creating all test cases.










## 367 - Valid Perfect Square
~1~  ['Math', 'Binary Search']
Given a positive integer num, write a function which returns True if num is a perfect square else False.


Note: Do not use any built-in library function such as sqrt.


Example 1:

Input: 16
Returns: True



Example 2:

Input: 14
Returns: False



Credits:Special thanks to @elmirap for adding this problem and creating all test cases.










## 368 - Largest Divisible Subset
~2~  ['Math', 'Dynamic Programming']
Given a set of distinct positive integers, find the largest subset such that every pair (Si, Sj) of elements in this subset satisfies: Si % Sj = 0 or Sj % Si = 0.


If there are multiple solutions, return any subset is fine.


Example 1:

nums: [1,2,3]

Result: [1,2] (of course, [1,3] will also be ok)



Example 2:

nums: [1,2,4,8]

Result: [1,2,4,8]



Credits:Special thanks to @Stomach_ache for adding this problem and creating all test cases.










## 369 - Plus One Linked List
~2~  []
Given a non-negative number represented as a singly linked list of digits,
plus one to the number.

The digits are stored such that the most significant digit is at the head of
the list.

**Example:**


    Input:1->2->3Output:1->2->4










## 370 - Range Addition
~2~  []
Assume you have an array of length **_n_** initialized with all **0**'s and
are given **_k_** update operations.

Each operation is represented as a triplet: **[startIndex, endIndex, inc]**
which increments each element of subarray **A[startIndex ... endIndex]**
(startIndex and endIndex inclusive) with **inc**.

Return the modified array after all **_k_** operations were executed.

**Example:**


    Given:    length = 5,    updates = [        [1,  3,  2],        [2,  4,  3],        [0,  2, -2]    ]Output:    [-2, 0, 3, 5, 3]

**Explanation:**


    Initial state:[ 0, 0, 0, 0, 0 ]After applying operation [1, 3, 2]:[ 0, 2, 2, 2, 0 ]After applying operation [2, 4, 3]:[ 0, 2, 5, 5, 3 ]After applying operation [0, 2, -2]:[-2, 0, 3, 5, 3 ]

**Hint:**

  1. Thinking of using advanced data structures? You are thinking it too complicated.
  2. For each update operation, do you really need to update all elements between i and j?
  3. Update only the first and end element is sufficient.
  4. The optimal time complexity is O(**_k_** \+ **_n_**) and uses O(1) extra space.

**Credits:**
Special thanks to [@vinod23](https://discuss.leetcode.com/user/vinod23) for
adding this problem and creating all test cases.










## 371 - Sum of Two Integers
~1~  ['Bit Manipulation']
Calculate the sum of two integers a and b, but you are not allowed to use the operator + and -.

Example:
Given a = 1 and b = 2, return 3.


Credits:Special thanks to @fujiaozhu for adding this problem and creating all test cases.










## 372 - Super Pow
~2~  ['Math']
Your task is to calculate ab mod 1337 where a is a positive integer and b is an extremely large positive integer given in the form of an array.


Example1:

a = 2
b = [3]

Result: 8



Example2:

a = 2
b = [1,0]

Result: 1024



Credits:Special thanks to @Stomach_ache for adding this problem and creating all test cases.










## 373 - Find K Pairs with Smallest Sums
~2~  ['Heap']
You are given two integer arrays nums1 and nums2 sorted in ascending order and an integer k. 


Define a pair (u,v) which consists of one element from the first array and one element from the second array.

Find the k pairs (u1,v1),(u2,v2) ...(uk,vk) with the smallest sums.


Example 1:

Given nums1 = [1,7,11], nums2 = [2,4,6],  k = 3

Return: [1,2],[1,4],[1,6]

The first 3 pairs are returned from the sequence:
[1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]



Example 2:

Given nums1 = [1,1,2], nums2 = [1,2,3],  k = 2

Return: [1,1],[1,1]

The first 2 pairs are returned from the sequence:
[1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]



Example 3:

Given nums1 = [1,2], nums2 = [3],  k = 3 

Return: [1,3],[2,3]

All possible pairs are returned from the sequence:
[1,3],[2,3]



Credits:Special thanks to @elmirap and @StefanPochmann for adding this problem and creating all test cases.










## 374 - Guess Number Higher or Lower
~1~  ['Binary Search']
We are playing the Guess Game. The game is as follows: 

I pick a number from 1 to n. You have to guess which number I picked.

Every time you guess wrong, I'll tell you whether the number is higher or lower.

You call a pre-defined API guess(int num) which returns 3 possible results (-1, 1, or 0):

-1 : My number is lower
 1 : My number is higher
 0 : Congrats! You got it!


Example:

n = 10, I pick 6.

Return 6.










## 375 - Guess Number Higher or Lower II
~2~  ['Dynamic Programming', 'Minimax']
We are playing the Guess Game. The game is as follows: 

I pick a number from 1 to n. You have to guess which number I picked.

Every time you guess wrong, I'll tell you whether the number I picked is higher or lower. 

However, when you guess a particular number x,  and you guess wrong, you pay $x. You win the game when you guess the number I picked.


Example:

n = 10, I pick 8.

First round:  You guess 5, I tell you that it's higher. You pay $5.
Second round: You guess 7, I tell you that it's higher. You pay $7.
Third round:  You guess 9, I tell you that it's lower. You pay $9.

Game over. 8 is the number I picked.

You end up paying $5 + $7 + $9 = $21.



Given a particular n ≥ 1, find out how much money you need to have to guarantee a win.

Credits:Special thanks to @agave and @StefanPochmann for adding this problem and creating all test cases.










## 376 - Wiggle Subsequence
~2~  ['Dynamic Programming', 'Greedy']
A sequence of numbers is called a wiggle sequence if the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with fewer than two elements is trivially a wiggle sequence. 

For example, [1,7,4,9,2,5] is a wiggle sequence because the differences (6,-3,5,-7,3) are alternately positive and negative. In contrast, [1,4,7,2,5] and [1,7,4,5,5] are not wiggle sequences, the first because its first two differences are positive and the second because its last difference is zero.

Given a sequence of integers, return the length of the longest subsequence that is a wiggle sequence. A subsequence is obtained by deleting some number of elements (eventually, also zero) from the original sequence, leaving the remaining elements in their original order.

Examples:

Input: [1,7,4,9,2,5]
Output: 6
The entire sequence is a wiggle sequence.

Input: [1,17,5,10,13,15,10,5,16,8]
Output: 7
There are several subsequences that achieve this length. One is [1,17,10,13,10,16,8].

Input: [1,2,3,4,5,6,7,8,9]
Output: 2



Follow up:
Can you do it in O(n) time?


Credits:Special thanks to @agave and @StefanPochmann for adding this problem and creating all test cases.










## 377 - Combination Sum IV
~2~  ['Dynamic Programming']
Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target.

Example:

nums = [1, 2, 3]
target = 4

The possible combination ways are:
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)

Note that different sequences are counted as different combinations.

Therefore the output is 7.



Follow up:
What if negative numbers are allowed in the given array?
How does it change the problem?
What limitation we need to add to the question to allow negative numbers? 

Credits:Special thanks to @pbrother for adding this problem and creating all test cases.










## 378 - Kth Smallest Element in a Sorted Matrix
~2~  ['Binary Search', 'Heap']
Given a n x n matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix.


Note that it is the kth smallest element in the sorted order, not the kth distinct element.


Example:

matrix = [
   [ 1,  5,  9],
   [10, 11, 13],
   [12, 13, 15]
],
k = 8,

return 13.



Note: 
You may assume k is always valid, 1 ≤ k ≤ n2.










## 379 - Design Phone Directory
~2~  []
Design a Phone Directory which supports the following operations:



  1. `get`: Provide a number which is not assigned to anyone.
  2. `check`: Check if a number is available or not.
  3. `release`: Recycle or release a number.

**Example:**


    // Init a phone directory containing a total of 3 numbers: 0, 1, and 2.PhoneDirectory directory = new PhoneDirectory(3);// It can return any available phone number. Here we assume it returns 0.directory.get();// Assume it returns 1.directory.get();// The number 2 is available, so return true.directory.check(2);// It returns 2, the only number that is left.directory.get();// The number 2 is no longer available, so return false.directory.check(2);// Release number 2 back to the pool.directory.release(2);// Number 2 is available again, return true.directory.check(2);










## 380 - Insert Delete GetRandom O(1)
~2~  ['Array', 'Hash Table', 'Design']
Design a data structure that supports all following operations in average O(1) time.



insert(val): Inserts an item val to the set if not already present.
remove(val): Removes an item val from the set if present.
getRandom: Returns a random element from current set of elements. Each element must have the same probability of being returned.



Example:

// Init an empty set.
RandomizedSet randomSet = new RandomizedSet();

// Inserts 1 to the set. Returns true as 1 was inserted successfully.
randomSet.insert(1);

// Returns false as 2 does not exist in the set.
randomSet.remove(2);

// Inserts 2 to the set, returns true. Set now contains [1,2].
randomSet.insert(2);

// getRandom should return either 1 or 2 randomly.
randomSet.getRandom();

// Removes 1 from the set, returns true. Set now contains [2].
randomSet.remove(1);

// 2 was already in the set, so return false.
randomSet.insert(2);

// Since 2 is the only number in the set, getRandom always return 2.
randomSet.getRandom();










## 381 - Insert Delete GetRandom O(1) - Duplicates allowed
~3~  ['Array', 'Hash Table', 'Design']
Design a data structure that supports all following operations in average O(1) time.
Note: Duplicate elements are allowed.


insert(val): Inserts an item val to the collection.
remove(val): Removes an item val from the collection if present.
getRandom: Returns a random element from current collection of elements. The probability of each element being returned is linearly related to the number of same value the collection contains.



Example:

// Init an empty collection.
RandomizedCollection collection = new RandomizedCollection();

// Inserts 1 to the collection. Returns true as the collection did not contain 1.
collection.insert(1);

// Inserts another 1 to the collection. Returns false as the collection contained 1. Collection now contains [1,1].
collection.insert(1);

// Inserts 2 to the collection, returns true. Collection now contains [1,1,2].
collection.insert(2);

// getRandom should return 1 with the probability 2/3, and returns 2 with the probability 1/3.
collection.getRandom();

// Removes 1 from the collection, returns true. Collection now contains [1,2].
collection.remove(1);

// getRandom should return 1 and 2 both equally likely.
collection.getRandom();










## 382 - Linked List Random Node
~2~  ['Reservoir Sampling']
Given a singly linked list, return a random node's value from the linked list. Each node must have the same probability of being chosen.

Follow up:
What if the linked list is extremely large and its length is unknown to you? Could you solve this efficiently without using extra space?


Example:

// Init a singly linked list [1,2,3].
ListNode head = new ListNode(1);
head.next = new ListNode(2);
head.next.next = new ListNode(3);
Solution solution = new Solution(head);

// getRandom() should return either 1, 2, or 3 randomly. Each element should have equal probability of returning.
solution.getRandom();










## 383 - Ransom Note
~1~  ['String']
Given an arbitrary ransom note string and another string containing letters from all the magazines, write a function that will return true if the ransom 
note can be constructed from the magazines ; otherwise, it will return false. 


Each letter in the magazine string can only be used once in your ransom note.


Note:
You may assume that both strings contain only lowercase letters.



canConstruct("a", "b") -> false
canConstruct("aa", "ab") -> false
canConstruct("aa", "aab") -> true










## 384 - Shuffle an Array
~2~  []
Shuffle a set of numbers without duplicates.


Example:

// Init an array with set 1, 2, and 3.
int[] nums = {1,2,3};
Solution solution = new Solution(nums);

// Shuffle the array [1,2,3] and return its result. Any permutation of [1,2,3] must equally likely to be returned.
solution.shuffle();

// Resets the array back to its original configuration [1,2,3].
solution.reset();

// Returns the random shuffling of array [1,2,3].
solution.shuffle();










## 385 - Mini Parser
~2~  ['String', 'Stack']
Given a nested list of integers represented as a string, implement a parser to deserialize it.

Each element is either an integer, or a list -- whose elements may also be integers or other lists.

Note:
You may assume that the string is well-formed:

String is non-empty.
String does not contain white spaces.
String contains only digits 0-9, [, - ,, ].



Example 1:

Given s = "324",

You should return a NestedInteger object which contains a single integer 324.



Example 2:

Given s = "[123,[456,[789]]]",

Return a NestedInteger object containing a nested list with 2 elements:

1. An integer containing value 123.
2. A nested list containing two elements:
    i.  An integer containing value 456.
    ii. A nested list with one element:
         a. An integer containing value 789.










## 386 - Lexicographical Numbers
~2~  []
Given an integer n, return 1 - n in lexicographical order.



For example, given 13, return: [1,10,11,12,13,2,3,4,5,6,7,8,9].



Please optimize your algorithm to use less time and space. The input size may be as large as 5,000,000.










## 387 - First Unique Character in a String
~1~  []
Given a string, find the first non-repeating character in it and return it's index. If it doesn't exist, return -1.

Examples:

s = "leetcode"
return 0.

s = "loveleetcode",
return 2.




Note: You may assume the string contain only lowercase letters.










## 388 - Longest Absolute File Path
~2~  []
Suppose we abstract our file system by a string in the following manner:

The string "dir\n\tsubdir1\n\tsubdir2\n\t\tfile.ext" represents:

dir
    subdir1
    subdir2
        file.ext


The directory dir contains an empty sub-directory subdir1 and a sub-directory subdir2 containing a file file.ext.

The string "dir\n\tsubdir1\n\t\tfile1.ext\n\t\tsubsubdir1\n\tsubdir2\n\t\tsubsubdir2\n\t\t\tfile2.ext" represents:

dir
    subdir1
        file1.ext
        subsubdir1
    subdir2
        subsubdir2
            file2.ext


The directory dir contains two sub-directories subdir1 and subdir2. subdir1 contains a file file1.ext and an empty second-level sub-directory subsubdir1. subdir2 contains a second-level sub-directory subsubdir2 containing a file file2.ext.

We are interested in finding the longest (number of characters) absolute path to a file within our file system. For example, in the second example above, the longest absolute path is "dir/subdir2/subsubdir2/file2.ext", and its length is 32 (not including the double quotes).

Given a string representing the file system in the above format, return the length of the longest absolute path to file in the abstracted file system. If there is no file in the system, return 0.

Note:

The name of a file contains at least a . and an extension.
The name of a directory or sub-directory will not contain a ..



Time complexity required: O(n) where n is the size of the input string.

Notice that a/aa/aaa/file1.txt is not the longest file path, if there is another path aaaaaaaaaaaaaaaaaaaaa/sth.png.










## 389 - Find the Difference
~1~  ['Hash Table', 'Bit Manipulation']
Given two strings s and t which consist of only lowercase letters.

String t is generated by random shuffling string s and then add one more letter at a random position.

Find the letter that was added in t.

Example:

Input:
s = "abcd"
t = "abcde"

Output:
e

Explanation:
'e' is the letter that was added.










## 390 - Elimination Game
~2~  []
There is a list of sorted integers from 1 to n. Starting from left to right, remove the first number and every other number afterward until you reach the end of the list.

Repeat the previous step again, but this time from right to left, remove the right most number and every other number from the remaining numbers.

We keep repeating the steps again, alternating left to right and right to left, until a single number remains.

Find the last number that remains starting with a list of length n.

Example:

Input:
n = 9,
1 2 3 4 5 6 7 8 9
2 4 6 8
2 6
6

Output:
6










## 391 - Perfect Rectangle
~3~  []
Given N axis-aligned rectangles where N > 0, determine if they all together form an exact cover of a rectangular region.



Each rectangle is represented as a bottom-left point and a top-right point. For example, a unit square is represented as [1,1,2,2]. (coordinate of bottom-left point is (1, 1) and top-right point is (2, 2)).



Example 1:

rectangles = [
  [1,1,3,3],
  [3,1,4,2],
  [3,2,4,4],
  [1,3,2,4],
  [2,3,3,4]
]

Return true. All 5 rectangles together form an exact cover of a rectangular region.






Example 2:

rectangles = [
  [1,1,2,3],
  [1,3,2,4],
  [3,1,4,2],
  [3,2,4,4]
]

Return false. Because there is a gap between the two rectangular regions.






Example 3:

rectangles = [
  [1,1,3,3],
  [3,1,4,2],
  [1,3,2,4],
  [3,2,4,4]
]

Return false. Because there is a gap in the top center.






Example 4:

rectangles = [
  [1,1,3,3],
  [3,1,4,2],
  [1,3,2,4],
  [2,2,4,4]
]

Return false. Because two of the rectangles overlap with each other.










## 392 - Is Subsequence
~2~  ['Binary Search', 'Dynamic Programming', 'Greedy']
Given a string s and a string t, check if s is subsequence of t.



You may assume that there is only lower case English letters in both s and t. t is potentially a very long (length ~= 500,000) string, and s is a short string (<=100).



A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, "ace" is a subsequence of "abcde" while "aec" is not).


Example 1:
s = "abc", t = "ahbgdc"


Return true.


Example 2:
s = "axc", t = "ahbgdc"


Return false.


Follow up:
If there are lots of incoming S, say S1, S2, ... , Sk where k >= 1B, and you want to check one by one to see if T has its subsequence. In this scenario, how would you change your code?

Credits:Special thanks to @pbrother for adding this problem and creating all test cases.










## 393 - UTF-8 Validation
~2~  ['Bit Manipulation']
A character in UTF8 can be from 1 to 4 bytes long, subjected to the following rules:

For 1-byte character, the first bit is a 0, followed by its unicode code.
For n-bytes character, the first n-bits are all one's, the n+1 bit is 0, followed by n-1 bytes with most significant 2 bits being 10.

This is how the UTF-8 encoding would work:

   Char. number range  |        UTF-8 octet sequence
      (hexadecimal)    |              (binary)
   --------------------+---------------------------------------------
   0000 0000-0000 007F | 0xxxxxxx
   0000 0080-0000 07FF | 110xxxxx 10xxxxxx
   0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx
   0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx


Given an array of integers representing the data, return whether it is a valid utf-8 encoding.


Note:
The input is an array of integers. Only the least significant 8 bits of each integer is used to store the data. This means each integer represents only 1 byte of data.



Example 1:

data = [197, 130, 1], which represents the octet sequence: 11000101 10000010 00000001.

Return true.
It is a valid utf-8 encoding for a 2-bytes character followed by a 1-byte character.




Example 2:

data = [235, 140, 4], which represented the octet sequence: 11101011 10001100 00000100.

Return false.
The first 3 bits are all one's and the 4th bit is 0 means it is a 3-bytes character.
The next byte is a continuation byte which starts with 10 and that's correct.
But the second continuation byte does not start with 10, so it is invalid.










## 394 - Decode String
~2~  ['Stack', 'Depth-first Search']
Given an encoded string, return it's decoded string.


The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer.


You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc.

Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there won't be input like 3a or 2[4].


Examples:

s = "3[a]2[bc]", return "aaabcbc".
s = "3[a2[c]]", return "accaccacc".
s = "2[abc]3[cd]ef", return "abcabccdcdcdef".










## 395 - Longest Substring with At Least K Repeating Characters
~2~  []
Find the length of the longest substring T of a given string (consists of lowercase letters only) such that every character in T appears no less than k times.


Example 1:

Input:
s = "aaabb", k = 3

Output:
3

The longest substring is "aaa", as 'a' is repeated 3 times.



Example 2:

Input:
s = "ababbc", k = 2

Output:
5

The longest substring is "ababb", as 'a' is repeated 2 times and 'b' is repeated 3 times.










## 396 - Rotate Function
~2~  ['Math']
Given an array of integers A and let n to be its length.



Assume Bk to be an array obtained by rotating the array A k positions clock-wise, we define a "rotation function" F on A as follow:



F(k) = 0 * Bk[0] + 1 * Bk[1] + ... + (n-1) * Bk[n-1].

Calculate the maximum value of F(0), F(1), ..., F(n-1). 


Note:
n is guaranteed to be less than 105.


Example:

A = [4, 3, 2, 6]

F(0) = (0 * 4) + (1 * 3) + (2 * 2) + (3 * 6) = 0 + 3 + 4 + 18 = 25
F(1) = (0 * 6) + (1 * 4) + (2 * 3) + (3 * 2) = 0 + 4 + 6 + 6 = 16
F(2) = (0 * 2) + (1 * 6) + (2 * 4) + (3 * 3) = 0 + 6 + 8 + 9 = 23
F(3) = (0 * 3) + (1 * 2) + (2 * 6) + (3 * 4) = 0 + 2 + 12 + 12 = 26

So the maximum value of F(0), F(1), F(2), F(3) is F(3) = 26.










## 397 - Integer Replacement
~2~  ['Math', 'Bit Manipulation']
Given a positive integer n and you can do operations as follow:




If n is even, replace n with n/2.
If n is odd, you can replace n with either n + 1 or n - 1.




What is the minimum number of replacements needed for n to become 1?




Example 1:

Input:
8

Output:
3

Explanation:
8 -> 4 -> 2 -> 1



Example 2:

Input:
7

Output:
4

Explanation:
7 -> 8 -> 4 -> 2 -> 1
or
7 -> 6 -> 3 -> 2 -> 1










## 398 - Random Pick Index
~2~  ['Reservoir Sampling']
Given an array of integers with possible duplicates, randomly output the index of a given target number. You can assume that the given target number must exist in the array.



Note:
The array size can be very large. Solution that uses too much extra space will not pass the judge.


Example:

int[] nums = new int[] {1,2,3,3,3};
Solution solution = new Solution(nums);

// pick(3) should return either index 2, 3, or 4 randomly. Each index should have equal probability of returning.
solution.pick(3);

// pick(1) should return 0. Since in the array only nums[0] is equal to 1.
solution.pick(1);










## 399 - Evaluate Division
~2~  ['Graph']
Equations are given in the format A / B = k, where  A and B are variables represented as strings, and k is a real number (floating point number). Given some queries, return the answers. If the answer does not exist, return -1.0.

Example:
Given  a / b = 2.0, b / c = 3.0. queries are:  a / c = ?,  b / a = ?, a / e = ?,  a / a = ?, x / x = ? . return  [6.0, 0.5, -1.0, 1.0, -1.0 ].


The input is:  vector<pair<string, string>> equations, vector<double>& values, vector<pair<string, string>> queries , where equations.size() == values.size(), and the values are positive. This represents the equations. Return  vector<double>.


According to the example above:
equations = [ ["a", "b"], ["b", "c"] ],
values = [2.0, 3.0],
queries = [ ["a", "c"], ["b", "a"], ["a", "e"], ["a", "a"], ["x", "x"] ]. 



The input is always valid. You may assume that evaluating the queries will result in no division by zero and there is no contradiction.










## 400 - Nth Digit
~1~  ['Math']
Find the nth digit of the infinite integer sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... 

Note:
n is positive and will fit within the range of a 32-bit signed integer (n < 231).


Example 1:

Input:
3

Output:
3



Example 2:

Input:
11

Output:
0

Explanation:
The 11th digit of the sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... is a 0, which is part of the number 10.










## 401 - Binary Watch
~1~  ['Backtracking', 'Bit Manipulation']
A binary watch has 4 LEDs on the top which represent the hours (0-11), and the 6 LEDs on the bottom represent the minutes (0-59).
Each LED represents a zero or one, with the least significant bit on the right.

For example, the above binary watch reads "3:25".

Given a non-negative integer n which represents the number of LEDs that are currently on, return all possible times the watch could represent.

Example:
Input: n = 1Return: ["1:00", "2:00", "4:00", "8:00", "0:01", "0:02", "0:04", "0:08", "0:16", "0:32"]


Note:

The order of output does not matter.
The hour must not contain a leading zero, for example "01:00" is not valid, it should be "1:00".
The minute must be consist of two digits and may contain a leading zero, for example "10:2" is not valid, it should be "10:02".










## 402 - Remove K Digits
~2~  ['Stack', 'Greedy']
Given a non-negative integer num represented as a string, remove k digits from the number so that the new number is the smallest possible.


Note:

The length of num is less than 10002 and will be ≥ k.
The given num does not contain any leading zero.




Example 1:

Input: num = "1432219", k = 3
Output: "1219"
Explanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.



Example 2:

Input: num = "10200", k = 1
Output: "200"
Explanation: Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes.



Example 3:

Input: num = "10", k = 2
Output: "0"
Explanation: Remove all the digits from the number and it is left with nothing which is 0.










## 403 - Frog Jump
~3~  ['Dynamic Programming']
A frog is crossing a river. The river is divided into x units and at each unit there may or may not exist a stone. The frog can jump on a stone, but it must not jump into the water.

Given a list of stones' positions (in units) in sorted ascending order, determine if the frog is able to cross the river by landing on the last stone. Initially, the frog is on the first stone and assume the first jump must be 1 unit.


If the frog's last jump was k units, then its next jump must be either k - 1, k, or k + 1 units. Note that the frog can only jump in the forward direction.

Note:

The number of stones is ≥ 2 and is < 1,100.
Each stone's position will be a non-negative integer < 231.
The first stone's position is always 0.



Example 1:

[0,1,3,5,6,8,12,17]

There are a total of 8 stones.
The first stone at the 0th unit, second stone at the 1st unit,
third stone at the 3rd unit, and so on...
The last stone at the 17th unit.

Return true. The frog can jump to the last stone by jumping 
1 unit to the 2nd stone, then 2 units to the 3rd stone, then 
2 units to the 4th stone, then 3 units to the 6th stone, 
4 units to the 7th stone, and 5 units to the 8th stone.



Example 2:

[0,1,2,3,4,8,9,11]

Return false. There is no way to jump to the last stone as 
the gap between the 5th and 6th stone is too large.










## 404 - Sum of Left Leaves
~1~  ['Tree']
Find the sum of all left leaves in a given binary tree.

Example:

    3
   / \
  9  20
    /  \
   15   7

There are two left leaves in the binary tree, with values 9 and 15 respectively. Return 24.










## 405 - Convert a Number to Hexadecimal
~1~  ['Bit Manipulation']
Given an integer, write an algorithm to convert it to hexadecimal. For negative integer, two’s complement method is used.


Note:

All letters in hexadecimal (a-f) must be in lowercase.
The hexadecimal string must not contain extra leading 0s. If the number is zero, it is represented by a single zero character '0'; otherwise, the first character in the hexadecimal string will not be the zero character.
The given number is guaranteed to fit within the range of a 32-bit signed integer.
You must not use any method provided by the library which converts/formats the number to hex directly.



Example 1:

Input:
26

Output:
"1a"



Example 2:

Input:
-1

Output:
"ffffffff"










## 406 - Queue Reconstruction by Height
~2~  ['Greedy']
Suppose you have a random list of people standing in a queue. Each person is described by a pair of integers (h, k), where h is the height of the person and k is the number of people in front of this person who have a height greater than or equal to h. Write an algorithm to reconstruct the queue.


Note:
The number of people is less than 1,100.




Example

Input:
[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]

Output:
[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]










## 407 - Trapping Rain Water II
~3~  ['Heap', 'Breadth-first Search']
Given an m x n matrix of positive integers representing the height of each unit cell in a 2D elevation map, compute the volume of water it is able to trap after raining.


Note:
Both m and n are less than 110. The height of each unit cell is greater than 0 and is less than 20,000.


Example:

Given the following 3x6 height map:
[
  [1,4,3,1,3,2],
  [3,2,1,3,2,4],
  [2,3,3,2,3,1]
]

Return 4.





The above image represents the elevation map [[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]] before the rain.




After the rain, water are trapped between the blocks. The total volume of water trapped is 4.










## 408 - Valid Word Abbreviation
~1~  []
Given a non-empty string `s` and an abbreviation `abbr`, return whether the
string matches with the given abbreviation.

A string such as `"word"` contains only the following valid abbreviations:



    ["word", "1ord", "w1rd", "wo1d", "wor1", "2rd", "w2d", "wo2", "1o1d", "1or1", "w1r1", "1o2", "2r1", "3d", "w3", "4"]

Notice that only the above abbreviations are valid abbreviations of the string
`"word"`. Any other string is not a valid abbreviation of `"word"`.

Note:
Assume `s` contains only lowercase letters and `abbr` contains only lowercase
letters and digits.

Example 1:



    Given s = "internationalization", abbr = "i12iz4n":Return true.



Example 2:



    Given s = "apple", abbr = "a2e":Return false.










## 409 - Longest Palindrome
~1~  ['Hash Table']
Given a string which consists of lowercase or uppercase letters, find the length of the longest palindromes that can be built with those letters.

This is case sensitive, for example "Aa" is not considered a palindrome here.

Note:
Assume the length of given string will not exceed 1,010.


Example: 

Input:
"abccccdd"

Output:
7

Explanation:
One longest palindrome that can be built is "dccaccd", whose length is 7.










## 410 - Split Array Largest Sum
~3~  ['Binary Search', 'Dynamic Programming']
Given an array which consists of non-negative integers and an integer m, you can split the array into m non-empty continuous subarrays. Write an algorithm to minimize the largest sum among these m subarrays.


Note:
If n is the length of array, assume the following constraints are satisfied:

1 ≤ n ≤ 1000
1 ≤ m ≤ min(50, n)



Examples: 

Input:
nums = [7,2,5,10,8]
m = 2

Output:
18

Explanation:
There are four ways to split nums into two subarrays.
The best way is to split it into [7,2,5] and [10,8],
where the largest sum among the two subarrays is only 18.










## 411 - Minimum Unique Word Abbreviation
~3~  []
A string such as `"word"` contains the following abbreviations:



    ["word", "1ord", "w1rd", "wo1d", "wor1", "2rd", "w2d", "wo2", "1o1d", "1or1", "w1r1", "1o2", "2r1", "3d", "w3", "4"]

Given a target string and a set of strings in a dictionary, find an
abbreviation of this target string with the_smallest possible_ length such
that it does not conflict with abbreviations of the strings in the dictionary.

Each number or letter in the abbreviation is considered length = 1. For
example, the abbreviation "a32bc" has length = 4.

Note:

  * In the case of multiple answers as shown in the second example below, you may return any one of them.
  * Assume length of target string = m, and dictionary size = n. You may assume that m ≤ 21, n ≤ 1000, and log2(n) + m ≤ 20.



Examples:



    "apple", ["blade"] -> "a4" (because "5" or "4e" conflicts with "blade")"apple", ["plain", "amber", "blade"] -> "1p3" (other valid answers include "ap3", "a3e", "2p2", "3le", "3l1").










## 412 - Fizz Buzz
~1~  []
Write a program that outputs the string representation of numbers from 1 to n.

But for multiples of three it should output “Fizz” instead of the number and for the multiples of five output “Buzz”. For numbers which are multiples of both three and five output “FizzBuzz”.

Example:

n = 15,

Return:
[
    "1",
    "2",
    "Fizz",
    "4",
    "Buzz",
    "Fizz",
    "7",
    "8",
    "Fizz",
    "Buzz",
    "11",
    "Fizz",
    "13",
    "14",
    "FizzBuzz"
]










## 413 - Arithmetic Slices
~2~  ['Math', 'Dynamic Programming']
A sequence of number is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.

For example, these are arithmetic sequence:
1, 3, 5, 7, 9
7, 7, 7, 7
3, -1, -5, -9

The following sequence is not arithmetic. 1, 1, 2, 5, 7 


A zero-indexed array A consisting of N numbers is given. A slice of that array is any pair of integers (P, Q) such that 0 <= P < Q < N.

A slice (P, Q) of array A is called arithmetic if the sequence:
    A[P], A[p + 1], ..., A[Q - 1], A[Q] is arithmetic. In particular, this means that P + 1 < Q.

The function should return the number of arithmetic slices in the array A. 


Example:

A = [1, 2, 3, 4]

return: 3, for 3 arithmetic slices in A: [1, 2, 3], [2, 3, 4] and [1, 2, 3, 4] itself.










## 414 - Third Maximum Number
~1~  ['Array']
Given a non-empty array of integers, return the third maximum number in this array. If it does not exist, return the maximum number. The time complexity must be in O(n).

Example 1:

Input: [3, 2, 1]

Output: 1

Explanation: The third maximum is 1.



Example 2:

Input: [1, 2]

Output: 2

Explanation: The third maximum does not exist, so the maximum (2) is returned instead.



Example 3:

Input: [2, 2, 3, 1]

Output: 1

Explanation: Note that the third maximum here means the third maximum distinct number.
Both numbers with value 2 are both considered as second maximum.










## 415 - Add Strings
~1~  ['Math']
Given two non-negative integers num1 and num2 represented as string, return the sum of num1 and num2.

Note:

The length of both num1 and num2 is < 5100.
Both num1 and num2 contains only digits 0-9.
Both num1 and num2 does not contain any leading zero.
You must not use any built-in BigInteger library or convert the inputs to integer directly.










## 416 - Partition Equal Subset Sum
~2~  ['Dynamic Programming']
Given a non-empty array containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.


Note:

Each of the array element will not exceed 100.
The array size will not exceed 200.



Example 1:

Input: [1, 5, 11, 5]

Output: true

Explanation: The array can be partitioned as [1, 5, 5] and [11].



Example 2:

Input: [1, 2, 3, 5]

Output: false

Explanation: The array cannot be partitioned into equal sum subsets.










## 417 - Pacific Atlantic Water Flow
~2~  ['Depth-first Search', 'Breadth-first Search']
Given an m x n matrix of non-negative integers representing the height of each unit cell in a continent, the "Pacific ocean" touches the left and top edges of the matrix and the "Atlantic ocean" touches the right and bottom edges.

Water can only flow in four directions (up, down, left, or right) from a cell to another one with height equal or lower.

Find the list of grid coordinates where water can flow to both the Pacific and Atlantic ocean.

Note:

The order of returned grid coordinates does not matter.
Both m and n are less than 150.


Example:

Given the following 5x5 matrix:

  Pacific ~   ~   ~   ~   ~ 
       ~  1   2   2   3  (5) *
       ~  3   2   3  (4) (4) *
       ~  2   4  (5)  3   1  *
       ~ (6) (7)  1   4   5  *
       ~ (5)  1   1   2   4  *
          *   *   *   *   * Atlantic

Return:

[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (positions with parentheses in above matrix).










## 418 - Sentence Screen Fitting
~2~  []
Given a `rows x cols` screen and a sentence represented by a list of words,
find how many times the given sentence can be fitted on the screen.

Note:

  1. A word cannot be split into two lines.
  2. The order of words in the sentence must remain unchanged.
  3. Two consecutive words in a line must be separated by a single space.
  4. Total words in the sentence won't exceed 100.
  5. Length of each word won't exceed 10.
  6. 1 ≤ rows, cols ≤ 20,000.



Example 1:



    Input:rows = 2, cols = 8, sentence = ["hello", "world"]Output: 1Explanation:hello---world---The character '-' signifies an empty space on the screen.



Example 2:



    Input:rows = 3, cols = 6, sentence = ["a", "bcd", "e"]Output: 2Explanation:a-bcd- e-a---bcd-e-The character '-' signifies an empty space on the screen.



Example 3:



    Input:rows = 4, cols = 5, sentence = ["I", "had", "apple", "pie"]Output: 1Explanation:I-hadapplepie-Ihad--The character '-' signifies an empty space on the screen.










## 419 - Battleships in a Board
~2~  []
Given an 2D board, count how many battleships are in it. The battleships are represented with 'X's, empty slots are represented with '.'s. You may assume the following rules:


You receive a valid board, made of only battleships or empty slots.
Battleships can only be placed horizontally or vertically. In other words, they can only be made of the shape 1xN (1 row, N columns) or Nx1 (N rows, 1 column), where N can be of any size.
At least one horizontal or vertical cell separates between two battleships - there are no adjacent battleships.


Example:
X..X
...X
...X

In the above board there are 2 battleships.

Invalid Example:
...X
XXXX
...X

This is an invalid board that you will not receive - as battleships will always have a cell separating between them.

Follow up:Could you do it in one-pass, using only O(1) extra memory and without modifying the value of the board?










## 420 - Strong Password Checker
~3~  []
A password is considered strong if below conditions are all met:


 It has at least 6 characters and at most 20 characters. 
 It must contain at least one lowercase letter, at least one uppercase letter, and at least one digit. 
 It must NOT contain three repeating characters in a row ("...aaa..." is weak, but "...aa...a..." is strong, assuming other conditions are met). 


Write a function strongPasswordChecker(s), that takes a string s as input, and return the MINIMUM change required to make s a strong password. If s is already strong, return 0.

Insertion, deletion or replace of any one character are all considered as one change.










## 421 - Maximum XOR of Two Numbers in an Array
~2~  ['Bit Manipulation', 'Trie']
Given a non-empty array of numbers, a0, a1, a2, … , an-1, where 0 ≤ ai < 231.

Find the maximum result of ai XOR aj, where 0 ≤ i, j < n.

Could you do this in O(n) runtime?

Example:

Input: [3, 10, 5, 25, 2, 8]

Output: 28

Explanation: The maximum result is 5 ^ 25 = 28.










## 422 - Valid Word Square
~1~  []
Given a sequence of words, check whether it forms a valid word square.

A sequence of words forms a valid word square if the _k_th row and column read
the exact same string, where 0 ≤_k_ < max(numRows, numColumns).

Note:

  1. The number of words given is at least 1 and does not exceed 500.
  2. Word length will be at least 1 and does not exceed 500.
  3. Each word contains only lowercase English alphabet `a-z`.



Example 1:



    Input:[  "abcd",  "bnrt",  "crmy",  "dtye"]Output:trueExplanation:The first row and first column both read "abcd".The second row and second column both read "bnrt".The third row and third column both read "crmy".The fourth row and fourth column both read "dtye".Therefore, it is a valid word square.



Example 2:



    Input:[  "abcd",  "bnrt",  "crm",  "dt"]Output:trueExplanation:The first row and first column both read "abcd".The second row and second column both read "bnrt".The third row and third column both read "crm".The fourth row and fourth column both read "dt".Therefore, it is a valid word square.



Example 3:



    Input:[  "ball",  "area",  "read",  "lady"]Output:falseExplanation:The third row reads "read" while the third column reads "lead".Therefore, it is NOT a valid word square.










## 423 - Reconstruct Original Digits from English
~2~  ['Math']
Given a non-empty string containing an out-of-order English representation of digits 0-9, output the digits in ascending order.

Note:

Input contains only lowercase English letters.
Input is guaranteed to be valid and can be transformed to its original digits. That means invalid inputs such as "abc" or "zerone" are not permitted.
Input length is less than 50,000.



Example 1:

Input: "owoztneoer"

Output: "012"



Example 2:

Input: "fviefuro"

Output: "45"










## 424 - Longest Repeating Character Replacement
~2~  []
Given a string that consists of only uppercase English letters, you can replace any letter in the string with another letter at most k times. Find the length of a longest substring containing all repeating letters you can get after performing the above operations.

Note:
Both the string's length and k will not exceed 104.



Example 1:

Input:
s = "ABAB", k = 2

Output:
4

Explanation:
Replace the two 'A's with two 'B's or vice versa.




Example 2:

Input:
s = "AABABBA", k = 1

Output:
4

Explanation:
Replace the one 'A' in the middle with 'B' and form "AABBBBA".
The substring "BBBB" has the longest repeating letters, which is 4.










## 425 - Word Squares
~3~  []
Given a set of words (without duplicates), find all [word
squares](https://en.wikipedia.org/wiki/Word_square) you can build from them.

A sequence of words forms a valid word square if the  _k_ th row and column
read the exact same string, where 0 ≤  _k_  < max(numRows, numColumns).

For example, the word sequence `["ball","area","lead","lady"]` forms a word
square because each word reads the same both horizontally and vertically.



    b a l la r e al e a dl a d y

Note:

  1. There are at least 1 and at most 1000 words.
  2. All words will have the exact same length.
  3. Word length is at least 1 and at most 5.
  4. Each word contains only lowercase English alphabet `a-z`.



Example 1:



    Input:["area","lead","wall","lady","ball"]Output:[  [ "wall",    "area",    "lead",    "lady"  ],  [ "ball",    "area",    "lead",    "lady"  ]]Explanation:The output consists of two word squares. The order of output does not matter (just the order of words in each word square matters).



Example 2:



    Input:["abat","baba","atan","atal"]Output:[  [ "baba",    "abat",    "baba",    "atan"  ],  [ "baba",    "abat",    "baba",    "atal"  ]]Explanation:The output consists of two word squares. The order of output does not matter (just the order of words in each word square matters).










## 432 - All O`one Data Structure
~3~  ['Design']
Implement a data structure supporting the following operations:



Inc(Key) - Inserts a new key  with value 1. Or increments an existing key by 1. Key is guaranteed to be a non-empty string.
Dec(Key) - If Key's value is 1, remove it from the data structure. Otherwise decrements an existing key by 1. If the key does not exist, this function does nothing. Key is guaranteed to be a non-empty string.
GetMaxKey() - Returns one of the keys with maximal value. If no element exists, return an empty string "".
GetMinKey() - Returns one of the keys with minimal value. If no element exists, return an empty string "".




Challenge: Perform all these in O(1) time complexity.










## 433 - Minimum Genetic Mutation
~2~  []
A gene string can be represented by an 8-character long string, with choices from "A", "C", "G", "T".

Suppose we need to investigate about a mutation (mutation from "start" to "end"), where ONE mutation is defined as ONE single character changed in the gene string.

For example, "AACCGGTT" -> "AACCGGTA" is 1 mutation.

Also, there is a given gene "bank", which records all the valid gene mutations. A gene must be in the bank to make it a valid gene string.

Now, given 3 things - start, end, bank, your task is to determine what is the minimum number of mutations needed to mutate from "start" to "end". If there is no such a mutation, return -1.

Note:

Starting point is assumed to be valid, so it might not be included in the bank.
If multiple mutations are needed, all mutations during in the sequence must be valid.
You may assume start and end string is not the same.



Example 1:

start: "AACCGGTT"
end:   "AACCGGTA"
bank: ["AACCGGTA"]

return: 1



Example 2:

start: "AACCGGTT"
end:   "AAACGGTA"
bank: ["AACCGGTA", "AACCGCTA", "AAACGGTA"]

return: 2



Example 3:

start: "AAAAACCC"
end:   "AACCCCCC"
bank: ["AAAACCCC", "AAACCCCC", "AACCCCCC"]

return: 3










## 434 - Number of Segments in a String
~1~  ['String']
Count the number of segments in a string, where a segment is defined to be a contiguous sequence of non-space characters.

Please note that the string does not contain any non-printable characters.

Example:

Input: "Hello, my name is John"
Output: 5










## 435 - Non-overlapping Intervals
~2~  ['Greedy']
Given a collection of intervals, find the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.


Note:

You may assume the interval's end point is always bigger than its start point.
Intervals like [1,2] and [2,3] have borders "touching" but they don't overlap each other.



Example 1:

Input: [ [1,2], [2,3], [3,4], [1,3] ]

Output: 1

Explanation: [1,3] can be removed and the rest of intervals are non-overlapping.



Example 2:

Input: [ [1,2], [1,2], [1,2] ]

Output: 2

Explanation: You need to remove two [1,2] to make the rest of intervals non-overlapping.



Example 3:

Input: [ [1,2], [2,3] ]

Output: 0

Explanation: You don't need to remove any of the intervals since they're already non-overlapping.










## 436 - Find Right Interval
~2~  ['Binary Search']
Given a set of intervals, for each of the interval i, check if there exists an interval j whose start point is bigger than or equal to the end point of the interval i, which can be called that j is on the "right" of i.



For any interval i, you need to store the minimum interval j's index, which means that the interval j has the minimum start point to build the "right" relationship for interval i. If the interval j doesn't exist, store -1 for the interval i. Finally, you need output the stored value of each interval as an array.


Note:

You may assume the interval's end point is always bigger than its start point.
You may assume none of these intervals have the same start point.



Example 1:

Input: [ [1,2] ]

Output: [-1]

Explanation: There is only one interval in the collection, so it outputs -1.



Example 2:

Input: [ [3,4], [2,3], [1,2] ]

Output: [-1, 0, 1]

Explanation: There is no satisfied "right" interval for [3,4].
For [2,3], the interval [3,4] has minimum-"right" start point;
For [1,2], the interval [2,3] has minimum-"right" start point.



Example 3:

Input: [ [1,4], [2,3], [3,4] ]

Output: [-1, 2, -1]

Explanation: There is no satisfied "right" interval for [1,4] and [3,4].
For [2,3], the interval [3,4] has minimum-"right" start point.










## 437 - Path Sum III
~1~  ['Tree']
You are given a binary tree in which each node contains an integer value.

Find the number of paths that sum to a given value.

The path does not need to start or end at the root or a leaf, but it must go downwards
(traveling only from parent nodes to child nodes).

The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000.

Example:

root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8

      10
     /  \
    5   -3
   / \    \
  3   2   11
 / \   \
3  -2   1

Return 3. The paths that sum to 8 are:

1.  5 -> 3
2.  5 -> 2 -> 1
3. -3 -> 11










## 438 - Find All Anagrams in a String
~1~  ['Hash Table']
Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.

Strings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100.

The order of output does not matter.

Example 1:

Input:
s: "cbaebabacd" p: "abc"

Output:
[0, 6]

Explanation:
The substring with start index = 0 is "cba", which is an anagram of "abc".
The substring with start index = 6 is "bac", which is an anagram of "abc".



Example 2:

Input:
s: "abab" p: "ab"

Output:
[0, 1, 2]

Explanation:
The substring with start index = 0 is "ab", which is an anagram of "ab".
The substring with start index = 1 is "ba", which is an anagram of "ab".
The substring with start index = 2 is "ab", which is an anagram of "ab".










## 439 - Ternary Expression Parser
~2~  []
Given a string representing arbitrarily nested ternary expressions, calculate
the result of the expression. You can always assume that the given expression
is valid and only consists of digits `0-9`, `?`, `:`, `T` and `F` (`T` and
`F`represent True and False respectively).

Note:

  1. The length of the given string is ≤ 10000.
  2. Each number will contain only one digit.
  3. The conditional expressions group right-to-left (as usual in most languages).
  4. The condition will always be either `T` or `F`. That is, the condition will never be a digit.
  5. The result of the expression will always evaluate to either a digit `0-9`, `T` or `F`.



Example 1:



    Input: "T?2:3"Output: "2"Explanation: If true, then result is 2; otherwise result is 3.



Example 2:



    Input: "F?1:T?4:5"Output: "4"Explanation: The conditional expressions group right-to-left. Using parenthesis, it is read/evaluated as:             "(F ? 1 : (T ? 4 : 5))"                   "(F ? 1 : (T ? 4 : 5))"          -> "(F ? 1 : 4)"                 or       -> "(T ? 4 : 5)"          -> "4"                                    -> "4"



Example 3:



    Input: "T?T?F:5:3"Output: "F"Explanation: The conditional expressions group right-to-left. Using parenthesis, it is read/evaluated as:             "(T ? (T ? F : 5) : 3)"                   "(T ? (T ? F : 5) : 3)"          -> "(T ? F : 3)"                 or       -> "(T ? F : 5)"          -> "F"                                    -> "F"










## 440 - K-th Smallest in Lexicographical Order
~3~  []
Given integers n and k, find the lexicographically k-th smallest integer in the range from 1 to n.

Note: 1 ≤ k ≤ n ≤ 109.

Example:

Input:
n: 13   k: 2

Output:
10

Explanation:
The lexicographical order is [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9], so the second smallest number is 10.










## 441 - Arranging Coins
~1~  ['Math', 'Binary Search']
You have a total of n coins that you want to form in a staircase shape, where every k-th row must have exactly k coins.
 
Given n, find the total number of full staircase rows that can be formed.

n is a non-negative integer and fits within the range of a 32-bit signed integer.

Example 1:

n = 5

The coins can form the following rows:
¤
¤ ¤
¤ ¤

Because the 3rd row is incomplete, we return 2.



Example 2:

n = 8

The coins can form the following rows:
¤
¤ ¤
¤ ¤ ¤
¤ ¤

Because the 4th row is incomplete, we return 3.










## 442 - Find All Duplicates in an Array
~2~  ['Array']
Given an array of integers, 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once.

Find all the elements that appear twice in this array.

Could you do it without extra space and in O(n) runtime?

Example:

Input:
[4,3,2,7,8,2,3,1]

Output:
[2,3]










## 443 - String Compression
~1~  ['String']
Given an array of characters, compress it in-place.

The length after compression must always be smaller than or equal to the original array.

Every element of the array should be a character (not int) of length 1.
 
After you are done modifying the input array in-place, return the new length of the array.



Follow up:
Could you solve it using only O(1) extra space?




Example 1:

Input:
["a","a","b","b","c","c","c"]

Output:
Return 6, and the first 6 characters of the input array should be: ["a","2","b","2","c","3"]

Explanation:
"aa" is replaced by "a2". "bb" is replaced by "b2". "ccc" is replaced by "c3".



Example 2:

Input:
["a"]

Output:
Return 1, and the first 1 characters of the input array should be: ["a"]

Explanation:
Nothing is replaced.



Example 3:

Input:
["a","b","b","b","b","b","b","b","b","b","b","b","b"]

Output:
Return 4, and the first 4 characters of the input array should be: ["a","b","1","2"].

Explanation:
Since the character "a" does not repeat, it is not compressed. "bbbbbbbbbbbb" is replaced by "b12".
Notice each digit has it's own entry in the array.



Note:

All characters have an ASCII value in [35, 126].
1 <= len(chars) <= 1000.










## 444 - Sequence Reconstruction
~2~  []
Check whether the original sequence `org` can be uniquely reconstructed from
the sequences in `seqs`. The `org` sequence is a permutation of the integers
from 1 to n, with 1 ≤ n ≤ 104. Reconstruction means building a shortest common
supersequence of the sequences in `seqs` (i.e., a shortest sequence so that
all sequences in `seqs` are subsequences of it). Determine whether there is
only one sequence that can be reconstructed from `seqs` and it is the `org`
sequence.

**Example 1:**


    **Input:**org: [1,2,3], seqs: [[1,2],[1,3]]**Output:**false**Explanation:**[1,2,3] is not the only one sequence that can be reconstructed, because [1,3,2] is also a valid sequence that can be reconstructed.

**Example 2:**


    **Input:**org: [1,2,3], seqs: [[1,2]]**Output:**false**Explanation:**The reconstructed sequence can only be [1,2].

**Example 3:**


    **Input:**org: [1,2,3], seqs: [[1,2],[1,3],[2,3]]**Output:**true**Explanation:**The sequences [1,2], [1,3], and [2,3] can uniquely reconstruct the original sequence [1,2,3].

**Example 4:**


    **Input:**org: [4,1,5,2,6,3], seqs: [[5,2,6,3],[4,1,5,2]]**Output:**true










## 445 - Add Two Numbers II
~2~  ['Linked List']
You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.

You may assume the two numbers do not contain any leading zero, except the number 0 itself.

Follow up:
What if you cannot modify the input lists? In other words, reversing the lists is not allowed.



Example:

Input: (7 -> 2 -> 4 -> 3) + (5 -> 6 -> 4)
Output: 7 -> 8 -> 0 -> 7










## 446 - Arithmetic Slices II - Subsequence
~3~  ['Dynamic Programming']
A sequence of numbers is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.

For example, these are arithmetic sequences:
1, 3, 5, 7, 9
7, 7, 7, 7
3, -1, -5, -9

The following sequence is not arithmetic. 1, 1, 2, 5, 7 


A zero-indexed array A consisting of N numbers is given. A subsequence slice of that array is any sequence of integers (P0, P1, ..., Pk) such that 0 ≤ P0 < P1 < ... < Pk < N.

A subsequence slice (P0, P1, ..., Pk) of array A is called arithmetic if the sequence A[P0], A[P1], ..., A[Pk-1], A[Pk] is arithmetic. In particular, this means that k ≥ 2.

The function should return the number of arithmetic subsequence slices in the array A. 

The input contains N integers. Every integer is in the range of -231 and 231-1 and 0 ≤ N ≤ 1000. The output is guaranteed to be less than 231-1.


Example:

Input: [2, 4, 6, 8, 10]

Output: 7

Explanation:
All arithmetic subsequence slices are:
[2,4,6]
[4,6,8]
[6,8,10]
[2,4,6,8]
[4,6,8,10]
[2,4,6,8,10]
[2,6,10]










## 447 - Number of Boomerangs
~1~  ['Hash Table']
Given n points in the plane that are all pairwise distinct, a "boomerang" is a tuple of points (i, j, k) such that the distance between i and j equals the distance between i and k (the order of the tuple matters).

Find the number of boomerangs. You may assume that n will be at most 500 and coordinates of points are all in the range [-10000, 10000] (inclusive).

Example:

Input:
[[0,0],[1,0],[2,0]]

Output:
2

Explanation:
The two boomerangs are [[1,0],[0,0],[2,0]] and [[1,0],[2,0],[0,0]]










## 448 - Find All Numbers Disappeared in an Array
~1~  ['Array']
Given an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once.

Find all the elements of [1, n] inclusive that do not appear in this array.

Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space.

Example:

Input:
[4,3,2,7,8,2,3,1]

Output:
[5,6]










## 449 - Serialize and Deserialize BST
~2~  ['Tree']
Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment. 

Design an algorithm to serialize and deserialize a binary search tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary search tree can be serialized to a string and this string can be deserialized to the original tree structure.


The encoded string should be as compact as possible.



Note: Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.










## 450 - Delete Node in a BST
~2~  ['Tree']
Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST.

Basically, the deletion can be divided into two stages:

Search for a node to remove.
If the node is found, delete the node.



Note: Time complexity should be O(height of tree).

Example:

root = [5,3,6,2,4,null,7]
key = 3

    5
   / \
  3   6
 / \   \
2   4   7

Given key to delete is 3. So we find the node with value 3 and delete it.

One valid answer is [5,4,6,2,null,null,7], shown in the following BST.

    5
   / \
  4   6
 /     \
2       7

Another valid answer is [5,2,6,null,4,null,7].

    5
   / \
  2   6
   \   \
    4   7










## 451 - Sort Characters By Frequency
~2~  ['Hash Table', 'Heap']
Given a string, sort it in decreasing order based on the frequency of characters.

Example 1:

Input:
"tree"

Output:
"eert"

Explanation:
'e' appears twice while 'r' and 't' both appear once.
So 'e' must appear before both 'r' and 't'. Therefore "eetr" is also a valid answer.



Example 2:

Input:
"cccaaa"

Output:
"cccaaa"

Explanation:
Both 'c' and 'a' appear three times, so "aaaccc" is also a valid answer.
Note that "cacaca" is incorrect, as the same characters must be together.



Example 3:

Input:
"Aabb"

Output:
"bbAa"

Explanation:
"bbaA" is also a valid answer, but "Aabb" is incorrect.
Note that 'A' and 'a' are treated as two different characters.










## 452 - Minimum Number of Arrows to Burst Balloons
~2~  ['Greedy']
There are a number of spherical balloons spread in two-dimensional space. For each balloon, provided input is the start and end coordinates of the horizontal diameter. Since it's horizontal, y-coordinates don't matter and hence the x-coordinates of start and end of the diameter suffice. Start is always smaller than end. There will be at most 104 balloons.

An arrow can be shot up exactly vertically from different points along the x-axis. A balloon with xstart and xend bursts by an arrow shot at x if xstart ≤ x ≤ xend. There is no limit to the number of arrows that can be shot. An arrow once shot keeps travelling up infinitely. The problem is to find the minimum number of arrows that must be shot to burst all balloons. 

Example:

Input:
[[10,16], [2,8], [1,6], [7,12]]

Output:
2

Explanation:
One way is to shoot one arrow for example at x = 6 (bursting the balloons [2,8] and [1,6]) and another arrow at x = 11 (bursting the other two balloons).










## 453 - Minimum Moves to Equal Array Elements
~1~  ['Math']
Given a non-empty integer array of size n, find the minimum number of moves required to make all array elements equal, where a move is incrementing n - 1 elements by 1.

Example:

Input:
[1,2,3]

Output:
3

Explanation:
Only three moves are needed (remember each move increments two elements):

[1,2,3]  =>  [2,3,3]  =>  [3,4,3]  =>  [4,4,4]










## 454 - 4Sum II
~2~  ['Hash Table', 'Binary Search']
Given four lists A, B, C, D of integer values, compute how many tuples (i, j, k, l) there are such that A[i] + B[j] + C[k] + D[l] is zero.

To make problem a bit easier, all A, B, C, D have same length of N where 0 ≤ N ≤ 500. All integers are in the range of -228 to 228 - 1 and the result is guaranteed to be at most 231 - 1.

Example:

Input:
A = [ 1, 2]
B = [-2,-1]
C = [-1, 2]
D = [ 0, 2]

Output:
2

Explanation:
The two tuples are:
1. (0, 0, 0, 1) -> A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0
2. (1, 1, 0, 0) -> A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0










## 455 - Assign Cookies
~1~  ['Greedy']
Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie. Each child i has a greed factor gi, which is the minimum size of a cookie that the child will be content with; and each cookie j has a size sj. If sj >= gi, we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number.


Note:
You may assume the greed factor is always positive. 
You cannot assign more than one cookie to one child.


Example 1:

Input: [1,2,3], [1,1]

Output: 1

Explanation: You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3. 
And even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content.
You need to output 1.



Example 2:

Input: [1,2], [1,2,3]

Output: 2

Explanation: You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2. 
You have 3 cookies and their sizes are big enough to gratify all of the children, 
You need to output 2.










## 456 - 132 Pattern
~2~  ['Stack']
Given a sequence of n integers a1, a2, ..., an, a 132 pattern is a subsequence ai, aj, ak such
that i < j < k and ai < ak < aj. Design an algorithm that takes a list of n numbers as input and checks whether there is a 132 pattern in the list.

Note: n will be less than 15,000.

Example 1:

Input: [1, 2, 3, 4]

Output: False

Explanation: There is no 132 pattern in the sequence.



Example 2:

Input: [3, 1, 4, 2]

Output: True

Explanation: There is a 132 pattern in the sequence: [1, 4, 2].



Example 3:

Input: [-1, 3, 2, 0]

Output: True

Explanation: There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0].










## 457 - Circular Array Loop
~2~  []
You are given an array of positive and negative integers. If a number n at an index is positive, then move forward n steps. Conversely, if it's negative (-n), move backward n steps. Assume the first element of the array is forward next to the last element, and the last element is backward next to the first element. Determine if there is a loop in this array. A loop starts and ends at a particular index with more than 1 element along the loop. The loop must be "forward" or "backward'.


Example 1:

Given the array [2, -1, 1, 2, 2], there is a loop, from index 0 -> 2 -> 3 -> 0.


Example 2:

Given the array [-1, 2], there is no loop.


Note:

The given array is guaranteed to contain no element "0".



Can you do it in O(n) time complexity and O(1) space complexity?










## 458 - Poor Pigs
~1~  []
There are 1000 buckets, one and only one of them contains poison, the rest are filled with water. They all look the same. If a pig drinks that poison it will die within 15 minutes. What is the minimum amount of pigs you need to figure out which bucket contains the poison within one hour. 


Answer this question, and write an algorithm for the follow-up general case.



Follow-up:



If there are n buckets and a pig drinking poison will die within m minutes, how many pigs (x) you need to figure out the "poison" bucket within p minutes? There is exact one bucket with poison.










## 459 - Repeated Substring Pattern
~1~  ['String']
Given a non-empty string check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.  You may assume the given string consists of lowercase English letters only and its length  will not exceed 10000. 

Example 1:

Input: "abab"

Output: True

Explanation: It's the substring "ab" twice.



Example 2:

Input: "aba"

Output: False



Example 3:

Input: "abcabcabcabc"

Output: True

Explanation: It's the substring "abc" four times. (And the substring "abcabc" twice.)










## 460 - LFU Cache
~3~  ['Design']
Design and implement a data structure for Least Frequently Used (LFU) cache. It should support the following operations: get and put.



get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.
put(key, value) - Set or insert the value if the key is not already present. When the cache reaches its capacity, it should invalidate the least frequently used item before inserting a new item. For the purpose of this problem, when there is a tie (i.e., two or more keys that have the same frequency), the least recently used key would be evicted.


Follow up:
Could you do both operations in O(1) time complexity?

Example:

LFUCache cache = new LFUCache( 2 /* capacity */ );

cache.put(1, 1);
cache.put(2, 2);
cache.get(1);       // returns 1
cache.put(3, 3);    // evicts key 2
cache.get(2);       // returns -1 (not found)
cache.get(3);       // returns 3.
cache.put(4, 4);    // evicts key 1.
cache.get(1);       // returns -1 (not found)
cache.get(3);       // returns 3
cache.get(4);       // returns 4










## 461 - Hamming Distance
~1~  ['Bit Manipulation']
The Hamming distance between two integers is the number of positions at which the corresponding bits are different.

Given two integers x and y, calculate the Hamming distance.

Note:
0 ≤ x, y < 231.


Example:

Input: x = 1, y = 4

Output: 2

Explanation:
1   (0 0 0 1)
4   (0 1 0 0)
       ↑   ↑

The above arrows point to positions where the corresponding bits are different.










## 462 - Minimum Moves to Equal Array Elements II
~2~  ['Math']
Given a non-empty integer array, find the minimum number of moves required to make all array elements equal, where a move is incrementing a selected element by 1 or decrementing a selected element by 1.

You may assume the array's length is at most 10,000.

Example:

Input:
[1,2,3]

Output:
2

Explanation:
Only two moves are needed (remember each move increments or decrements one element):

[1,2,3]  =>  [2,2,3]  =>  [2,2,2]










## 463 - Island Perimeter
~1~  ['Hash Table']
You are given a map in form of a two-dimensional integer grid where 1 represents land and 0 represents water. Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells). The island doesn't have "lakes" (water inside that isn't connected to the water around the island). One cell is a square with side length 1. The grid is rectangular, width and height don't exceed 100. Determine the perimeter of the island.

Example:

[[0,1,0,0],
 [1,1,1,0],
 [0,1,0,0],
 [1,1,0,0]]

Answer: 16
Explanation: The perimeter is the 16 yellow stripes in the image below:










## 464 - Can I Win
~2~  ['Dynamic Programming', 'Minimax']
In the "100 game," two players take turns adding, to a running total, any integer from 1..10. The player who first causes the running total to reach or exceed 100 wins. 

What if we change the game so that players cannot re-use integers? 

For example, two players might take turns drawing from a common pool of numbers of 1..15 without replacement until they reach a total >= 100.

Given an integer maxChoosableInteger and another integer desiredTotal, determine if the first player to move can force a win, assuming both players play optimally. 

You can always assume that maxChoosableInteger will not be larger than 20 and desiredTotal will not be larger than 300.


Example

Input:
maxChoosableInteger = 10
desiredTotal = 11

Output:
false

Explanation:
No matter which integer the first player choose, the first player will lose.
The first player can choose an integer from 1 up to 10.
If the first player choose 1, the second player can only choose integers from 2 up to 10.
The second player will win by choosing 10 and get a total = 11, which is >= desiredTotal.
Same with other integers chosen by the first player, the second player will always win.










## 465 - Optimal Account Balancing
~3~  []
A group of friends went on holiday and sometimes lent each other money. For
example, Alice paid for Bill's lunch for $10. Then later Chris gave Alice $5
for a taxi ride. We can model each transaction as a tuple (x, y, z) which
means person x gave person y $z. Assuming Alice, Bill, and Chris are person 0,
1, and 2 respectively (0, 1, 2 are the person's ID), the transactions can be
represented as `[[0, 1, 10], [2, 0, 5]]`.

Given a list of transactions between a group of people, return the minimum
number of transactions required to settle the debt.

Note:

  1. A transaction will be given as a tuple (x, y, z). Note that `x ≠ y` and `z > 0`.
  2. Person's IDs may not be linear, e.g. we could have the persons 0, 1, 2 or we could also have the persons 0, 2, 6.



Example 1:



    Input:[[0,1,10], [2,0,5]]Output:2Explanation:Person #0 gave person #1 $10.Person #2 gave person #0 $5.Two transactions are needed. One way to settle the debt is person #1 pays person #0 and #2 $5 each.



Example 2:



    Input:[[0,1,10], [1,0,1], [1,2,5], [2,0,5]]Output:1Explanation:Person #0 gave person #1 $10.Person #1 gave person #0 $1.Person #1 gave person #2 $5.Person #2 gave person #0 $5.Therefore, person #1 only need to give person #0 $4, and all debt is settled.










## 466 - Count The Repetitions
~3~  ['Dynamic Programming']
Define S = [s,n] as the string S which consists of n connected strings s. For example, ["abc", 3] ="abcabcabc". 
On the other hand, we define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1. For example, “abc”  can be obtained from “abdbec” based on our definition, but it can not be obtained from “acbbe”.
You are given two non-empty strings s1 and s2 (each at most 100 characters long) and two integers 0 ≤ n1 ≤ 106 and 1 ≤ n2 ≤ 106. Now consider the strings S1 and S2, where S1=[s1,n1] and S2=[s2,n2]. Find the maximum integer M such that [S2,M] can be obtained from S1.

Example:

Input:
s1="acb", n1=4
s2="ab", n2=2

Return:
2










## 467 - Unique Substrings in Wraparound String
~2~  ['Dynamic Programming']
Consider the string s to be the infinite wraparound string of "abcdefghijklmnopqrstuvwxyz", so s will look like this: "...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd....".

Now we have another string p. Your job is to find out how many unique non-empty substrings of p are present in s. In particular, your input is the string p and you need to output the number of different non-empty substrings of p in the string s.

Note: p consists of only lowercase English letters and the size of p might be over 10000.

Example 1:

Input: "a"
Output: 1

Explanation: Only the substring "a" of string "a" is in the string s.



Example 2:

Input: "cac"
Output: 2
Explanation: There are two substrings "a", "c" of string "cac" in the string s.



Example 3:

Input: "zab"
Output: 6
Explanation: There are six substrings "z", "a", "b", "za", "ab", "zab" of string "zab" in the string s.










## 468 - Validate IP Address
~2~  ['String']
Write a function to check whether an input string is a valid IPv4 address or IPv6 address or neither.



IPv4 addresses are canonically represented in dot-decimal notation, which consists of four decimal numbers, each ranging from 0 to 255, separated by dots ("."), e.g.,172.16.254.1;



Besides, leading zeros in the IPv4 is invalid. For example, the address 172.16.254.01 is invalid.



IPv6 addresses are represented as eight groups of four hexadecimal digits, each group representing 16 bits. The groups are separated by colons (":"). For example, the address 2001:0db8:85a3:0000:0000:8a2e:0370:7334 is a valid one. Also, we could omit some leading zeros among four hexadecimal digits and some low-case characters in the address to upper-case ones, so 2001:db8:85a3:0:0:8A2E:0370:7334 is also a valid IPv6 address(Omit leading zeros and using upper cases).




However, we don't replace a consecutive group of zero value with a single empty group using two consecutive colons (::) to pursue simplicity. For example, 2001:0db8:85a3::8A2E:0370:7334 is an invalid IPv6 address.



Besides, extra leading zeros in the IPv6 is also invalid. For example, the address 02001:0db8:85a3:0000:0000:8a2e:0370:7334 is invalid.



Note:
You may assume there is no extra space or special characters in the input string.


Example 1:

Input: "172.16.254.1"

Output: "IPv4"

Explanation: This is a valid IPv4 address, return "IPv4".




Example 2:

Input: "2001:0db8:85a3:0:0:8A2E:0370:7334"

Output: "IPv6"

Explanation: This is a valid IPv6 address, return "IPv6".



Example 3:

Input: "256.256.256.256"

Output: "Neither"

Explanation: This is neither a IPv4 address nor a IPv6 address.










## 469 - Convex Polygon
~2~  []
Given a list of points that form a polygon when joined sequentially, find if
this polygon is convex [(Convex polygon
definition)](https://en.wikipedia.org/wiki/Convex_polygon).

**Note:**

  1. There are at least 3 and at most 10,000 points.
  2. Coordinates are in the range -10,000 to 10,000.
  3. You may assume the polygon formed by given points is always a simple polygon[ (Simple polygon definition)](https://en.wikipedia.org/wiki/Simple_polygon). In other words, we ensure that exactly two edges intersect at each vertex, and that edges otherwise **don't intersect each other**.

**Example 1:**


    [[0,0],[0,1],[1,1],[1,0]]Answer: TrueExplanation:

![](https://leetcode.com/static/images/problemset/polygon_convex.png)

**Example 2:**


    [[0,0],[0,10],[10,10],[10,0],[5,5]]Answer: FalseExplanation:

![](https://leetcode.com/static/images/problemset/polygon_not_convex.png)










## 471 - Encode String with Shortest Length
~3~  []
Given a **non-empty** string, encode the string such that its encoded length
is the shortest.

The encoding rule is: `k[encoded_string]`, where the _encoded_string_ inside
the square brackets is being repeated exactly _k_ times.

**Note:**
  1. _k_ will be a positive integer and encoded string will not be empty or have extra space.
  2. You may assume that the input string contains only lowercase English letters. The string's length is at most 160.
  3. If an encoding process does not make the string shorter, then do not encode it. If there are several solutions, return any of them is fine.

**Example 1:**


    Input: "aaa"Output: "aaa"Explanation: There is no way to encode it such that it is shorter than the input string, so we do not encode it.

**Example 2:**


    Input: "aaaaa"Output: "5[a]"Explanation: "5[a]" is shorter than "aaaaa" by 1 character.

**Example 3:**


    Input: "aaaaaaaaaa"Output: "10[a]"Explanation: "a9[a]" or "9[a]a" are also valid solutions, both of them have the same length = 5, which is the same as "10[a]".

**Example 4:**


    Input: "aabcaabcd"Output: "2[aabc]d"Explanation: "aabc" occurs twice, so one answer can be "2[aabc]d".

**Example 5:**


    Input: "abbbabbbcabbbabbbc"Output: "2[2[abbb]c]"Explanation: "abbbabbbc" occurs twice, but "abbbabbbc" can also be encoded to "2[abbb]c", so one answer can be "2[2[abbb]c]".










## 472 - Concatenated Words
~3~  ['Dynamic Programming', 'Depth-first Search', 'Trie']
Given a list of words (without duplicates), please write a program that returns all concatenated words in the given list of words.
A concatenated word is defined as a string that is comprised entirely of at least two shorter words in the given array.

Example:

Input: ["cat","cats","catsdogcats","dog","dogcatsdog","hippopotamuses","rat","ratcatdogcat"]

Output: ["catsdogcats","dogcatsdog","ratcatdogcat"]

Explanation: "catsdogcats" can be concatenated by "cats", "dog" and "cats";  "dogcatsdog" can be concatenated by "dog", "cats" and "dog"; "ratcatdogcat" can be concatenated by "rat", "cat", "dog" and "cat".



Note:

The number of elements of the given array will not exceed 10,000 
The length sum of elements in the given array will not exceed 600,000. 
All the input string will only include lower case letters.
The returned elements order does not matter.










## 473 - Matchsticks to Square
~2~  ['Depth-first Search']
Remember the story of Little Match Girl? By now, you know exactly what matchsticks the little match girl has, please find out a way you can make one square by using up all those matchsticks. You should not break any stick, but you can link them up, and each matchstick must be used exactly one time.

 Your input will be several matchsticks the girl has, represented with their stick length. Your output will either be true or false, to represent whether you could make one square using all the matchsticks the little match girl has.

Example 1:

Input: [1,1,2,2,2]
Output: true

Explanation: You can form a square with length 2, one side of the square came two sticks with length 1.



Example 2:

Input: [3,3,3,3,4]
Output: false

Explanation: You cannot find a way to form a square with all the matchsticks.



Note:

The length sum of the given matchsticks is in the range of 0 to 10^9.
The length of the given matchstick array will not exceed 15.










## 474 - Ones and Zeroes
~2~  ['Dynamic Programming']
In the computer world, use restricted resource you have to generate maximum benefit is what we always want to pursue.
For now, suppose you are a dominator of m 0s and n 1s respectively. On the other hand, there is an array with strings consisting of only 0s and 1s.


Now your task is to find the maximum number of strings that you can form with given m 0s and n 1s. Each 0 and 1 can be used at most once.



Note:

The given numbers of 0s and 1s will both not exceed 100
The size of given string array won't exceed 600.



Example 1:

Input: Array = {"10", "0001", "111001", "1", "0"}, m = 5, n = 3
Output: 4

Explanation: This are totally 4 strings can be formed by the using of 5 0s and 3 1s, which are “10,”0001”,”1”,”0”



Example 2:

Input: Array = {"10", "0", "1"}, m = 1, n = 1
Output: 2

Explanation: You could form "10", but then you'd have nothing left. Better form "0" and "1".










## 475 - Heaters
~1~  ['Binary Search']
Winter is coming! Your first job during the contest is to design a standard heater with fixed warm radius to warm all the houses.

Now, you are given positions of houses and heaters on a horizontal line, find out minimum radius of heaters so that all houses could be covered by those heaters.

So, your input will be the positions of houses and heaters seperately, and your expected output will be the minimum radius standard of heaters.

Note:

Numbers of houses and heaters you are given are non-negative and will not exceed 25000.
Positions of houses and heaters you are given are non-negative and will not exceed 10^9.
As long as a house is in the heaters' warm radius range, it can be warmed.
All the heaters follow your radius standard and the warm radius will the same.



Example 1:

Input: [1,2,3],[2]
Output: 1
Explanation: The only heater was placed in the position 2, and if we use the radius 1 standard, then all the houses can be warmed.



Example 2:

Input: [1,2,3,4],[1,4]
Output: 1
Explanation: The two heater was placed in the position 1 and 4. We need to use radius 1 standard, then all the houses can be warmed.










## 476 - Number Complement
~1~  ['Bit Manipulation']
Given a positive integer, output its complement number. The complement strategy is to flip the bits of its binary representation.

Note:

The given integer is guaranteed to fit within the range of a 32-bit signed integer.
You could assume no leading zero bit in the integer’s binary representation.



Example 1:

Input: 5
Output: 2
Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.



Example 2:

Input: 1
Output: 0
Explanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0.










## 477 - Total Hamming Distance
~2~  ['Bit Manipulation']
The Hamming distance between two integers is the number of positions at which the corresponding bits are different.

Now your job is to find the total Hamming distance between all pairs of the given numbers.


Example:

Input: 4, 14, 2

Output: 6

Explanation: In binary representation, the 4 is 0100, 14 is 1110, and 2 is 0010 (just
showing the four bits relevant in this case). So the answer will be:
HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6.



Note:

Elements of the given array are in the range of 0  to 10^9
Length of the array will not exceed 10^4.










## 479 - Largest Palindrome Product
~1~  []
Find the largest palindrome made from the product of two n-digit numbers.
 Since the result could be very large, you should return the largest palindrome mod 1337.

Example:
Input: 2
Output: 987
Explanation: 99 x 91 = 9009, 9009 % 1337 = 987




Note:
The range of n is [1,8].










## 480 - Sliding Window Median
~3~  []
Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value.
Examples: 
[2,3,4] , the median is 3
[2,3], the median is (2 + 3) / 2 = 2.5 

Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Your job is to output the median array for each window in the original array.

For example,
Given nums = [1,3,-1,-3,5,3,6,7], and k = 3.


Window position                Median
---------------               -----
[1  3  -1] -3  5  3  6  7       1
 1 [3  -1  -3] 5  3  6  7       -1
 1  3 [-1  -3  5] 3  6  7       -1
 1  3  -1 [-3  5  3] 6  7       3
 1  3  -1  -3 [5  3  6] 7       5
 1  3  -1  -3  5 [3  6  7]      6


Therefore, return the median sliding window as [1,-1,-1,3,5,6].

Note: 
You may assume k is always valid, ie: k is always smaller than input array's size for non-empty array.










## 481 - Magical String
~2~  []
A magical string S consists of only '1' and '2' and obeys the following rules:


The string S is magical because concatenating the number of contiguous occurrences of characters '1' and '2' generates the string S itself.



The first few elements of string S is the following:
S = "1221121221221121122……"



If we group the consecutive '1's and '2's in S, it will be:


1   22  11  2  1  22  1  22  11  2  11  22 ......


and the occurrences of '1's or '2's in each group are:


1   2	   2    1   1    2     1    2     2    1    2    2 ......



You can see that the occurrence sequence above is the S itself. 



Given an integer N as input, return the number of '1's in the first N number in the magical string S.


Note:
N will not exceed 100,000.



Example 1:

Input: 6
Output: 3
Explanation: The first 6 elements of magical string S is "12211" and it contains three 1's, so return 3.










## 482 - License Key Formatting
~2~  []
Now you are given a string S, which represents a software license key which we would like to format. The string S is composed of alphanumerical characters and dashes. The dashes split the alphanumerical characters within the string into groups. (i.e. if there are M dashes, the string is split into M+1 groups). The dashes in the given string are possibly misplaced.

We want each group of characters to be of length K (except for possibly the first group, which could be shorter, but still must contain at least one character). To satisfy this requirement, we will reinsert dashes. Additionally, all the lower case letters in the string must be converted to upper case.

So, you are given a non-empty string S, representing a license key to format, and an integer K. And you need to return the license key formatted according to the description above.


Example 1:

Input: S = "2-4A0r7-4k", K = 4

Output: "24A0-R74K"

Explanation: The string S has been split into two parts, each part has 4 characters.




Example 2:

Input: S = "2-4A0r7-4k", K = 3

Output: "24-A0R-74K"

Explanation: The string S has been split into three parts, each part has 3 characters except the first part as it could be shorter as said above.



Note:

The length of string S will not exceed 12,000, and K is a positive integer.
String S consists only of alphanumerical characters (a-z and/or A-Z and/or 0-9) and dashes(-).
String S is non-empty.










## 483 - Smallest Good Base
~3~  ['Math', 'Binary Search']
For an integer n, we call k>=2 a good base of n, if all digits of n base k are 1.
Now given a string representing n, you should return the smallest good base of n in string format. 

Example 1:

Input: "13"
Output: "3"
Explanation: 13 base 3 is 111.



Example 2:

Input: "4681"
Output: "8"
Explanation: 4681 base 8 is 11111.



Example 3:

Input: "1000000000000000000"
Output: "999999999999999999"
Explanation: 1000000000000000000 base 999999999999999999 is 11.



Note:

The range of n is [3, 10^18].
The string representing n is always valid and will not have leading zeros.










## 484 - Find Permutation
~2~  []
By now, you are given a secret signature consisting of character 'D' and 'I'.
'D' represents a decreasing relationship between two numbers, 'I' represents
an increasing relationship between two numbers. And our secret signature was
constructed by a special integer array, which contains uniquely all the
different number from 1 to n (n is the length of the secret signature plus 1).
For example, the secret signature "DI" can be constructed by array [2,1,3] or
[3,1,2], but won't be constructed by array [3,2,4] or [2,1,3,4], which are
both illegal constructing special string that can't represent the "DI" secret
signature.

On the other hand, now your job is to find the lexicographically smallest
permutation of [1, 2, ... n] could refer to the given secret signature in the
input.

Example 1:



    Input: "I"Output: [1,2]Explanation: [1,2] is the only legal initial spectial string can construct secret signature "I", where the number 1 and 2 construct an increasing relationship.



Example 2:



    Input: "DI"Output: [2,1,3]Explanation: Both [2,1,3] and [3,1,2] can construct the secret signature "DI",
    but since we want to find the one with the smallest lexicographical permutation, you need to output [2,1,3]



Note:

  * The input string will only contain the character 'D' and 'I'.
  * The length of input string is a positive integer and will not exceed 10,000










## 485 - Max Consecutive Ones
~1~  ['Array']
Given a binary array, find the maximum number of consecutive 1s in this array.

Example 1:

Input: [1,1,0,1,1,1]
Output: 3
Explanation: The first two digits or the last three digits are consecutive 1s.
    The maximum number of consecutive 1s is 3.



Note:

The input array will only contain 0 and 1.
The length of input array is a positive integer and will not exceed 10,000










## 486 - Predict the Winner
~2~  ['Dynamic Programming', 'Minimax']
Given an array of scores that are non-negative integers. Player 1 picks one of the numbers from either end of the array followed by the player 2 and then player 1 and so on. Each time a player picks a number, that number will not be available for the next player. This continues until all the scores have been chosen. The player with the maximum score wins. 

Given an array of scores, predict whether player 1 is the winner. You can assume each player plays to maximize his score. 

Example 1:

Input: [1, 5, 2]
Output: False
Explanation: Initially, player 1 can choose between 1 and 2. If he chooses 2 (or 1), then player 2 can choose from 1 (or 2) and 5. If player 2 chooses 5, then player 1 will be left with 1 (or 2). So, final score of player 1 is 1 + 2 = 3, and player 2 is 5. Hence, player 1 will never be the winner and you need to return False.



Example 2:

Input: [1, 5, 233, 7]
Output: True
Explanation: Player 1 first chooses 1. Then player 2 have to choose between 5 and 7. No matter which number player 2 choose, player 1 can choose 233.Finally, player 1 has more score (234) than player 2 (12), so you need to return True representing player1 can win.



Note:

1 <= length of the array <= 20. 
Any scores in the given array are non-negative integers and will not exceed 10,000,000.
If the scores of both players are equal, then player 1 is still the winner.










## 487 - Max Consecutive Ones II
~2~  []
Given a binary array, find the maximum number of consecutive 1s in this array
if you can flip at most one 0.

Example 1:



    Input: [1,0,1,1,0]Output: 4Explanation: Flip the first zero will get the the maximum number of consecutive 1s.    After flipping, the maximum number of consecutive 1s is 4.



Note:

  * The input array will only contain `0` and `1`.
  * The length of input array is a positive integer and will not exceed 10,000



Follow up:
What if the input numbers come in one by one as an infinite stream? In other
words, you can't store all numbers coming from the stream as it's too large to
hold in memory. Could you solve it efficiently?










## 488 - Zuma Game
~3~  ['Depth-first Search']
Think about Zuma Game. You have a row of balls on the table, colored red(R), yellow(Y), blue(B), green(G), and white(W). You also have several balls in your hand.

Each time, you may choose a ball in your hand, and insert it into the row (including the leftmost place and rightmost place). Then, if there is a group of 3 or more balls in the same color touching, remove these balls. Keep doing this until no more balls can be removed.

Find the minimal balls you have to insert to remove all the balls on the table. If you cannot remove all the balls, output -1.


Examples:
Input: "WRRBBW", "RB"
Output: -1
Explanation: WRRBBW -> WRR[R]BBW -> WBBW -> WBB[B]W -> WW

Input: "WWRRBBWW", "WRBRW"
Output: 2
Explanation: WWRRBBWW -> WWRR[R]BBWW -> WWBBWW -> WWBB[B]WW -> WWWW -> empty

Input:"G", "GGGGG"
Output: 2
Explanation: G -> G[G] -> GG[G] -> empty 

Input: "RBYYBBRRB", "YRBGB"
Output: 3
Explanation: RBYYBBRRB -> RBYY[Y]BBRRB -> RBBBRRB -> RRRB -> B -> B[B] -> BB[B] -> empty 



Note:

You may assume that the initial row of balls on the table won’t have any 3 or more consecutive balls with the same color.
The number of balls on the table won't exceed 20, and the string represents these balls is called "board" in the input.
The number of balls in your hand won't exceed 5, and the string represents these balls is called "hand" in the input.
Both input strings will be non-empty and only contain characters 'R','Y','B','G','W'.










## 491 - Increasing Subsequences
~2~  ['Depth-first Search']
Given an integer array, your task is to find all the different possible increasing subsequences of the given array, and the length of an increasing subsequence should be at least 2 .


Example:

Input: [4, 6, 7, 7]
Output: [[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]]



Note:

The length of the given array will not exceed 15.
The range of integer in the given array is [-100,100].
The given array may contain duplicates, and two equal integers should also be considered as a special case of increasing sequence.










## 492 - Construct the Rectangle
~1~  []
For a web developer, it is very important to know how to design a web page's size. So, given a specific rectangular web page’s area, your job by now is to design a rectangular web page, whose length L and width W satisfy the following requirements:
1. The area of the rectangular web page you designed must equal to the given target area.
2. The width W should not be larger than the length L, which means L >= W.
3. The difference between length L and width W should be as small as possible.

You need to output the length L and the width W of the web page you designed in sequence.



Example:

Input: 4
Output: [2, 2]
Explanation: The target area is 4, and all the possible ways to construct it are [1,4], [2,2], [4,1]. 
But according to requirement 2, [1,4] is illegal; according to requirement 3,  [4,1] is not optimal compared to [2,2]. So the length L is 2, and the width W is 2.



Note:

The given area won't exceed 10,000,000 and is a positive integer
The web page's width and length you designed must be positive integers.










## 493 - Reverse Pairs
~3~  ['Divide and Conquer', 'Binary Indexed Tree', 'Segment Tree', 'Binary Search Tree']
Given an array nums, we call (i, j) an important reverse pair if i < j and nums[i] > 2*nums[j].

You need to return the number of important reverse pairs in the given array.

Example1:

Input: [1,3,2,3,1]
Output: 2


Example2:

Input: [2,4,3,5,1]
Output: 3


Note:

The length of the given array will not exceed 50,000.
All the numbers in the input array are in the range of 32-bit integer.










## 494 - Target Sum
~2~  ['Dynamic Programming', 'Depth-first Search']
You are given a list of non-negative integers, a1, a2, ..., an, and a target, S. Now you have 2 symbols + and -. For each integer, you should choose one from + and - as its new symbol.
 

Find out how many ways to assign symbols to make sum of integers equal to target S.  


Example 1:

Input: nums is [1, 1, 1, 1, 1], S is 3. 
Output: 5
Explanation: 

-1+1+1+1+1 = 3
+1-1+1+1+1 = 3
+1+1-1+1+1 = 3
+1+1+1-1+1 = 3
+1+1+1+1-1 = 3

There are 5 ways to assign symbols to make the sum of nums be target 3.



Note:

The length of the given array is positive and will not exceed 20. 
The sum of elements in the given array will not exceed 1000.
Your output answer is guaranteed to be fitted in a 32-bit integer.










## 495 - Teemo Attacking
~2~  ['Array']
In LOL world, there is a hero called Teemo and his attacking can make his enemy Ashe be in poisoned condition. Now, given the Teemo's attacking ascending time series towards Ashe and the poisoning time duration per Teemo's attacking, you need to output the total time that Ashe is in poisoned condition.


You may assume that Teemo attacks at the very beginning of a specific time point, and makes Ashe be in poisoned condition immediately.

Example 1:

Input: [1,4], 2
Output: 4
Explanation: At time point 1, Teemo starts attacking Ashe and makes Ashe be poisoned immediately. This poisoned status will last 2 seconds until the end of time point 2. And at time point 4, Teemo attacks Ashe again, and causes Ashe to be in poisoned status for another 2 seconds. So you finally need to output 4.




Example 2:

Input: [1,2], 2
Output: 3
Explanation: At time point 1, Teemo starts attacking Ashe and makes Ashe be poisoned. This poisoned status will last 2 seconds until the end of time point 2. However, at the beginning of time point 2, Teemo attacks Ashe again who is already in poisoned status. Since the poisoned status won't add up together, though the second poisoning attack will still work at time point 2, it will stop at the end of time point 3. So you finally need to output 3.




Note:

You may assume the length of given time series array won't exceed 10000.
You may assume the numbers in the Teemo's attacking time series and his poisoning time duration per attacking are non-negative integers, which won't exceed 10,000,000.










## 496 - Next Greater Element I
~1~  ['Stack']
You are given two arrays (without duplicates) nums1 and nums2 where nums1’s elements are subset of nums2. Find all the next greater numbers for nums1's elements in the corresponding places of nums2. 



The Next Greater Number of a number x in nums1 is the first greater number to its right in nums2. If it does not exist, output -1 for this number.


Example 1:

Input: nums1 = [4,1,2], nums2 = [1,3,4,2].
Output: [-1,3,-1]
Explanation:
    For number 4 in the first array, you cannot find the next greater number for it in the second array, so output -1.
    For number 1 in the first array, the next greater number for it in the second array is 3.
    For number 2 in the first array, there is no next greater number for it in the second array, so output -1.



Example 2:

Input: nums1 = [2,4], nums2 = [1,2,3,4].
Output: [3,-1]
Explanation:
    For number 2 in the first array, the next greater number for it in the second array is 3.
    For number 4 in the first array, there is no next greater number for it in the second array, so output -1.




Note:

All elements in nums1 and nums2 are unique.
The length of both nums1 and nums2 would not exceed 1000.










## 498 - Diagonal Traverse
~2~  []
Given a matrix of M x N elements (M rows, N columns), return all elements of the matrix in diagonal order as shown in the below image. 


Example:

Input:
[
 [ 1, 2, 3 ],
 [ 4, 5, 6 ],
 [ 7, 8, 9 ]
]
Output:  [1,2,4,7,5,3,6,8,9]
Explanation:




Note:

The total number of elements of the given matrix will not exceed 10,000.










## 500 - Keyboard Row
~1~  ['Hash Table']
Given a List of words, return the words that can be typed using letters of alphabet on only one row's of American keyboard like the image below. 







Example 1:

Input: ["Hello", "Alaska", "Dad", "Peace"]
Output: ["Alaska", "Dad"]



Note:

You may use one character in the keyboard more than once.
You may assume the input string will only contain letters of alphabet.










## 501 - Find Mode in Binary Search Tree
~1~  ['Tree']
Given a binary search tree (BST) with duplicates, find all the mode(s) (the most frequently occurred element) in the given BST.


Assume a BST is defined as follows:

The left subtree of a node contains only nodes with keys less than or equal to the node's key.
The right subtree of a node contains only nodes with keys greater than or equal to the node's key.
Both the left and right subtrees must also be binary search trees.




For example:
Given BST [1,null,2,2],

   1
    \
     2
    /
   2



return [2].


Note:
If a tree has more than one mode, you can return them in any order.


Follow up:
Could you do that without using any extra space? (Assume that the implicit stack space incurred due to recursion does not count).










## 502 - IPO
~3~  ['Heap', 'Greedy']
Suppose LeetCode will start its IPO soon. In order to sell a good price of its shares to Venture Capital, LeetCode would like to work on some projects to increase its capital before the IPO. Since it has limited resources, it can only finish at most k distinct projects before the IPO. Help LeetCode design the best way to maximize its total capital after finishing at most k distinct projects. 



You are given several projects. For each project i, it has a pure profit Pi and a minimum capital of Ci is needed to start the corresponding project. Initially, you have W capital. When you finish a project, you will obtain its pure profit and the profit will be added to your total capital.



To sum up, pick a list of at most k distinct projects from given projects to maximize your final capital, and output your final maximized capital.


Example 1:

Input: k=2, W=0, Profits=[1,2,3], Capital=[0,1,1].

Output: 4

Explanation: Since your initial capital is 0, you can only start the project indexed 0.
             After finishing it you will obtain profit 1 and your capital becomes 1.
             With capital 1, you can either start the project indexed 1 or the project indexed 2.
             Since you can choose at most 2 projects, you need to finish the project indexed 2 to get the maximum capital.
             Therefore, output the final maximized capital, which is 0 + 1 + 3 = 4.



Note:

You may assume all numbers in the input are non-negative integers.
The length of Profits array and Capital array will not exceed 50,000.
The answer is guaranteed to fit in a 32-bit signed integer.










## 503 - Next Greater Element II
~2~  ['Stack']
Given a circular array (the next element of the last element is the first element of the array), print the Next Greater Number for every element. The Next Greater Number of a number x is the first greater number to its traversing-order next in the array, which means you could search circularly to find its next greater number. If it doesn't exist, output -1 for this number.


Example 1:

Input: [1,2,1]
Output: [2,-1,2]
Explanation: The first 1's next greater number is 2; The number 2 can't find next greater number; The second 1's next greater number needs to search circularly, which is also 2.



Note:
The length of given array won't exceed 10000.










## 504 - Base 7
~1~  []
Given an integer, return its base 7 string representation.

Example 1:

Input: 100
Output: "202"



Example 2:

Input: -7
Output: "-10"



Note:
The input will be in range of [-1e7, 1e7].










## 506 - Relative Ranks
~1~  []
Given scores of N athletes, find their relative ranks and the people with the top three highest scores, who will be awarded medals: "Gold Medal", "Silver Medal" and "Bronze Medal".

Example 1:

Input: [5, 4, 3, 2, 1]
Output: ["Gold Medal", "Silver Medal", "Bronze Medal", "4", "5"]
Explanation: The first three athletes got the top three highest scores, so they got "Gold Medal", "Silver Medal" and "Bronze Medal". For the left two athletes, you just need to output their relative ranks according to their scores.



Note:

N is a positive integer and won't exceed 10,000.
All the scores of athletes are guaranteed to be unique.










## 507 - Perfect Number
~1~  ['Math']
We define the Perfect Number is a positive integer that is equal to the sum of all its positive divisors except itself. 

Now, given an integer n, write a function that returns true when it is a perfect number and false when it is not.


Example:

Input: 28
Output: True
Explanation: 28 = 1 + 2 + 4 + 7 + 14



Note:
The input number n will not exceed 100,000,000. (1e8)










## 508 - Most Frequent Subtree Sum
~2~  ['Hash Table', 'Tree']
Given the root of a tree, you are asked to find the most frequent subtree sum. The subtree sum of a node is defined as the sum of all the node values formed by the subtree rooted at that node (including the node itself). So what is the most frequent subtree sum value? If there is a tie, return all the values with the highest frequency in any order.


Examples 1
Input:

  5
 /  \
2   -3

return [2, -3, 4], since all the values happen only once, return all of them in any order.


Examples 2
Input:

  5
 /  \
2   -5

return [2], since 2 happens twice, however -5 only occur once.


Note:
You may assume the sum of values in any subtree is in the range of 32-bit signed integer.










## 513 - Find Bottom Left Tree Value
~2~  ['Tree', 'Depth-first Search', 'Breadth-first Search']
Given a binary tree, find the leftmost value in the last row of the tree. 


Example 1:

Input:

    2
   / \
  1   3

Output:
1



  Example 2: 

Input:

        1
       / \
      2   3
     /   / \
    4   5   6
       /
      7

Output:
7



Note:
You may assume the tree (i.e., the given root node) is not NULL.










## 514 - Freedom Trail
~3~  ['Divide and Conquer', 'Dynamic Programming', 'Depth-first Search']
In the video game Fallout 4, the quest "Road to Freedom" requires players to reach a metal dial called the "Freedom Trail Ring", and use the dial to spell a specific keyword in order to open the door. 



Given a string ring, which represents the code engraved on the outer ring and another string key, which represents the keyword needs to be spelled. You need to find the minimum number of steps in order to spell all the characters in the keyword.

Initially, the first character of the ring is aligned at 12:00 direction. You need to spell all the characters in the string key one by one by rotating the ring clockwise or anticlockwise to make each character of the string key aligned at 12:00 direction and then by pressing the center button.


At the stage of rotating the ring to spell the key character key[i]:

You can rotate the ring clockwise or anticlockwise one place, which counts as 1 step. The final purpose of the rotation is to align one of the string ring's characters at the 12:00 direction, where this character must equal to the character key[i].

If the character key[i] has been aligned at the 12:00 direction, you need to press the center button to spell, which also counts as 1 step. After the pressing, you could begin to spell the next character in the key (next stage), otherwise, you've finished all the spelling.




Example:





Input: ring = "godding", key = "gd"
Output: 4
Explanation: For the first key character 'g', since it is already in place, we just need 1 step to spell this character.  For the second key character 'd', we need to rotate the ring "godding" anticlockwise by two steps to make it become "ddinggo". Also, we need 1 more step for spelling. So the final output is 4.



Note:

Length of both ring and key will be in range 1 to 100.
There are only lowercase letters in both strings and might be some duplcate characters in both strings.
It's guaranteed that string key could always be spelled by rotating the string ring.










## 515 - Find Largest Value in Each Tree Row
~2~  ['Tree', 'Depth-first Search', 'Breadth-first Search']
You need to find the largest value in each row of a binary tree.

Example:

Input: 

          1
         / \
        3   2
       / \   \  
      5   3   9 

Output: [1, 3, 9]










## 516 - Longest Palindromic Subsequence
~2~  ['Dynamic Programming']
Given a string s, find the longest palindromic subsequence's length in s. You may assume that the maximum length of s is 1000.


Example 1:
Input: 

"bbbab"

Output: 

4

One possible longest palindromic subsequence is "bbbb".


Example 2:
Input:

"cbbd"

Output:

2

One possible longest palindromic subsequence is "bb".










## 517 - Super Washing Machines
~3~  ['Math', 'Dynamic Programming']
You have n super washing machines on a line. Initially, each washing machine has some dresses or is empty. 


For each move, you could choose any m (1 ≤ m ≤ n) washing machines, and pass one dress of each washing machine to one of its adjacent washing machines  at the same time .  

Given an integer array representing the number of dresses in each washing machine from left to right on the line, you should find the minimum number of moves to make all the washing machines have the same number of dresses. If it is not possible to do it, return -1.

Example1

Input: [1,0,5]

Output: 3

Explanation: 
1st move:    1     0 <-- 5    =>    1     1     4
2nd move:    1 <-- 1 <-- 4    =>    2     1     3    
3rd move:    2     1 <-- 3    =>    2     2     2   


Example2

Input: [0,3,0]

Output: 2

Explanation: 
1st move:    0 <-- 3     0    =>    1     2     0    
2nd move:    1     2 --> 0    =>    1     1     1     


Example3

Input: [0,2,0]

Output: -1

Explanation: 
It's impossible to make all the three washing machines have the same number of dresses. 




Note:

The range of n is [1, 10000].
The range of dresses number in a super washing machine is [0, 1e5].










## 518 - Coin Change 2
~2~  []
You are given coins of different denominations and a total amount of money. Write a function to compute the number of combinations that make up that amount. You may assume that you have infinite number of each kind of coin.


Note: 
You can assume that

 0 <= amount <= 5000
 1 <= coin <= 5000
 the number of coins is less than 500 
 the answer is guaranteed to fit into signed 32-bit integer



Example 1:

Input: amount = 5, coins = [1, 2, 5]
Output: 4
Explanation: there are four ways to make up the amount:
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1


Example 2:

Input: amount = 3, coins = [2]
Output: 0
Explanation: the amount of 3 cannot be made up just with coins of 2.


Example 3:

Input: amount = 10, coins = [10] 
Output: 1










## 520 - Detect Capital
~1~  ['String']
Given a word, you need to judge whether the usage of capitals in it is right or not.



We define the usage of capitals in a word to be right when one of the following cases holds:

All letters in this word are capitals, like "USA".
All letters in this word are not capitals, like "leetcode".
Only the first letter in this word is capital if it has more than one letter, like "Google".

Otherwise, we define that this word doesn't use capitals in a right way.



Example 1:

Input: "USA"
Output: True



Example 2:

Input: "FlaG"
Output: False



Note:
The input will be a non-empty word consisting of uppercase and lowercase latin letters.










## 521 - Longest Uncommon Subsequence I 
~1~  ['String']
Given a group of two strings, you need to find the longest uncommon subsequence of this group of two strings.
The longest uncommon subsequence is defined as the longest subsequence of one of these strings and this subsequence should not be any subsequence of the other strings.



A subsequence is a sequence that can be derived from one sequence by deleting some characters without changing the order of the remaining elements. Trivially, any string is a subsequence of itself and an empty string is a subsequence of any string.



The input will be two strings, and the output needs to be the length of the longest uncommon subsequence. If the longest uncommon subsequence doesn't exist, return -1.


Example 1:

Input: "aba", "cdc"
Output: 3
Explanation: The longest uncommon subsequence is "aba" (or "cdc"), because "aba" is a subsequence of "aba", but not a subsequence of any other strings in the group of two strings. 



Note:

Both strings' lengths will not exceed 100.
Only letters from a ~ z will appear in input strings.










## 522 - Longest Uncommon Subsequence II
~2~  ['String']
Given a list of strings, you need to find the longest uncommon subsequence among them. The longest uncommon subsequence is defined as the longest subsequence of one of these strings and this subsequence should not be any subsequence of the other strings.



A subsequence is a sequence that can be derived from one sequence by deleting some characters without changing the order of the remaining elements. Trivially, any string is a subsequence of itself and an empty string is a subsequence of any string.



The input will be a list of strings, and the output needs to be the length of the longest uncommon subsequence. If the longest uncommon subsequence doesn't exist, return -1.


Example 1:

Input: "aba", "cdc", "eae"
Output: 3



Note:

All the given strings' lengths will not exceed 10.
The length of the given list will be in the range of [2, 50].










## 523 - Continuous Subarray Sum
~2~  ['Math', 'Dynamic Programming']
Given a list of non-negative numbers and a target integer k, write a function to check if the array has a continuous subarray of size at least 2 that sums up to the multiple of k, that is, sums up to n*k where n is also an integer.



Example 1:

Input: [23, 2, 4, 6, 7],  k=6
Output: True
Explanation: Because [2, 4] is a continuous subarray of size 2 and sums up to 6.




Example 2:

Input: [23, 2, 6, 4, 7],  k=6
Output: True
Explanation: Because [23, 2, 6, 4, 7] is an continuous subarray of size 5 and sums up to 42.



Note:

The length of the array won't exceed 10,000.
You may assume the sum of all the numbers is in the range of a signed 32-bit integer.










## 524 - Longest Word in Dictionary through Deleting
~2~  ['Two Pointers', 'Sort']
Given a string and a string dictionary, find the longest string in the dictionary that can be formed by deleting some characters of the given string. If there are more than one possible results, return the longest word with the smallest lexicographical order. If there is no possible result, return the empty string.

Example 1:

Input:
s = "abpcplea", d = ["ale","apple","monkey","plea"]

Output: 
"apple"




Example 2:

Input:
s = "abpcplea", d = ["a","b","c"]

Output: 
"a"



Note:

All the strings in the input will only contain lower-case letters.
The size of the dictionary won't exceed 1,000.
The length of all the strings in the input won't exceed 1,000.










## 525 - Contiguous Array
~2~  ['Hash Table']
Given a binary array, find the maximum length of a contiguous subarray with equal number of 0 and 1. 


Example 1:

Input: [0,1]
Output: 2
Explanation: [0, 1] is the longest contiguous subarray with equal number of 0 and 1.



Example 2:

Input: [0,1,0]
Output: 2
Explanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1.



Note:
The length of the given binary array will not exceed 50,000.










## 526 - Beautiful Arrangement
~2~  ['Backtracking']
Suppose you have N integers from 1 to N. We define a beautiful arrangement as an array that is constructed by these N numbers successfully if one of the following is true for the ith position (1 <= i <= N) in this array:

The number at the ith position is divisible by i.
i is divisible by the number at the ith position.




Now given N, how many beautiful arrangements can you construct?


Example 1:

Input: 2
Output: 2
Explanation: 
The first beautiful arrangement is [1, 2]:
Number at the 1st position (i=1) is 1, and 1 is divisible by i (i=1).
Number at the 2nd position (i=2) is 2, and 2 is divisible by i (i=2).
The second beautiful arrangement is [2, 1]:
Number at the 1st position (i=1) is 2, and 2 is divisible by i (i=1).
Number at the 2nd position (i=2) is 1, and i (i=2) is divisible by 1.



Note:

N is a positive integer and will not exceed 15.










## 527 - Word Abbreviation
~3~  []
Given an array of n distinct non-empty strings, you need to generate minimal
possible abbreviations for every word following rules below.

  1. Begin with the first character and then the number of characters abbreviated, which followed by the last character.
  2. If there are any conflict, that is more than one words share the same abbreviation, a longer prefix is used instead of only the first character until making the map from word to abbreviation become unique. In other words, a final abbreviation cannot map to more than one original words.
  3. If the abbreviation doesn't make the word shorter, then keep it as original.

Example:



    Input: ["like", "god", "internal", "me", "internet", "interval", "intension", "face", "intrusion"]Output: ["l2e","god","internal","me","i6t","interval","inte4n","f2e","intr4n"]



Note:

  1. Both n and the length of each word will not exceed 400.
  2. The length of each word is greater than 1.
  3. The words consist of lowercase English letters only.
  4. The return answers should be in the same order as the original array.










## 529 - Minesweeper
~2~  ['Depth-first Search', 'Breadth-first Search']
Let's play the minesweeper game (Wikipedia, online game)! 

You are given a 2D char matrix representing the game board. 'M' represents an unrevealed mine, 'E' represents an unrevealed empty square, 'B' represents a revealed blank square that has no adjacent (above, below, left, right, and all 4 diagonals) mines, digit ('1' to '8') represents how many mines are adjacent to this revealed square, and finally 'X' represents a revealed mine.

Now given the next click position (row and column indices) among all the unrevealed squares ('M' or 'E'), return the board after revealing this position according to the following rules: 



If a mine ('M') is revealed, then the game is over - change it to 'X'.
If an empty square ('E') with no adjacent mines is revealed, then change it to revealed blank ('B') and all of its adjacent unrevealed squares should be revealed recursively.
If an empty square ('E') with at least one adjacent mine is revealed, then change it to a digit ('1' to '8') representing the number of adjacent mines.
Return the board when no more squares will be revealed.



Example 1:

Input: 

[['E', 'E', 'E', 'E', 'E'],
 ['E', 'E', 'M', 'E', 'E'],
 ['E', 'E', 'E', 'E', 'E'],
 ['E', 'E', 'E', 'E', 'E']]

Click : [3,0]

Output: 

[['B', '1', 'E', '1', 'B'],
 ['B', '1', 'M', '1', 'B'],
 ['B', '1', '1', '1', 'B'],
 ['B', 'B', 'B', 'B', 'B']]

Explanation:




Example 2:

Input: 

[['B', '1', 'E', '1', 'B'],
 ['B', '1', 'M', '1', 'B'],
 ['B', '1', '1', '1', 'B'],
 ['B', 'B', 'B', 'B', 'B']]

Click : [1,2]

Output: 

[['B', '1', 'E', '1', 'B'],
 ['B', '1', 'X', '1', 'B'],
 ['B', '1', '1', '1', 'B'],
 ['B', 'B', 'B', 'B', 'B']]

Explanation:






Note:

The range of the input matrix's height and width is [1,50].
The click position will only be an unrevealed square ('M' or 'E'), which also means the input board contains at least one clickable square.
The input board won't be a stage when game is over (some mines have been revealed).
For simplicity, not mentioned rules should be ignored in this problem. For example, you don't need to reveal all the unrevealed mines when the game is over, consider any cases that you will win the game or flag any squares.










## 530 - Minimum Absolute Difference in BST
~1~  ['Binary Search Tree']
Given a binary search tree with non-negative values, find the minimum absolute difference between values of any two nodes.


Example:

Input:

   1
    \
     3
    /
   2

Output:
1

Explanation:
The minimum absolute difference is 1, which is the difference between 2 and 1 (or between 2 and 3).




Note:
There are at least two nodes in this BST.










## 531 - Lonely Pixel I
~2~  []
Given a picture consisting of black and white pixels, find the number of black
lonely pixels.

The picture is represented by a 2D char array consisting of 'B' and 'W', which
means black and white pixels respectively.

A black lonely pixel is character 'B' that located at a specific position
where the same row and same column don't have any other black pixels.

Example:



    Input: [['W', 'W', 'B'], ['W', 'B', 'W'], ['B', 'W', 'W']]Output: 3Explanation: All the three 'B's are black lonely pixels.



Note:

  1. The range of width and height of the input 2D array is [1,500].










## 532 - K-diff Pairs in an Array
~1~  ['Array', 'Two Pointers']
Given an array of integers and an integer k, you need to find the number of unique k-diff pairs in the array. Here a k-diff pair is defined as an integer pair (i, j), where i and j are both numbers in the array and their absolute difference is k.



Example 1:

Input: [3, 1, 4, 1, 5], k = 2
Output: 2
Explanation: There are two 2-diff pairs in the array, (1, 3) and (3, 5).Although we have two 1s in the input, we should only return the number of unique pairs.



Example 2:

Input:[1, 2, 3, 4, 5], k = 1
Output: 4
Explanation: There are four 1-diff pairs in the array, (1, 2), (2, 3), (3, 4) and (4, 5).



Example 3:

Input: [1, 3, 1, 5, 4], k = 0
Output: 1
Explanation: There is one 0-diff pair in the array, (1, 1).



Note:

The pairs (i, j) and (j, i) count as the same pair.
The length of the array won't exceed 10,000.
All the integers in the given input belong to the range: [-1e7, 1e7].










## 533 - Lonely Pixel II
~2~  []
Given a picture consisting of black and white pixels, and a positive integer
N, find the number of black pixels located at some specific row **R** and
column **C** that align with all the following rules:

  1. Row R and column C both contain exactly N black pixels.
  2. For all rows that have a black pixel at column C, they should be exactly the same as row R

The picture is represented by a 2D char array consisting of 'B' and 'W', which
means black and white pixels respectively.

**Example:**


    **Input:**                                            [['W', 'B', 'W', 'B', 'B', 'W'],     ['W', 'B', 'W', 'B', 'B', 'W'],     ['W', 'B', 'W', 'B', 'B', 'W'],     ['W', 'W', 'B', 'W', 'B', 'W']] N = 3**Output:** 6**Explanation:** All the bold 'B' are the black pixels we need (all 'B's at column 1 and 3).        0    1    2    3    4    5         column index                                            0    [['W', **'B'**, 'W', **'B'**, 'B', 'W'],    1     ['W', **'B'**, 'W', **'B'**, 'B', 'W'],    2     ['W', **'B'**, 'W', **'B'**, 'B', 'W'],    3     ['W', 'W', 'B', 'W', 'B', 'W']]    row indexTake 'B' at row R = 0 and column C = 1 as an example:Rule 1, row R = 0 and column C = 1 both have exactly N = 3 black pixels. Rule 2, the rows have black pixel at column C = 1 are row 0, row 1 and row 2. They are exactly the same as row R = 0.

**Note:**
    1. The range of width and height of the input 2D array is [1,200].










## 534 - Design TinyURL
~2~  []
Note: For the coding companion problem, please see: Encode and Decode TinyURL.

How would you design a URL shortening service that is similar to TinyURL?

Background:
TinyURL is a URL shortening service where you enter a URL such as https://leetcode.com/problems/design-tinyurl and it returns a short URL such as http://tinyurl.com/4e9iAk.


Requirements:

For instance, "http://tinyurl.com/4e9iAk" is the tiny url for the page "https://leetcode.com/problems/design-tinyurl". The identifier (the highlighted part) can be any string with 6 alphanumeric characters containing 0-9, a-z, A-Z.

Each shortened URL must be unique; that is, no two different URLs can be shortened to the same URL.



Note about Questions:Below are just a small subset of questions to get you started. In real world, there could be many follow ups and questions possible and the discussion is open-ended (No one true or correct way to solve a problem). If you have more ideas or questions, please ask in Discuss and we may compile it here!

Questions:

How many unique identifiers possible? Will you run out of unique URLs?
Should the identifier be increment or not? Which is easier to design? Pros and cons?
Mapping an identifier to an URL and its reversal - Does this problem ring a bell to you?
How do you store the URLs? Does a simple flat file database work?
What is the bottleneck of the system? Is it read-heavy or write-heavy?
Estimate the maximum number of URLs a single machine can store.
Estimate the maximum number of queries per second (QPS) for decoding a shortened URL in a single machine.
How would you scale the service? For example, a viral link which is shared in social media could result in a peak QPS at a moment's notice.
How could you handle redundancy? i,e, if a server is down, how could you ensure the service is still operational?
Keep URLs forever or prune, pros/cons? How we do pruning? (Contributed by @alex_svetkin)
What API would you provide to a third-party developer? (Contributed by @alex_svetkin)
If you can enable caching, what would you cache and what's the expiry time? (Contributed by @Humandroid)




.hilight {
  color: #d14;
  background-color: #f7f7f9;
  padding: 1px 3px;
  border: 1px solid #e1e1e8"
}










## 535 - Encode and Decode TinyURL
~2~  ['Hash Table', 'Math']
Note: This is a companion problem to the System Design problem: Design TinyURL.

TinyURL is a URL shortening service where you enter a URL such as https://leetcode.com/problems/design-tinyurl and it returns a short URL such as http://tinyurl.com/4e9iAk.

Design the encode and decode methods for the TinyURL service. There is no restriction on how your encode/decode algorithm should work. You just need to ensure that a URL can be encoded to a tiny URL and the tiny URL can be decoded to the original URL.










## 536 - Construct Binary Tree from String
~2~  []
You need to construct a binary tree from a string consisting of parenthesis
and integers.

The whole input represents a binary tree. It contains an integer followed by
zero, one or two pairs of parenthesis. The integer represents the root's value
and a pair of parenthesis contains a child binary tree with the same
structure.

You always start to construct the left child node of the parent first if it
exists.

Example:



    Input: "4(2(3)(1))(6(5))"Output: return the tree root node representing the following tree:       4     /   \    2     6   / \   /   3   1 5   



Note:

  1. There will only be `'('`, `')'`, `'-'` and `'0'` ~ `'9'` in the input string.
  2. An empty tree is represented by `""` instead of `"()"`.










## 537 - Complex Number Multiplication
~2~  ['Math', 'String']
Given two strings representing two complex numbers.


You need to return a string representing their multiplication. Note i2 = -1 according to the definition.


Example 1:

Input: "1+1i", "1+1i"
Output: "0+2i"
Explanation: (1 + i) * (1 + i) = 1 + i2 + 2 * i = 2i, and you need convert it to the form of 0+2i.



Example 2:

Input: "1+-1i", "1+-1i"
Output: "0+-2i"
Explanation: (1 - i) * (1 - i) = 1 + i2 - 2 * i = -2i, and you need convert it to the form of 0+-2i.



Note:

The input strings will not have extra blank.
The input strings will be given in the form of a+bi, where the integer a and b will both belong to the range of [-100, 100]. And the output should be also in this form.










## 538 - Convert BST to Greater Tree
~1~  ['Tree']
Given a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus sum of all keys greater than the original key in BST.


Example:

Input: The root of a Binary Search Tree like this:
              5
            /   \
           2     13

Output: The root of a Greater Tree like this:
             18
            /   \
          20     13










## 539 - Minimum Time Difference
~2~  ['String']
Given a list of 24-hour clock time points in "Hour:Minutes" format, find the minimum minutes difference between any two time points in the list. 

Example 1:

Input: ["23:59","00:00"]
Output: 1



Note:

The number of time points in the given list is at least 2 and won't exceed 20000.
The input time is legal and ranges from 00:00 to 23:59.










## 540 - Single Element in a Sorted Array
~2~  []
Given a sorted array consisting of only integers where every element appears twice except for one element which appears once. Find this single element that appears only once. 


Example 1:

Input: [1,1,2,3,3,4,4,8,8]
Output: 2



Example 2:

Input: [3,3,7,7,10,11,11]
Output: 10



Note:
Your solution should run in O(log n) time and O(1) space.










## 541 - Reverse String II
~1~  ['String']
Given a string and an integer k, you need to reverse the first k characters for every 2k characters counting from the start of the string. If there are less than k characters left, reverse all of them. If there are less than 2k but greater than or equal to k characters, then reverse the first k characters and left the other as original.


Example:

Input: s = "abcdefg", k = 2
Output: "bacdfeg"



Restrictions: 

 The string consists of lower English letters only.
 Length of the given string and k will in the range [1, 10000]










## 542 - 01 Matrix
~2~  ['Depth-first Search', 'Breadth-first Search']
Given a matrix consists of 0 and 1, find the distance of the nearest 0 for each cell.

The distance between two adjacent cells is 1.

Example 1: 
Input:

0 0 0
0 1 0
0 0 0

Output:

0 0 0
0 1 0
0 0 0



Example 2: 
Input:

0 0 0
0 1 0
1 1 1

Output:

0 0 0
0 1 0
1 2 1



Note:

The number of elements of the given matrix will not exceed 10,000.
There are at least one 0 in the given matrix.
The cells are adjacent in only four directions: up, down, left and right.










## 543 - Diameter of Binary Tree
~1~  ['Tree']
Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.



Example:
Given a binary tree 

          1
         / \
        2   3
       / \     
      4   5    



Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3].


Note:
The length of path between two nodes is represented by the number of edges between them.










## 544 - Output Contest Matches
~2~  []
During the NBA playoffs, we always arrange the rather strong team to play with
the rather weak team, like make the rank 1 team play with the rank nth team,
which is a good strategy to make the contest more interesting. Now, you're
given n teams, you need to output their final contest matches in the form of a
string.

The n teams are given in the form of positive integers from 1 to n, which
represents their initial rank. (Rank 1 is the strongest team and Rank n is the
weakest team.) We'll use parentheses('(', ')') and commas(',') to represent
the contest team pairing - parentheses('(' , ')') for pairing and commas(',')
for partition. During the pairing process in each round, you always need to
follow the strategy of making the rather strong one pair with the rather weak
one.

Example 1:



    Input: 2Output: (1,2)Explanation: Initially, we have the team 1 and the team 2, placed like: 1,2.Then we pair the team (1,2) together with '(', ')' and ',', which is the final answer.



Example 2:



    Input: 4Output: ((1,4),(2,3))Explanation: In the first round, we pair the team 1 and 4, the team 2 and 3 together, as we need to make the strong team and weak team together.And we got (1,4),(2,3).In the second round, the winners of (1,4) and (2,3) need to play again to generate the final winner, so you need to add the paratheses outside them.And we got the final answer ((1,4),(2,3)).



Example 3:



    Input: 8Output: (((1,8),(4,5)),((2,7),(3,6)))Explanation: First round: (1,8),(2,7),(3,6),(4,5)Second round: ((1,8),(4,5)),((2,7),(3,6))Third round: (((1,8),(4,5)),((2,7),(3,6)))Since the third round will generate the final winner, you need to output the answer (((1,8),(4,5)),((2,7),(3,6))).



Note:

  1. The n is in range [2, 212].
  2. We ensure that the input n can be converted into the form 2k, where k is a positive integer.










## 545 - Boundary of Binary Tree
~2~  []
Given a binary tree, return the values of its boundary in anti-clockwise
direction starting from root. Boundary includes left boundary, leaves, and
right boundary in order without duplicate nodes.

Left boundary is defined as the path from root to the left-most node. Right
boundary is defined as the path from root to the right-most node. If the root
doesn't have left subtree or right subtree, then the root itself is left
boundary or right boundary. Note this definition only applies to the input
binary tree, and not applies to any subtrees.

The left-most node is defined as a leaf node you could reach when you always
firstly travel to the left subtree if exists. If not, travel to the right
subtree. Repeat until you reach a leaf node.

The right-most node is also defined by the same way with left and right
exchanged.

Example 1



    Input:  1   \    2   / \  3   4Ouput:[1, 3, 4, 2]Explanation:The root doesn't have left subtree, so the root itself is left boundary.The leaves are node 3 and 4.The right boundary are node 1,2,4. Note the anti-clockwise direction means you should output reversed right boundary.So order them in anti-clockwise without duplicates and we have [1,3,4,2].



Example 2



    Input:    ____1_____   /          \  2            3 / \          / 4   5        6      / \      / \  7   8    9  10         Ouput:[1,2,4,7,8,9,10,6,3]Explanation:The left boundary are node 1,2,4. (4 is the left-most node according to definition)The leaves are node 4,7,8,9,10.The right boundary are node 1,3,6,10. (10 is the right-most node).So order them in anti-clockwise without duplicate nodes we have [1,2,4,7,8,9,10,6,3].










## 546 - Remove Boxes
~3~  ['Dynamic Programming', 'Depth-first Search']
Given several boxes with different colors represented by different positive numbers. 
You may experience several rounds to remove boxes until there is no box left. Each time you can choose some continuous boxes with the same color (composed of k boxes, k >= 1), remove them and get k*k points.
Find the maximum points you can get.


Example 1:
Input: 

[1, 3, 2, 2, 2, 3, 4, 3, 1]

Output:

23

Explanation: 

[1, 3, 2, 2, 2, 3, 4, 3, 1] 
----> [1, 3, 3, 4, 3, 1] (3*3=9 points) 
----> [1, 3, 3, 3, 1] (1*1=1 points) 
----> [1, 1] (3*3=9 points) 
----> [] (2*2=4 points)



Note:
The number of boxes n would not exceed 100.










## 547 - Friend Circles
~2~  ['Depth-first Search', 'Union Find']
There are N students in a class. Some of them are friends, while some are not. Their friendship is transitive in nature. For example, if A is a direct friend of B, and B is a direct friend of C, then A is an indirect friend of C. And we defined a friend circle is a group of students who are direct or indirect friends.



Given a N*N matrix M representing the friend relationship between students in the class. If M[i][j] = 1, then the ith and jth students are direct friends with each other, otherwise not. And you have to output the total number of friend circles among all the students.


Example 1:

Input: 
[[1,1,0],
 [1,1,0],
 [0,0,1]]
Output: 2
Explanation:The 0th and 1st students are direct friends, so they are in a friend circle. The 2nd student himself is in a friend circle. So return 2.



Example 2:

Input: 
[[1,1,0],
 [1,1,1],
 [0,1,1]]
Output: 1
Explanation:The 0th and 1st students are direct friends, the 1st and 2nd students are direct friends, so the 0th and 2nd students are indirect friends. All of them are in the same friend circle, so return 1.




Note:

N is in range [1,200].
M[i][i] = 1 for all students.
If M[i][j] = 1, then M[j][i] = 1.










## 548 - Split Array with Equal Sum
~2~  []
Given an array with n integers, you need to find if there are triplets (i, j,
k) which satisfies following conditions:

  1. 0 < i, i + 1 < j, j + 1 < k < n - 1
  2. Sum of subarrays (0, i - 1), (i + 1, j - 1), (j + 1, k - 1) and (k + 1, n - 1) should be equal.

where we define that subarray (L, R) represents a slice of the original array
starting from the element indexed L to the element indexed R.

**Example:**


    **Input:** [1,2,1,2,1,2,1]**Output:** True**Explanation:**i = 1, j = 3, k = 5. sum(0, i - 1) = sum(0, 0) = 1sum(i + 1, j - 1) = sum(2, 2) = 1sum(j + 1, k - 1) = sum(4, 4) = 1sum(k + 1, n - 1) = sum(6, 6) = 1

**Note:**

  1. 1 <= n <= 2000.
  2. Elements in the given array will be in range [-1,000,000, 1,000,000].










## 549 - Binary Tree Longest Consecutive Sequence II
~2~  []
Given a binary tree, you need to find the length of Longest Consecutive Path
in Binary Tree.

Especially, this path can be either increasing or decreasing. For example,
[1,2,3,4] and [4,3,2,1] are both considered valid, but the path [1,2,4,3] is
not valid. On the other hand, the path can be in the child-Parent-child order,
where not necessarily be parent-child order.

Example 1:



    Input:        1       / \      2   3Output: 2Explanation: The longest consecutive path is [1, 2] or [2, 1].



Example 2:



    Input:        2       / \      1   3Output: 3Explanation: The longest consecutive path is [1, 2, 3] or [3, 2, 1].



Note: All the values of tree nodes are in the range of [-1e7, 1e7].










## 551 - Student Attendance Record I
~1~  ['String']
You are given a string representing an attendance record for a student. The record only contains the following three characters:



'A' : Absent. 
'L' : Late.
 'P' : Present. 




A student could be rewarded if his attendance record doesn't contain more than one 'A' (absent) or more than two continuous 'L' (late).    

You need to return whether the student could be rewarded according to his attendance record.

Example 1:

Input: "PPALLP"
Output: True



Example 2:

Input: "PPALLL"
Output: False










## 552 - Student Attendance Record II
~3~  ['Dynamic Programming']
Given a positive integer n, return the number of all possible attendance records with length n, which will be regarded as rewardable. The answer may be very large, return it after mod 109 + 7.

A student attendance record is a string that only contains the following three characters:



'A' : Absent. 
'L' : Late.
 'P' : Present. 




A record is regarded as rewardable if it doesn't contain more than one 'A' (absent) or more than two continuous 'L' (late).

Example 1:

Input: n = 2
Output: 8 
Explanation:
There are 8 records with length 2 will be regarded as rewardable:
"PP" , "AP", "PA", "LP", "PL", "AL", "LA", "LL"
Only "AA" won't be regarded as rewardable owing to more than one absent times. 



Note:
The value of n won't exceed 100,000.










## 553 - Optimal Division
~2~  ['Math', 'String']
Given a list of positive integers, the adjacent integers will perform the float division. For example, [2,3,4] -> 2 / 3 / 4.

However, you can add any number of parenthesis at any position to change the priority of operations. You should find out how to add parenthesis to get the maximum result, and return the corresponding expression in string format. Your expression should NOT contain redundant parenthesis.

Example:

Input: [1000,100,10,2]
Output: "1000/(100/10/2)"
Explanation:
1000/(100/10/2) = 1000/((100/10)/2) = 200
However, the bold parenthesis in "1000/((100/10)/2)" are redundant, since they don't influence the operation priority. So you should return "1000/(100/10/2)". 

Other cases:
1000/(100/10)/2 = 50
1000/(100/(10/2)) = 50
1000/100/10/2 = 0.5
1000/100/(10/2) = 2



Note:

The length of the input array is [1, 10].
Elements in the given array will be in range [2, 1000].
There is only one optimal division for each test case.










## 554 - Brick Wall
~2~  ['Hash Table']
There is a brick wall in front of you. The wall is rectangular and has several rows of bricks. The bricks have the same height but different width. You want to draw a vertical line from the top to the bottom and cross the least bricks. 


The brick wall is represented by a list of rows. Each row is a list of integers representing the width of each brick in this row from left to right. 


If your line go through the edge of a brick, then the brick is not considered as crossed. You need to find out how to draw the line to cross the least bricks and return the number of crossed bricks. 

You cannot draw a line just along one of the two vertical edges of the wall, in which case the line will obviously cross no bricks. 

Example:

Input: 
[[1,2,2,1],
 [3,1,2],
 [1,3,2],
 [2,4],
 [3,1,2],
 [1,3,1,1]]
Output: 2
Explanation: 




Note:

The width sum of bricks in different rows are the same and won't exceed INT_MAX.
The number of bricks in each row is in range [1,10,000]. The height of wall is in range [1,10,000]. Total number of bricks of the wall won't exceed 20,000.










## 555 - Split Concatenated Strings
~2~  []
Given a list of strings, you could concatenate these strings together into a
loop, where for each string you could choose to reverse it or not. Among all
the possible loops, you need to find the lexicographically biggest string
after cutting the loop, which will make the looped string into a regular one.

Specifically, to find the lexicographically biggest string, you need to
experience two phases:

  1. Concatenate all the strings into a loop, where you can reverse some strings or not and connect them in the same order as given.
  2. Cut and make one breakpoint in any place of the loop, which will make the looped string into a regular one starting from the character at the cutpoint.



And your job is to find the lexicographically biggest one among all the
possible regular strings.

Example:



    Input: "abc", "xyz"Output: "zyxcba"Explanation: You can get the looped string "-abcxyz-", "-abczyx-", "-cbaxyz-", "-cbazyx-",
    where '-' represents the looped status.
    The answer string came from the fourth looped one,
    where you could cut from the middle character 'a' and get "zyxcba".



Note:

  1. The input strings will only contain lowercase letters.
  2. The total length of all the strings will not over 1,000.










## 556 - Next Greater Element III
~2~  ['String']
Given a positive 32-bit integer n, you need to find the smallest 32-bit integer which has exactly the same digits existing in the integer n and is greater in value than n. If no such positive 32-bit integer exists, you need to return -1.

Example 1:

Input: 12
Output: 21



Example 2:

Input: 21
Output: -1










## 557 - Reverse Words in a String III
~1~  ['String']
Given a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.

Example 1:

Input: "Let's take LeetCode contest"
Output: "s'teL ekat edoCteeL tsetnoc"



Note:
In the string, each word is separated by single space and there will not be any extra space in the string.










## 560 - Subarray Sum Equals K
~2~  ['Array', 'Map']
Given an array of integers and an integer k, you need to find the total number of continuous subarrays whose sum equals to k.

Example 1:

Input:nums = [1,1,1], k = 2
Output: 2



Note:

The length of the array is in range [1, 20,000].
The range of numbers in the array is [-1000, 1000] and the range of the integer k is [-1e7, 1e7].










## 561 - Array Partition I
~1~  ['Array']
Given an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), ..., (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.


Example 1:

Input: [1,4,3,2]

Output: 4
Explanation: n is 2, and the maximum sum of pairs is 4 = min(1, 2) + min(3, 4).



Note:

n is a positive integer, which is in the range of [1, 10000].
All the integers in the array will be in the range of [-10000, 10000].










## 562 - Longest Line of Consecutive One in Matrix
~2~  []
Given a 01 matrix M, find the longest line of consecutive one in the matrix.
The line could be horizontal, vertical, diagonal or anti-diagonal.

Example:



    Input:[[0,1,1,0], [0,1,1,0], [0,0,0,1]]Output: 3



Hint: The number of elements in the given matrix will not exceed 10,000.










## 563 - Binary Tree Tilt
~1~  ['Tree']
Given a binary tree, return the tilt of the whole tree.

The tilt of a tree node is defined as the absolute difference between the sum of all left subtree node values and the sum of all right subtree node values. Null node has tilt 0.

The tilt of the whole tree is defined as the sum of all nodes' tilt.

Example:

Input: 
         1
       /   \
      2     3
Output: 1
Explanation: 
Tilt of node 2 : 0
Tilt of node 3 : 0
Tilt of node 1 : |2-3| = 1
Tilt of binary tree : 0 + 0 + 1 = 1



Note:

The sum of node values in any subtree won't exceed the range of 32-bit integer. 
All the tilt values won't exceed the range of 32-bit integer.










## 564 - Find the Closest Palindrome
~3~  ['String']
Given an integer n, find the closest integer (not including itself), which is a palindrome. 

The 'closest' is defined as absolute difference minimized between two integers.

Example 1:

Input: "123"
Output: "121"



Note:

The input n is a positive integer represented by string, whose length will not exceed 18.
If there is a tie, return the smaller one as answer.










## 565 - Array Nesting
~2~  []
A zero-indexed array A of length N contains all integers from 0 to N-1. Find and return the longest length of set S, where S[i] = {A[i], A[A[i]], A[A[A[i]]], ... } subjected to the rule below.

Suppose the first element in S starts with the selection of element A[i] of index = i, the next element in S should be A[A[i]], and then A[A[A[i]]]… By that analogy, we stop adding right before a duplicate element occurs in S.

Example 1:

Input: A = [5,4,0,3,1,6,2]
Output: 4
Explanation: 
A[0] = 5, A[1] = 4, A[2] = 0, A[3] = 3, A[4] = 1, A[5] = 6, A[6] = 2.

One of the longest S[K]:
S[0] = {A[0], A[5], A[6], A[2]} = {5, 6, 2, 0}



Note:

N is an integer within the range [1, 20,000].
The elements of A are all distinct.
Each element of A is an integer within the range [0, N-1].










## 566 - Reshape the Matrix
~1~  ['Array']
In MATLAB, there is a very useful function called 'reshape', which can reshape a matrix into a new one with different size but keep its original data.



You're given a matrix represented by a two-dimensional array, and two positive integers r and c representing the row number and column number of the wanted reshaped matrix, respectively.

 The reshaped matrix need to be filled with all the elements of the original matrix in the same row-traversing order as they were.



If the 'reshape' operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix.


Example 1:

Input: 
nums = 
[[1,2],
 [3,4]]
r = 1, c = 4
Output: 
[[1,2,3,4]]
Explanation:The row-traversing of nums is [1,2,3,4]. The new reshaped matrix is a 1 * 4 matrix, fill it row by row by using the previous list.



Example 2:

Input: 
nums = 
[[1,2],
 [3,4]]
r = 2, c = 4
Output: 
[[1,2],
 [3,4]]
Explanation:There is no way to reshape a 2 * 2 matrix to a 2 * 4 matrix. So output the original matrix.



Note:

The height and width of the given matrix is in range [1, 100].
The given r and c are all positive.










## 567 - Permutation in String
~2~  ['Two Pointers']
Given two strings s1 and s2, write a function to return true if s2 contains the permutation of s1. In other words, one of the first string's permutations is the substring of the second string.

Example 1:

Input:s1 = "ab" s2 = "eidbaooo"
Output:True
Explanation: s2 contains one permutation of s1 ("ba").



Example 2:

Input:s1= "ab" s2 = "eidboaoo"
Output: False



Note:

The input strings only contain lower case letters.
The length of both given strings is in range [1, 10,000].










## 568 - Maximum Vacation Days
~3~  []
LeetCode wants to give one of its best employees the option to travel among N
cities to collect algorithm problems. But all work and no play makes Jack a
dull boy, you could take vacations in some particular cities and weeks. Your
job is to schedule the traveling to maximize the number of vacation days you
could take, but there are certain rules and restrictions you need to follow.

Rules and restrictions:

  1. You can only travel among N cities, represented by indexes from 0 to N-1. Initially, you are in the city indexed 0 on Monday.
  2. The cities are connected by flights. The flights are represented as a N*N matrix (not necessary symmetrical), called flights representing the airline status from the city i to the city j. If there is no flight from the city i to the city j, flights[i][j] = 0; Otherwise, flights[i][j] = 1. Also, flights[i][i] = 0 for all i.
  3. You totally have K weeks (each week has 7 days) to travel. You can only take flights at most once per day and can only take flights on each week's Monday morning. Since flight time is so short, we don't consider the impact of flight time.
  4. For each city, you can only have restricted vacation days in different weeks, given an N*K matrix called days representing this relationship. For the value of days[i][j], it represents the maximum days you could take vacation in the city i in the week j.



You're given the flights matrix and days matrix, and you need to output the
maximum vacation days you could take during K weeks.

Example 1:



    Input:flights = [[0,1,1],[1,0,1],[1,1,0]], days = [[1,3,1],[6,0,3],[3,3,3]]Output: 12Explanation:
    Ans = 6 + 3 + 3 = 12.
    One of the best strategies is:1st week : fly from city 0 to city 1 on Monday, and play 6 days and work 1 day.
    (Although you start at city 0, we could also fly to and start at other cities since it is Monday.) 2nd week : fly from city 1 to city 2 on Monday, and play 3 days and work 4 days.3rd week : stay at city 2, and play 3 days and work 4 days.



Example 2:



    Input:flights = [[0,0,0],[0,0,0],[0,0,0]], days = [[1,1,1],[7,7,7],[7,7,7]]Output: 3Explanation:
    Ans = 1 + 1 + 1 = 3.
    Since there is no flights enable you to move to another city, you have to stay at city 0 for the whole 3 weeks.
    For each week, you only have one day to play and six days to work.
    So the maximum number of vacation days is 3.



Example 3:



    Input:flights = [[0,1,1],[1,0,1],[1,1,0]], days = [[7,0,0],[0,7,0],[0,0,7]]Output: 21Explanation:
    Ans = 7 + 7 + 7 = 21
    One of the best strategies is:1st week : stay at city 0, and play 7 days. 2nd week : fly from city 0 to city 1 on Monday, and play 7 days.3rd week : fly from city 1 to city 2 on Monday, and play 7 days.



Note:

  1. N and K are positive integers, which are in the range of [1, 100].
  2. In the matrix flights, all the values are integers in the range of [0, 1].
  3. In the matrix days, all the values are integers in the range [0, 7].
  4. You could stay at a city beyond the number of vacation days, but you should work on the extra days, which won't be counted as vacation days.
  5. If you fly from the city A to the city B and take the vacation on that day, the deduction towards vacation days will count towards the vacation days of city B in that week.
  6. We don't consider the impact of flight hours towards the calculation of vacation days.










## 569 - Median Employee Salary
~3~  []
LeetCode wants to give one of its best employees the option to travel among N
cities to collect algorithm problems. But all work and no play makes Jack a
dull boy, you could take vacations in some particular cities and weeks. Your
job is to schedule the traveling to maximize the number of vacation days you
could take, but there are certain rules and restrictions you need to follow.

Rules and restrictions:

  1. You can only travel among N cities, represented by indexes from 0 to N-1. Initially, you are in the city indexed 0 on Monday.
  2. The cities are connected by flights. The flights are represented as a N*N matrix (not necessary symmetrical), called flights representing the airline status from the city i to the city j. If there is no flight from the city i to the city j, flights[i][j] = 0; Otherwise, flights[i][j] = 1. Also, flights[i][i] = 0 for all i.
  3. You totally have K weeks (each week has 7 days) to travel. You can only take flights at most once per day and can only take flights on each week's Monday morning. Since flight time is so short, we don't consider the impact of flight time.
  4. For each city, you can only have restricted vacation days in different weeks, given an N*K matrix called days representing this relationship. For the value of days[i][j], it represents the maximum days you could take vacation in the city i in the week j.



You're given the flights matrix and days matrix, and you need to output the
maximum vacation days you could take during K weeks.

Example 1:



    Input:flights = [[0,1,1],[1,0,1],[1,1,0]], days = [[1,3,1],[6,0,3],[3,3,3]]Output: 12Explanation:
    Ans = 6 + 3 + 3 = 12.
    One of the best strategies is:1st week : fly from city 0 to city 1 on Monday, and play 6 days and work 1 day.
    (Although you start at city 0, we could also fly to and start at other cities since it is Monday.) 2nd week : fly from city 1 to city 2 on Monday, and play 3 days and work 4 days.3rd week : stay at city 2, and play 3 days and work 4 days.



Example 2:



    Input:flights = [[0,0,0],[0,0,0],[0,0,0]], days = [[1,1,1],[7,7,7],[7,7,7]]Output: 3Explanation:
    Ans = 1 + 1 + 1 = 3.
    Since there is no flights enable you to move to another city, you have to stay at city 0 for the whole 3 weeks.
    For each week, you only have one day to play and six days to work.
    So the maximum number of vacation days is 3.



Example 3:



    Input:flights = [[0,1,1],[1,0,1],[1,1,0]], days = [[7,0,0],[0,7,0],[0,0,7]]Output: 21Explanation:
    Ans = 7 + 7 + 7 = 21
    One of the best strategies is:1st week : stay at city 0, and play 7 days. 2nd week : fly from city 0 to city 1 on Monday, and play 7 days.3rd week : fly from city 1 to city 2 on Monday, and play 7 days.



Note:

  1. N and K are positive integers, which are in the range of [1, 100].
  2. In the matrix flights, all the values are integers in the range of [0, 1].
  3. In the matrix days, all the values are integers in the range [0, 7].
  4. You could stay at a city beyond the number of vacation days, but you should work on the extra days, which won't be counted as vacation days.
  5. If you fly from the city A to the city B and take the vacation on that day, the deduction towards vacation days will count towards the vacation days of city B in that week.
  6. We don't consider the impact of flight hours towards the calculation of vacation days.










## 572 - Subtree of Another Tree
~1~  ['Tree']
Given two non-empty binary trees s and t, check whether tree t has exactly the same structure and node values with a subtree of s. A subtree of s is a tree consists of a node in s and all of this node's descendants. The tree s could also be considered as a subtree of itself.


Example 1:

Given tree s:

     3
    / \
   4   5
  / \
 1   2

Given tree t:

   4 
  / \
 1   2

Return true, because t has the same structure and node values with a subtree of s.


Example 2:

Given tree s:

     3
    / \
   4   5
  / \
 1   2
    /
   0

Given tree t:

   4
  / \
 1   2

Return false.










## 573 - Squirrel Simulation
~2~  []
There's a tree, a squirrel, and several nuts. Positions are represented by the
cells in a 2D grid. Your goal is to find the minimal distance for the squirrel
to collect all the nuts and put them under the tree one by one. The squirrel
can only take at most one nut at one time and can move in four directions -
up, down, left and right, to the adjacent cell. The distance is represented by
the number of moves.

Example 1:



    Input: Height : 5Width : 7Tree position : [2,2]Squirrel : [4,4]Nuts : [[3,0], [2,5]]Output: 12Explanation:

![](https://leetcode.com/static/images/problemset/squirrel_simulation.png)



Note:

  1. All given positions won't overlap.
  2. The squirrel can take at most one nut at one time.
  3. The given positions of nuts have no order.
  4. Height and width are positive integers. 3 <= height * width <= 10,000.
  5. The given positions contain at least one nut, only one tree and one squirrel.










## 574 - Winning Candidate
~2~  []
There's a tree, a squirrel, and several nuts. Positions are represented by the
cells in a 2D grid. Your goal is to find the minimal distance for the squirrel
to collect all the nuts and put them under the tree one by one. The squirrel
can only take at most one nut at one time and can move in four directions -
up, down, left and right, to the adjacent cell. The distance is represented by
the number of moves.

Example 1:



    Input: Height : 5Width : 7Tree position : [2,2]Squirrel : [4,4]Nuts : [[3,0], [2,5]]Output: 12Explanation:

![](https://leetcode.com/static/images/problemset/squirrel_simulation.png)



Note:

  1. All given positions won't overlap.
  2. The squirrel can take at most one nut at one time.
  3. The given positions of nuts have no order.
  4. Height and width are positive integers. 3 <= height * width <= 10,000.
  5. The given positions contain at least one nut, only one tree and one squirrel.










## 575 - Distribute Candies
~1~  ['Hash Table']
Given an integer array with even length, where different numbers in this array represent different kinds of candies. Each number means one candy of the corresponding kind. You need to distribute these candies equally in number to brother and sister. Return the maximum number of kinds of candies the sister could gain. 

Example 1:

Input: candies = [1,1,2,2,3,3]
Output: 3
Explanation:
There are three different kinds of candies (1, 2 and 3), and two candies for each kind.
Optimal distribution: The sister has candies [1,2,3] and the brother has candies [1,2,3], too. 
The sister has three different kinds of candies. 



Example 2:

Input: candies = [1,1,2,3]
Output: 2
Explanation: For example, the sister has candies [2,3] and the brother has candies [1,1]. 
The sister has two different kinds of candies, the brother has only one kind of candies. 



Note:

The length of the given array is in range [2, 10,000], and will be even.
The number in given array is in range [-100,000, 100,000].










## 576 - Out of Boundary Paths
~2~  ['Dynamic Programming', 'Depth-first Search']
There is an m by n grid with a ball. Given the start coordinate (i,j) of the ball, you can move the ball to adjacent cell or cross the grid boundary in four directions (up, down, left, right). However, you can at most move N times. Find out the number of paths to move the ball out of grid boundary. The answer may be very large, return it after mod 109 + 7.

Example 1:

Input:m = 2, n = 2, N = 2, i = 0, j = 0
Output: 6
Explanation:




Example 2:

Input:m = 1, n = 3, N = 3, i = 0, j = 1
Output: 12
Explanation:




Note:

Once you move the ball out of boundary, you cannot move it back.
The length and height of the grid is in range [1,50].
N is in range [0,50].










## 581 - Shortest Unsorted Continuous Subarray
~1~  ['Array']
Given an integer array, you need to find one continuous subarray that if you only sort this subarray in ascending order, then the whole array will be sorted in ascending order, too.  

You need to find the shortest such subarray and output its length.

Example 1:

Input: [2, 6, 4, 8, 10, 9, 15]
Output: 5
Explanation: You need to sort [6, 4, 8, 10, 9] in ascending order to make the whole array sorted in ascending order.



Note:

Then length of the input array is in range [1, 10,000].
The input array may contain duplicates, so ascending order here means <=.










## 582 - Kill Process
~2~  []
Given n processes, each process has a unique PID (process id) and its PPID
(parent process id).

Each process only has one parent process, but may have one or more children
processes. This is just like a tree structure. Only one process has PPID that
is 0, which means this process has no parent process. All the PIDs will be
distinct positive integers.

We use two list of integers to represent a list of processes, where the first
list contains PID for each process and the second list contains the
corresponding PPID.

Now given the two lists, and a PID representing a process you want to kill,
return a list of PIDs of processes that will be killed in the end. You should
assume that when a process is killed, all its children processes will be
killed. No order is required for the final answer.

Example 1:



    Input: pid =  [1, 3, 10, 5]ppid = [3, 0, 5, 3]kill = 5Output: [5,10]Explanation:            3         /   \        1     5             /            10Kill 5 will also kill 10.



Note:

  1. The given kill id is guaranteed to be one of the given PIDs.
  2. n >= 1.










## 583 - Delete Operation for Two Strings
~2~  ['String']
Given two words word1 and word2, find the minimum number of steps required to make word1 and word2 the same, where in each step you can delete one character in either string.


Example 1:

Input: "sea", "eat"
Output: 2
Explanation: You need one step to make "sea" to "ea" and another step to make "eat" to "ea".



Note:

The length of given words won't exceed 500.
Characters in given words can only be lower-case letters.










## 587 - Erect the Fence
~3~  ['Geometry']
There are some trees, where each tree is represented by (x,y) coordinate in a two-dimensional garden. Your job is to fence the entire garden using the minimum length of rope as it is expensive. The garden is well fenced only if all the trees are enclosed. Your task is to help find the coordinates of trees which are exactly located on the fence perimeter.

Example 1:

Input: [[1,1],[2,2],[2,0],[2,4],[3,3],[4,2]]
Output: [[1,1],[2,0],[4,2],[3,3],[2,4]]
Explanation:




Example 2:

Input: [[1,2],[2,2],[4,2]]
Output: [[1,2],[2,2],[4,2]]
Explanation:

Even you only have trees in a line, you need to use rope to enclose them. 



 Note: 

All trees should be enclosed together. You cannot cut the rope to enclose trees that will separate them in more than one group.
All input integers will range from 0 to 100. 
The garden has at least one tree. 
All coordinates are distinct. 
Input points have NO order. No order required for output.










## 588 - Design In-Memory File System
~3~  []
Design an in-memory file system to simulate the following functions:

`ls`: Given a path in string format. If it is a file path, return a list that
only contains this file's name. If it is a directory path, return the list of
file and directory names in this directory. Your output (file and directory
names together) should in lexicographic order.

`mkdir`: Given a directory path that does not exist, you should make a new
directory according to the path. If the middle directories in the path don't
exist either, you should create them as well. This function has void return
type.

`addContentToFile`: Given a file path and file content in string format. If
the file doesn't exist, you need to create that file containing given content.
If the file already exists, you need to append given content to original
content. This function has void return type.

`readContentFromFile`: Given a file path, return its content in string format.

Example:



    Input: ["FileSystem","ls","mkdir","addContentToFile","ls","readContentFromFile"][[],["/"],["/a/b/c"],["/a/b/c/d","hello"],["/"],["/a/b/c/d"]]Output:[null,[],null,null,["a"],"hello"]Explanation:

![filesystem](https://leetcode.com/static/images/problemset/filesystem.png)



Note:

  1. You can assume all file or directory paths are absolute paths which begin with `/` and do not end with `/`except that the path is just `"/"`.
  2. You can assume that all operations will be passed valid parameters and users will not attempt to retrieve file content or list a directory or file that does not exist.
  3. You can assume that all directory names and file names only contain lower-case letters, and same names won't exist in the same directory.










## 591 - Tag Validator
~3~  ['String', 'Stack']
Given a string representing a code snippet, you need to implement a tag validator to parse the code and return whether it is valid. A code snippet is valid if all the following rules hold:

The code must be wrapped in a valid closed tag. Otherwise, the code is invalid.
A closed tag (not necessarily valid) has exactly the following format : <TAG_NAME>TAG_CONTENT</TAG_NAME>. Among them, <TAG_NAME> is the start tag, and </TAG_NAME> is the end tag. The TAG_NAME in start and end tags should be the same. A closed tag is valid if and only if the TAG_NAME and TAG_CONTENT are valid.
A valid TAG_NAME only contain upper-case letters, and has length in range [1,9]. Otherwise, the TAG_NAME is invalid.
A valid TAG_CONTENT may contain other valid closed tags, cdata and any characters (see note1) EXCEPT unmatched <, unmatched start and end tag, and unmatched or closed tags with invalid TAG_NAME. Otherwise, the TAG_CONTENT is invalid.
A start tag is unmatched if no end tag exists with the same TAG_NAME, and vice versa. However, you also need to consider the issue of unbalanced when tags are nested.
A < is unmatched if you cannot find a subsequent >. And when you find a < or </, all the subsequent characters until the next > should be parsed as TAG_NAME  (not necessarily valid).
The cdata has the following format : <![CDATA[CDATA_CONTENT]]>. The range of CDATA_CONTENT is defined as the characters between <![CDATA[ and the first subsequent ]]>. 
CDATA_CONTENT may contain any characters. The function of cdata is to forbid the validator to parse CDATA_CONTENT, so even it has some characters that can be parsed as tag (no matter valid or invalid), you should treat it as regular characters. 


Valid Code Examples:

Input: "<DIV>This is the first line <![CDATA[<div>]]></DIV>"
Output: True
Explanation: 
The code is wrapped in a closed tag : <DIV> and </DIV>. 
The TAG_NAME is valid, the TAG_CONTENT consists of some characters and cdata. 
Although CDATA_CONTENT has unmatched start tag with invalid TAG_NAME, it should be considered as plain text, not parsed as tag.
So TAG_CONTENT is valid, and then the code is valid. Thus return true.

Input: "<DIV>>>  ![cdata[]] <![CDATA[<div>]>]]>]]>>]</DIV>"
Output: True
Explanation:
We first separate the code into : start_tag|tag_content|end_tag.
start_tag -> "<DIV>"
end_tag -> "</DIV>"
tag_content could also be separated into : text1|cdata|text2.
text1 -> ">>  ![cdata[]] "
cdata -> "<![CDATA[<div>]>]]>", where the CDATA_CONTENT is "<div>]>"
text2 -> "]]>>]"

The reason why start_tag is NOT "<DIV>>>" is because of the rule 6.
The reason why cdata is NOT "<![CDATA[<div>]>]]>]]>" is because of the rule 7.



Invalid Code Examples:

Input: "<A>  <B> </A>   </B>"
Output: False
Explanation: Unbalanced. If "<A>" is closed, then "<B>" must be unmatched, and vice versa.

Input: "<DIV>  div tag is not closed  <DIV>"
Output: False

Input: "<DIV>  unmatched <  </DIV>"
Output: False

Input: "<DIV> closed tags with invalid tag name  <b>123</b> </DIV>"
Output: False

Input: "<DIV> unmatched tags with invalid tag name  </1234567890> and <CDATA[[]]>  </DIV>"
Output: False

Input: "<DIV>  unmatched start tag <B>  and unmatched end tag </C>  </DIV>"
Output: False



Note:

For simplicity, you could assume the input code (including the any characters mentioned above) only contain letters, digits, '<','>','/','!','[',']' and ' '.










## 592 - Fraction Addition and Subtraction
~2~  ['Math']
Given a string representing an expression of fraction addition and subtraction, you need to return the calculation result in string format. The final result should be irreducible fraction. If your final result is an integer, say 2, you need to change it to the format of fraction that has denominator 1. So in this case, 2 should be converted to 2/1.

Example 1:

Input:"-1/2+1/2"
Output: "0/1"



Example 2:

Input:"-1/2+1/2+1/3"
Output: "1/3"



Example 3:

Input:"1/3-1/2"
Output: "-1/6"



Example 4:

Input:"5/3+1/3"
Output: "2/1"



Note:

The input string only contains '0' to '9', '/', '+' and '-'. So does the output.
Each fraction (input and output) has format ±numerator/denominator. If the first input fraction or the output is positive, then '+' will be omitted.
The input only contains valid irreducible fractions, where the numerator and denominator of each fraction will always be in the range [1,10]. If the denominator is 1, it means this fraction is actually an integer in a fraction format defined above. 
The number of given fractions will be in the range [1,10].
The numerator and denominator of the final result are guaranteed to be valid and in the range of 32-bit int.










## 593 - Valid Square
~2~  ['Math']
Given the coordinates of four points in 2D space, return whether the four points could construct a square.

The coordinate (x,y) of a point is represented by an integer array with two integers.

Example:

Input: p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,1]
Output: True



 Note: 

All the input integers are in the range [-10000, 10000].
A valid square has four equal sides with positive length and four equal angles (90-degree angles).
Input points have no order.










## 594 - Longest Harmonious Subsequence
~1~  ['Hash Table']
We define a harmonious array is an array where the difference between its maximum value and its minimum value is exactly 1.

Now, given an integer array, you need to find the length of its longest harmonious subsequence among all its possible subsequences.

Example 1:

Input: [1,3,2,2,5,2,3,7]
Output: 5
Explanation: The longest harmonious subsequence is [3,2,2,2,3].



Note:
The length of the input array will not exceed 20,000.










## 595 - Big Countries
~1~  []
There is a table World 

+-----------------+------------+------------+--------------+---------------+
| name            | continent  | area       | population   | gdp           |
+-----------------+------------+------------+--------------+---------------+
| Afghanistan     | Asia       | 652230     | 25500100     | 20343000      |
| Albania         | Europe     | 28748      | 2831741      | 12960000      |
| Algeria         | Africa     | 2381741    | 37100000     | 188681000     |
| Andorra         | Europe     | 468        | 78115        | 3712000       |
| Angola          | Africa     | 1246700    | 20609294     | 100990000     |
+-----------------+------------+------------+--------------+---------------+


A country is big if it has an area of bigger than 3 million square km or a population of more than 25 million.

Write a SQL solution to output big countries' name, population and area.


For example, according to the above table, we should output:

+--------------+-------------+--------------+
| name         | population  | area         |
+--------------+-------------+--------------+
| Afghanistan  | 25500100    | 652230       |
| Algeria      | 37100000    | 2381741      |
+--------------+-------------+--------------+










## 596 - Classes More Than 5 Students
~1~  []
There is a table courses with columns: student and class

Please list out all classes which have more than or equal to 5 students.


For example, the table:


+---------+------------+
| student | class      |
+---------+------------+
| A       | Math       |
| B       | English    |
| C       | Math       |
| D       | Biology    |
| E       | Math       |
| F       | Computer   |
| G       | Math       |
| H       | Math       |
| I       | Math       |
+---------+------------+


Should output:

+---------+
| class   |
+---------+
| Math    |
+---------+



Note:
The students should not be counted duplicate in each course.










## 598 - Range Addition II
~1~  ['Math']
Given an m * n matrix M initialized with all 0's and several update operations.
Operations are represented by a 2D array, and each operation is represented by an array with two positive integers a and b, which means M[i][j] should be added by one for all 0 <= i < a and 0 <= j < b. 
You need to count and return the number of maximum integers in the matrix after performing all the operations.

Example 1:

Input: 
m = 3, n = 3
operations = [[2,2],[3,3]]
Output: 4
Explanation: 
Initially, M = 
[[0, 0, 0],
 [0, 0, 0],
 [0, 0, 0]]

After performing [2,2], M = 
[[1, 1, 0],
 [1, 1, 0],
 [0, 0, 0]]

After performing [3,3], M = 
[[2, 2, 1],
 [2, 2, 1],
 [1, 1, 1]]

So the maximum integer in M is 2, and there are four of it in M. So return 4.



Note:

The range of m and n is [1,40000].
The range of a is [1,m], and the range of b is [1,n].
The range of operations size won't exceed 10,000.










## 599 - Minimum Index Sum of Two Lists
~1~  ['Hash Table']
Suppose Andy and Doris want to choose a restaurant for dinner, and they both have a list of favorite restaurants represented by strings. 


You need to help them find out their common interest with the least list index sum. If there is a choice tie between answers, output all of them with no order requirement. You could assume there always exists an answer.



Example 1:

Input:
["Shogun", "Tapioca Express", "Burger King", "KFC"]
["Piatti", "The Grill at Torrey Pines", "Hungry Hunter Steakhouse", "Shogun"]
Output: ["Shogun"]
Explanation: The only restaurant they both like is "Shogun".



Example 2:

Input:
["Shogun", "Tapioca Express", "Burger King", "KFC"]
["KFC", "Shogun", "Burger King"]
Output: ["Shogun"]
Explanation: The restaurant they both like and have the least index sum is "Shogun" with index sum 1 (0+1).




Note:

The length of both lists will be in the range of [1, 1000].
The length of strings in both lists will be in the range of [1, 30].
The index is starting from 0 to the list length minus 1.
No duplicates in both lists.










## 600 - Non-negative Integers without Consecutive Ones
~3~  ['Dynamic Programming']
Given a positive integer n, find the number of non-negative integers less than or equal to n, whose binary representations do NOT contain consecutive ones.

Example 1:

Input: 5
Output: 5
Explanation: 
Here are the non-negative integers <= 5 with their corresponding binary representations:
0 : 0
1 : 1
2 : 10
3 : 11
4 : 100
5 : 101
Among them, only integer 3 disobeys the rule (two consecutive ones) and the other 5 satisfy the rule. 



Note:
1 <= n <= 109










## 601 - Human Traffic of Stadium
~3~  []
X city built a new stadium, each day many people visit it and the stats are saved as these columns: id, date, people

Please write a query to display the records which have 3 or more consecutive rows and the  amount of people more than 100(inclusive).

 
For example, the table stadium:

+------+------------+-----------+
| id   | date       | people    |
+------+------------+-----------+
| 1    | 2017-01-01 | 10        |
| 2    | 2017-01-02 | 109       |
| 3    | 2017-01-03 | 150       |
| 4    | 2017-01-04 | 99        |
| 5    | 2017-01-05 | 145       |
| 6    | 2017-01-06 | 1455      |
| 7    | 2017-01-07 | 199       |
| 8    | 2017-01-08 | 188       |
+------+------------+-----------+


For the sample data above, the output is:


+------+------------+-----------+
| id   | date       | people    |
+------+------------+-----------+
| 5    | 2017-01-05 | 145       |
| 6    | 2017-01-06 | 1455      |
| 7    | 2017-01-07 | 199       |
| 8    | 2017-01-08 | 188       |
+------+------------+-----------+


Note:
Each day only have one row record, and the dates are increasing with id increasing.










## 604 - Design Compressed String Iterator
~1~  []
Design and implement a data structure for a compressed string iterator. It
should support the following operations: `next` and `hasNext`.

The given compressed string will be in the form of each letter followed by a
positive integer representing the number of this letter existing in the
original uncompressed string.

`next()` \- if the original string still has uncompressed characters, return
the next letter; Otherwise return a white space.
`hasNext()` \- Judge whether there is any letter needs to be uncompressed.

Note:
Please remember to RESET your class variables declared in StringIterator, as
static/class variables are persisted across multiple test cases. Please see
[here](https://leetcode.com/faq/#different-output) for more details.

Example:



    StringIterator iterator = new StringIterator("L1e2t1C1o1d1e1");iterator.next(); // return 'L'iterator.next(); // return 'e'iterator.next(); // return 'e'iterator.next(); // return 't'iterator.next(); // return 'C'iterator.next(); // return 'o'iterator.next(); // return 'd'iterator.hasNext(); // return trueiterator.next(); // return 'e'iterator.hasNext(); // return falseiterator.next(); // return ' '










## 605 - Can Place Flowers
~1~  ['Array']
Suppose you have a long flowerbed in which some of the plots are planted and some are not. However, flowers cannot be planted in adjacent plots - they would compete for water and both would die.

Given a flowerbed (represented as an array containing 0 and 1, where 0 means empty and 1 means not empty), and a number n, return if n new flowers can be planted in it without violating the no-adjacent-flowers rule.

Example 1:

Input: flowerbed = [1,0,0,0,1], n = 1
Output: True



Example 2:

Input: flowerbed = [1,0,0,0,1], n = 2
Output: False



Note:

The input array won't violate no-adjacent-flowers rule.
The input array size is in the range of [1, 20000].
n is a non-negative integer which won't exceed the input array size.










## 606 - Construct String from Binary Tree
~1~  ['String', 'Tree']
You need to construct a string consists of parenthesis and integers from a binary tree with the preorder traversing way.

The null node needs to be represented by empty parenthesis pair "()". And you need to omit all the empty parenthesis pairs that don't affect the one-to-one mapping relationship between the string and the original binary tree.

Example 1:

Input: Binary tree: [1,2,3,4]
       1
     /   \
    2     3
   /    
  4     

Output: "1(2(4))(3)"
Explanation: Originallay it needs to be "1(2(4)())(3()())", but you need to omit all the unnecessary empty parenthesis pairs. And it will be "1(2(4))(3)".



Example 2:

Input: Binary tree: [1,2,3,null,4]
       1
     /   \
    2     3
     \  
      4 

Output: "1(2()(4))(3)"
Explanation: Almost the same as the first example, except we can't omit the first parenthesis pair to break the one-to-one mapping relationship between the input and the output.










## 607 - Sales Person
~1~  []
You need to construct a string consists of parenthesis and integers from a
binary tree with the preorder traversing way.

The null node needs to be represented by empty parenthesis pair "()". And you
need to omit all the empty parenthesis pairs that don't affect the one-to-one
mapping relationship between the string and the original binary tree.

Example 1:



    Input: Binary tree: [1,2,3,4]       1     /   \    2     3   /      4     Output: "1(2(4))(3)"
    Explanation: Originallay it needs to be "1(2(4)())(3()())",
    but you need to omit all the unnecessary empty parenthesis pairs.
    And it will be "1(2(4))(3)".



Example 2:



    Input: Binary tree: [1,2,3,null,4]       1     /   \    2     3     \        4 Output: "1(2()(4))(3)"
    Explanation: Almost the same as the first example,
    except we can't omit the first parenthesis pair to break the one-to-one mapping relationship between the input and the output.










## 609 - Find Duplicate File in System
~2~  ['Hash Table', 'String']
Given a list of directory info including directory path, and all the files with contents in this directory, you need to find out all the groups of duplicate files in the file system in terms of their paths.

A group of duplicate files consists of at least two files that have exactly the same content.

A single directory info string in the input list has the following format: 
"root/d1/d2/.../dm f1.txt(f1_content) f2.txt(f2_content) ... fn.txt(fn_content)"
It means there are n files (f1.txt, f2.txt ... fn.txt with content f1_content, f2_content ... fn_content, respectively) in directory root/d1/d2/.../dm. Note that n >= 1 and m >= 0. If m = 0, it means the directory is just the root directory.

The output is a list of group of duplicate file paths. For each group, it contains all the file paths of the files that have the same content. A file path is a string that has the following format: 
"directory_path/file_name.txt"


Example 1:

Input:
["root/a 1.txt(abcd) 2.txt(efgh)", "root/c 3.txt(abcd)", "root/c/d 4.txt(efgh)", "root 4.txt(efgh)"]
Output:  
[["root/a/2.txt","root/c/d/4.txt","root/4.txt"],["root/a/1.txt","root/c/3.txt"]]




Note:

No order is required for the final output.
You may assume the directory name, file name and file content only has letters and digits, and the length of file content is in the range of [1,50].
The number of files given is in the range of [1,20000].
You may assume no files or directories share the same name in the same directory.
You may assume each given directory info represents a unique directory. Directory path and file info are separated by a single blank space.




Follow-up beyond contest: 

 Imagine you are given a real file system, how will you search files? DFS or BFS?
 If the file content is very large (GB level), how will you modify your solution?
 If you can only read the file by 1kb each time, how will you modify your solution?
 What is the time complexity of your modified solution? What is the most time-consuming part and memory consuming part of it? How to optimize?
 How to make sure the duplicated files you find are not false positive?










## 611 - Valid Triangle Number
~2~  ['Array']
Given an array consists of non-negative integers,  your task is to count the number of triplets chosen from the array that can make triangles if we take them as side lengths of a triangle.

Example 1:

Input: [2,2,3,4]
Output: 3
Explanation:
Valid combinations are: 
2,3,4 (using the first 2)
2,3,4 (using the second 2)
2,2,3



Note:

The length of the given array won't exceed 1000.
The integers in the given array are in the range of [0, 1000].










## 616 - Add Bold Tag in String
~2~  []
Given a string s and a list of strings dict, you need to add a closed pair of
bold tag `<b>` and `</b>` to wrap the substrings in s that exist in dict. If
two such substrings overlap, you need to wrap them together by only one pair
of closed bold tag. Also, if two substrings wrapped by bold tags are
consecutive, you need to combine them.

Example 1:



    Input: s = "abcxyz123"dict = ["abc","123"]Output:"<b>abc</b>xyz<b>123</b>"



Example 2:



    Input: s = "aaabbcc"dict = ["aaa","aab","bc"]Output:"<b>aaabbc</b>c"



Note:

  1. The given dict won't contain duplicates, and its length won't exceed 100.
  2. All the strings in input have length in range [1, 1000].










## 617 - Merge Two Binary Trees
~1~  ['Tree']
Given two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. 


You need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of new tree.



Example 1:

Input: 
	Tree 1                     Tree 2                  
          1                         2                             
         / \                       / \                            
        3   2                     1   3                        
       /                           \   \                      
      5                             4   7                  
Output: 
Merged tree:
	     3
	    / \
	   4   5
	  / \   \ 
	 5   4   7




Note:
The merging process must start from the root nodes of both trees.










## 620 - Not Boring Movies
~1~  []
X city opened a new cinema, many people would like to go to this cinema.
The cinema also gives out a poster indicating the movies’ ratings and descriptions. 
 
Please write a SQL query to output movies with an odd numbered ID and a description that is not 'boring'. Order the result by rating.


For example, table cinema:

+---------+-----------+--------------+-----------+
|   id    | movie     |  description |  rating   |
+---------+-----------+--------------+-----------+
|   1     | War       |   great 3D   |   8.9     |
|   2     | Science   |   fiction    |   8.5     |
|   3     | irish     |   boring     |   6.2     |
|   4     | Ice song  |   Fantacy    |   8.6     |
|   5     | House card|   Interesting|   9.1     |
+---------+-----------+--------------+-----------+

For the example above, the output should be:

+---------+-----------+--------------+-----------+
|   id    | movie     |  description |  rating   |
+---------+-----------+--------------+-----------+
|   5     | House card|   Interesting|   9.1     |
|   1     | War       |   great 3D   |   8.9     |
+---------+-----------+--------------+-----------+










## 621 - Task Scheduler
~2~  ['Array', 'Greedy', 'Queue']
Given a char array representing tasks CPU need to do. It contains capital letters A to Z where different letters represent different tasks.Tasks could be done without original order. Each task could be done in one interval. For each interval, CPU could finish one task or just be idle.

However, there is a non-negative cooling interval n that means between two same tasks, there must be at least n intervals that CPU are doing different tasks or just be idle. 

You need to return the least number of intervals the CPU will take to finish all the given tasks.

Example 1:

Input: tasks = ["A","A","A","B","B","B"], n = 2
Output: 8
Explanation: A -> B -> idle -> A -> B -> idle -> A -> B.



Note:

The number of tasks is in the range [1, 10000].
The integer n is in the range [0, 100].










## 623 - Add One Row to Tree
~2~  ['Tree']
Given the root of a binary tree, then value v and depth d, you need to add a row of nodes with value v at the given depth d. The root node is at depth 1. 

The adding rule is: given a positive integer depth d, for each NOT null tree nodes N in depth d-1, create two tree nodes with value v as N's left subtree root and right subtree root. And N's original left subtree should be the left subtree of the new left subtree root, its original right subtree should be the right subtree of the new right subtree root. If depth d is 1 that means there is no depth d-1 at all, then create a tree node with value v as the new root of the whole original tree, and the original tree is the new root's left subtree.

Example 1:

Input: 
A binary tree as following:
       4
     /   \
    2     6
   / \   / 
  3   1 5   

v = 1

d = 2

Output: 
       4
      / \
     1   1
    /     \
   2       6
  / \     / 
 3   1   5   





Example 2:

Input: 
A binary tree as following:
      4
     /   
    2    
   / \   
  3   1    

v = 1

d = 3

Output: 
      4
     /   
    2
   / \    
  1   1
 /     \  
3       1



Note:

The given d is in range [1, maximum depth of the given tree + 1].
The given binary tree has at least one tree node.










## 624 - Maximum Distance in Arrays
~1~  []
Given `m` arrays, and each array is sorted in ascending order. Now you can
pick up two integers from two different arrays (each array picks one) and
calculate the distance. We define the distance between two integers `a` and
`b` to be their absolute difference `|a-b|`. Your task is to find the maximum
distance.

Example 1:



    Input: [[1,2,3], [4,5], [1,2,3]]Output: 4Explanation: One way to reach the maximum distance 4 is to pick 1 in the first or third array and pick 5 in the second array.



Note:

  1. Each given array will have at least 1 number. There will be at least two non-empty arrays.
  2. The total number of the integers in all the `m` arrays will be in the range of [2, 10000].
  3. The integers in the `m` arrays will be in the range of [-10000, 10000].










## 626 - Exchange Seats
~2~  []
Mary is a teacher in a middle school and she has a table seat storing students' names and their corresponding seat ids.
The column id is continuous increment.
Mary wants to change seats for the adjacent students.
Can you write a SQL query to output the result for Mary?

+---------+---------+
|    id   | student |
+---------+---------+
|    1    | Abbot   |
|    2    | Doris   |
|    3    | Emerson |
|    4    | Green   |
|    5    | Jeames  |
+---------+---------+

For the sample input, the output is:

+---------+---------+
|    id   | student |
+---------+---------+
|    1    | Doris   |
|    2    | Abbot   |
|    3    | Green   |
|    4    | Emerson |
|    5    | Jeames  |
+---------+---------+


Note:
If the number of students is odd, there is no need to change the last one's seat.










## 627 - Swap Salary
~1~  []
Given a table salary, such as the one below, that has m=male and  f=female values. Swap all f and m values (i.e., change all f values to m and vice versa) with a single update query and no intermediate temp table.
 
For example:
 

| id | name | sex | salary |
|----|------|-----|--------|
| 1  | A    | m   | 2500   |
| 2  | B    | f   | 1500   |
| 3  | C    | m   | 5500   |
| 4  | D    | f   | 500    |

After running your query, the above salary table should have the following rows:

| id | name | sex | salary |
|----|------|-----|--------|
| 1  | A    | f   | 2500   |
| 2  | B    | m   | 1500   |
| 3  | C    | f   | 5500   |
| 4  | D    | m   | 500    |










## 628 - Maximum Product of Three Numbers
~1~  ['Array', 'Math']
Given an integer array, find three numbers whose product is maximum and output the maximum product.

Example 1:

Input: [1,2,3]
Output: 6



Example 2:

Input: [1,2,3,4]
Output: 24



Note:

The length of the given array will be in range [3,104] and all elements are in the range [-1000, 1000].
Multiplication of any three numbers in the input won't exceed the range of 32-bit signed integer.










## 629 - K Inverse Pairs Array
~3~  ['Dynamic Programming']
Given two integers n and k, find how many different arrays consist of numbers from 1 to n such that there are exactly k inverse pairs. 


We define an inverse pair as following:
For ith and jth element in the array, if i < j and a[i] > a[j] then it's an inverse pair; Otherwise, it's not.



Since the answer may be very large, the answer should be modulo 109 + 7.


Example 1:

Input: n = 3, k = 0
Output: 1
Explanation: 
Only the array [1,2,3] which consists of numbers from 1 to 3 has exactly 0 inverse pair.



Example 2:

Input: n = 3, k = 1
Output: 2
Explanation: 
The array [1,3,2] and [2,1,3] have exactly 1 inverse pair.



Note:

The integer n is in the range [1, 1000] and k is in the range [0, 1000].










## 630 - Course Schedule III
~3~  ['Greedy']
There are n different online courses numbered from 1 to n. Each course has some duration(course length)  t and closed on dth day. A course should be taken continuously for t days and must be finished before or on the dth day. You will start at the 1st day.



Given n online courses represented by pairs (t,d), your task is to find the maximal number of courses that can be taken.



Example:

Input: [[100, 200], [200, 1300], [1000, 1250], [2000, 3200]]
Output: 3
Explanation: 
There're totally 4 courses, but you can take 3 courses at most:
First, take the 1st course, it costs 100 days so you will finish it on the 100th day, and ready to take the next course on the 101st day.
Second, take the 3rd course, it costs 1000 days so you will finish it on the 1100th day, and ready to take the next course on the 1101st day. 
Third, take the 2nd course, it costs 200 days so you will finish it on the 1300th day. 
The 4th course cannot be taken now, since you will finish it on the 3300th day, which exceeds the closed date.




Note:

The integer 1 <= d, t, n <= 10,000. 
You can't take two courses simultaneously.










## 631 - Design Excel Sum Formula
~3~  []
Your task is to design the basic function of Excel and implement the function
of sum formula. Specifically, you need to implement the following functions:

`Excel(int H, char W):` This is the constructor. The inputs represents the
height and width of the Excel form. His a positive integer, range from 1 to
26. It represents the height. W is a character range from 'A' to 'Z'. It
represents that the width is the number of characters from 'A' to W. The Excel
form content is represented by a height * width 2D integer array `C`, it
should be initialized to zero. You should assume that the first row of `C`
starts from 1, and the first column of `C` starts from 'A'.



`void Set(int row, char column, int val):` Change the value at `C(row,
column)` to be val.



`int Get(int row, char column):` Return the value at `C(row, column)`.



`int Sum(int row, char column, List of Strings : numbers):` This function
calculate and set the value at `C(row, column)`, where the value should be the
sum of cells represented by `numbers`. This function return the sum result at
`C(row, column)`. This sum formula should exist until this cell is overlapped
by another value or another sum formula.

`numbers` is a list of strings that each string represent a cell or a range of
cells. If the string represent a single cell, then it has the following format
: `ColRow`. For example, "F7" represents the cell at (7, F).

If the string represent a range of cells, then it has the following format :
`ColRow1:ColRow2`. The range will always be a rectangle, and ColRow1 represent
the position of the top-left cell, and ColRow2 represents the position of the
bottom-right cell.



Example 1:



    Excel(3,"C"); // construct a 3*3 2D array with all zero.//   A B C// 1 0 0 0// 2 0 0 0// 3 0 0 0Set(1, "A", 2);// set C(1,"A") to be 2.//   A B C// 1 2 0 0// 2 0 0 0// 3 0 0 0Sum(3, "C", ["A1", "A1:B2"]);// set C(3,"C") to be the sum of value at C(1,"A") and the values sum of the rectangle range whose top-left cell is C(1,"A") and bottom-right cell is C(2,"B"). Return 4. //   A B C// 1 2 0 0// 2 0 0 0// 3 0 0 4Set(2, "B", 2);// set C(2,"B") to be 2. Note C(3, "C") should also be changed.//   A B C// 1 2 0 0// 2 0 2 0// 3 0 0 6



Note:

  1. You could assume that there won't be any circular sum reference. For example, A1 = sum(B1) and B1 = sum(A1).
  2. The test cases are using double-quotes to represent a character.
  3. Please remember to RESET your class variables declared in class Excel, as static/class variables are persisted across multiple test cases. Please see [here](https://leetcode.com/faq/#different-output) for more details.










## 632 - Smallest Range
~3~  ['Hash Table', 'Two Pointers', 'String']
You have k lists of sorted integers in ascending order. Find the smallest range that includes at least one number from each of the k lists. 

We define the range [a,b] is smaller than range [c,d] if b-a < d-c or a < c if b-a == d-c.

Example 1:

Input:[[4,10,15,24,26], [0,9,12,20], [5,18,22,30]]
Output: [20,24]
Explanation: 
List 1: [4, 10, 15, 24,26], 24 is in range [20,24].
List 2: [0, 9, 12, 20], 20 is in range [20,24].
List 3: [5, 18, 22, 30], 22 is in range [20,24].




Note:

The given list may contain duplicates, so ascending order means >= here.
1 <= k <= 3500
 -105 <= value of elements <= 105.
For Java users, please note that the input type has been changed to List<List<Integer>>. And after you reset the code template, you'll see this point.










## 633 - Sum of Square Numbers
~1~  ['Math']
Given a non-negative integer c, your task is to decide whether there're two integers a and b such that a2 + b2 = c.


Example 1:

Input: 5
Output: True
Explanation: 1 * 1 + 2 * 2 = 5




Example 2:

Input: 3
Output: False










## 634 - Find the Derangement of An Array
~2~  []
In combinatorial mathematics, a derangement is a permutation of the elements
of a set, such that no element appears in its original position.

There's originally an array consisting of `n` integers from 1 to `n` in
ascending order, you need to find the number of derangement it can generate.

Also, since the answer may be very large, you should return the output mod 109
\+ 7.

Example 1:



    Input: 3Output: 2Explanation: The original array is [1,2,3]. The two derangements are [2,3,1] and [3,1,2].



Note:
`n` is in the range of [1, 106].










## 635 - Design Log Storage System
~2~  []
You are given several logs that each log contains a unique id and timestamp.
Timestamp is a string that has the following format:
`Year:Month:Day:Hour:Minute:Second`, for example, `2017:01:01:23:59:59`. All
domains are zero-padded decimal numbers.

Design a log storage system to implement the following functions:

`void Put(int id, string timestamp)`: Given a log's unique id and timestamp,
store the log in your storage system.



`int[] Retrieve(String start, String end, String granularity)`: Return the id
of logs whose timestamps are within the range from start to end. Start and end
all have the same format as timestamp. However, granularity means the time
level for consideration. For example, start = "2017:01:01:23:59:59", end =
"2017:01:02:23:59:59", granularity = "Day", it means that we need to find the
logs within the range from Jan. 1st 2017 to Jan. 2nd 2017.

Example 1:



    put(1, "2017:01:01:23:59:59");put(2, "2017:01:01:22:59:59");put(3, "2016:01:01:00:00:00");retrieve("2016:01:01:01:01:01","2017:01:01:23:00:00","Year"); // return [1,2,3], because you need to return all logs within 2016 and 2017.retrieve("2016:01:01:01:01:01","2017:01:01:23:00:00","Hour"); // return [1,2], because you need to return all logs start from 2016:01:01:01 to 2017:01:01:23, where log 3 is left outside the range.



Note:

  1. There will be at most 300 operations of Put or Retrieve.
  2. Year ranges from [2000,2017]. Hour ranges from [00,23].
  3. Output for Retrieve has no order required.










## 636 - Exclusive Time of Functions
~2~  ['Stack']
Given the running logs of n functions that are executed in a nonpreemptive single threaded CPU, find the exclusive time of these functions. 

Each function has a unique id, start from 0 to n-1. A function may be called recursively or by another function.

A log is a string has this format : function_id:start_or_end:timestamp. For example, "0:start:0" means function 0 starts from the very beginning of time 0. "0:end:0" means function 0 ends to the very end of time 0. 

Exclusive time of a function is defined as the time spent within this function, the time spent by calling other functions should not be considered as this function's exclusive time. You should return the exclusive time of each function sorted by their function id.

Example 1:

Input:
n = 2
logs = 
["0:start:0",
 "1:start:2",
 "1:end:5",
 "0:end:6"]
Output:[3, 4]
Explanation:
Function 0 starts at time 0, then it executes 2 units of time and reaches the end of time 1. 
Now function 0 calls function 1, function 1 starts at time 2, executes 4 units of time and end at time 5.
Function 0 is running again at time 6, and also end at the time 6, thus executes 1 unit of time. 
So function 0 totally execute 2 + 1 = 3 units of time, and function 1 totally execute 4 units of time.



Note:

Input logs will be sorted by timestamp, NOT log id.
Your output should be sorted by function id, which means the 0th element of your output corresponds to the exclusive time of function 0.
Two functions won't start or end at the same time.
Functions could be called recursively, and will always end.
1 <= n <= 100










## 637 - Average of Levels in Binary Tree
~1~  ['Tree']
Given a non-empty binary tree, return the average value of the nodes on each level in the form of an array.

Example 1:

Input:
    3
   / \
  9  20
    /  \
   15   7
Output: [3, 14.5, 11]
Explanation:
The average value of nodes on level 0 is 3,  on level 1 is 14.5, and on level 2 is 11. Hence return [3, 14.5, 11].



Note:

The range of node's value is in the range of 32-bit signed integer.










## 638 - Shopping Offers
~2~  ['Dynamic Programming', 'Depth-first Search']
In LeetCode Store, there are some kinds of items to sell. Each item has a price.



However, there are some special offers, and a special offer consists of one or more different kinds of items with a sale price.



You are given the each item's price, a set of special offers, and the number we need to buy for each item.
The job is to output the lowest price you have to pay for exactly certain items as given, where you could make optimal use of the special offers.



Each special offer is represented in the form of an array, the last number represents the price you need to pay for this special offer, other numbers represents how many specific items you could get if you buy this offer.


You could use any of special offers as many times as you want.

Example 1:

Input: [2,5], [[3,0,5],[1,2,10]], [3,2]
Output: 14
Explanation: 
There are two kinds of items, A and B. Their prices are $2 and $5 respectively. 
In special offer 1, you can pay $5 for 3A and 0B
In special offer 2, you can pay $10 for 1A and 2B. 
You need to buy 3A and 2B, so you may pay $10 for 1A and 2B (special offer #2), and $4 for 2A.



Example 2:

Input: [2,3,4], [[1,1,0,4],[2,2,1,9]], [1,2,1]
Output: 11
Explanation: 
The price of A is $2, and $3 for B, $4 for C. 
You may pay $4 for 1A and 1B, and $9 for 2A ,2B and 1C. 
You need to buy 1A ,2B and 1C, so you may pay $4 for 1A and 1B (special offer #1), and $3 for 1B, $4 for 1C. 
You cannot add more items, though only $9 for 2A ,2B and 1C.



Note:

There are at most 6 kinds of items, 100 special offers.
For each item, you need to buy at most 6 of them.
You are not allowed to buy more items than you want, even if that would lower the overall price.










## 639 - Decode Ways II
~3~  ['Dynamic Programming']
A message containing letters from A-Z is being encoded to numbers using the following mapping way:



'A' -> 1
'B' -> 2
...
'Z' -> 26



Beyond that, now the encoded string can also contain the character '*', which can be treated as one of the numbers from 1 to 9.




Given the encoded message containing digits and the character '*', return the total number of ways to decode it.



Also, since the answer may be very large, you should return the output mod 109 + 7.


Example 1:

Input: "*"
Output: 9
Explanation: The encoded message can be decoded to the string: "A", "B", "C", "D", "E", "F", "G", "H", "I".



Example 2:

Input: "1*"
Output: 9 + 9 = 18



Note:

The length of the input string will fit in range [1, 105].
The input string will only contain the character '*' and digits '0' - '9'.










## 640 - Solve the Equation
~2~  ['Math']
Solve a given equation and return the value of x in the form of string "x=#value". The equation contains only '+', '-' operation, the variable x and its coefficient.



If there is no solution for the equation, return "No solution".


If there are infinite solutions for the equation, return "Infinite solutions".


If there is exactly one solution for the equation, we ensure that the value of x is an integer.


Example 1:

Input: "x+5-3+x=6+x-2"
Output: "x=2"



Example 2:

Input: "x=x"
Output: "Infinite solutions"



Example 3:

Input: "2x=x"
Output: "x=0"



Example 4:

Input: "2x+3x-6x=x+2"
Output: "x=-1"



Example 5:

Input: "x=x+2"
Output: "No solution"










## 642 - Design Search Autocomplete System
~3~  []
Design a search autocomplete system for a search engine. Users may input a
sentence (at least one word and end with a special character `'#'`). For each
character they type except '#', you need to return the top 3historical hot
sentences that have prefix the same as the part of sentence already typed.
Here are the specific rules:

  1. The hot degree for a sentence is defined as the number of times a user typed the exactly same sentence before.
  2. The returned top 3 hot sentences should be sorted by hot degree (The first is the hottest one). If several sentences have the same degree of hot, you need to use ASCII-code order (smaller one appears first).
  3. If less than 3 hot sentences exist, then just return as many as you can.
  4. When the input is a special character, it means the sentence ends, and in this case, you need to return an empty list.

Your job is to implement the following functions:

The constructor function:

`AutocompleteSystem(String[] sentences, int[] times):` This is the
constructor. The input is historical data. `Sentences` is a string array
consists of previously typed sentences. `Times` is the corresponding times a
sentence has been typed. Your system should record these historical data.

Now, the user wants to input a new sentence. The following function will
provide the next character the user types:

`List<String> input(char c):` The input `c` is the next character typed by the
user. The character will only be lower-case letters (`'a'` to `'z'`), blank
space (`' '`) or a special character (`'#'`). Also, the previously typed
sentence should be recorded in your system. The output will be the top 3
historical hot sentences that have prefix the same as the part of sentence
already typed.



Example:
Operation: AutocompleteSystem(["i love you", "island","ironman", "i love
leetcode"], [5,3,2,2])
The system have already tracked down the following sentences and their
corresponding times:
`"i love you"` : `5` times
`"island"` : `3` times
`"ironman"` : `2` times
`"i love leetcode"` : `2` times
Now, the user begins another search:

Operation: input('i')
Output: ["i love you", "island","i love leetcode"]
Explanation:
There are four sentences that have prefix `"i"`. Among them, "ironman" and "i
love leetcode" have same hot degree. Since `' '` has ASCII code 32 and `'r'`
has ASCII code 114, "i love leetcode" should be in front of "ironman". Also we
only need to output top 3 hot sentences, so "ironman" will be ignored.

Operation: input(' ')
Output: ["i love you","i love leetcode"]
Explanation:
There are only two sentences that have prefix `"i "`.

Operation: input('a')
Output: []
Explanation:
There are no sentences that have prefix `"i a"`.

Operation: input('#')
Output: []
Explanation:
The user finished the input, the sentence `"i a"` should be saved as a
historical sentence in system. And the following input will be counted as a
new search.



Note:

    1. The input sentence will always start with a letter and end with '#', and only one blank space will exist between two words.
    2. The number of complete sentences that to be searched won't exceed 100. The length of each sentence including those in the historical data won't exceed 100.
    3. Please use double-quote instead of single-quote when you write test cases even for a character input.
    4. Please remember to RESET your class variables declared in class AutocompleteSystem, as static/class variables are persisted across multiple test cases. Please see [here](https://leetcode.com/faq/#different-output) for more details.










## 643 - Maximum Average Subarray I
~1~  ['Array']
Given an array consisting of n integers, find the contiguous subarray of given length k that has the maximum average value. And you need to output the maximum average value.


Example 1:

Input: [1,12,-5,-6,50,3], k = 4
Output: 12.75
Explanation: Maximum average is (12-5-6+50)/4 = 51/4 = 12.75



Note:

1 <= k <= n <= 30,000.
Elements of the given array will be in the range [-10,000, 10,000].










## 644 - Maximum Average Subarray II
~3~  []
Given an array consisting of `n` integers, find the contiguous subarray whose
length is greater than or equal to `k` that has the maximum average value. And
you need to output the maximum average value.

Example 1:



    Input: [1,12,-5,-6,50,3], k = 4Output: 12.75Explanation:when length is 5, maximum average value is 10.8,when length is 6, maximum average value is 9.16667.Thus return 12.75.



Note:

  1. 1 <= `k` <= `n` <= 10,000.
  2. Elements of the given array will be in range [-10,000, 10,000].
  3. The answer with the calculation error less than 10-5 will be accepted.










## 645 - Set Mismatch
~1~  ['Hash Table', 'Math']
The set S originally contains numbers from 1 to n. But unfortunately, due to the data error, one of the numbers in the set got duplicated to another number in the set, which results in repetition of one number and loss of another number. 



Given an array nums representing the data status of this set after the error. Your task is to firstly find the number occurs twice and then find the number that is missing. Return them in the form of an array.



Example 1:

Input: nums = [1,2,2,4]
Output: [2,3]



Note:

The given array size will in the range [2, 10000].
The given array's numbers won't have any order.










## 646 - Maximum Length of Pair Chain
~2~  ['Dynamic Programming']
You are given n pairs of numbers. In every pair, the first number is always smaller than the second number.



Now, we define a pair (c, d) can follow another pair (a, b) if and only if b < c. Chain of pairs can be formed in this fashion. 



Given a set of pairs, find the length longest chain which can be formed. You needn't use up all the given pairs. You can select pairs in any order.



Example 1:

Input: [[1,2], [2,3], [3,4]]
Output: 2
Explanation: The longest chain is [1,2] -> [3,4]



Note:

The number of given pairs will be in the range [1, 1000].










## 647 - Palindromic Substrings
~2~  ['String', 'Dynamic Programming']
Given a string, your task is to count how many palindromic substrings in this string.



The substrings with different start indexes or end indexes are counted as different substrings even they consist of same characters. 


Example 1:

Input: "abc"
Output: 3
Explanation: Three palindromic strings: "a", "b", "c".



Example 2:

Input: "aaa"
Output: 6
Explanation: Six palindromic strings: "a", "a", "a", "aa", "aa", "aaa".



Note:

The input string length won't exceed 1000.










## 648 - Replace Words
~2~  ['Hash Table', 'Trie']
In English, we have a concept called root, which can be followed by some other words to form another longer word - let's call this word successor. For example, the root an, followed by other, which can form another word another.




Now, given a dictionary consisting of many roots and a sentence. You need to replace all the successor in the sentence with the root forming it. If a successor has many roots can form it, replace it with the root with the shortest length.



You need to output the sentence after the replacement.



Example 1:

Input: dict = ["cat", "bat", "rat"]
sentence = "the cattle was rattled by the battery"
Output: "the cat was rat by the bat"




Note:

The input will only have lower-case letters.
 1 <= dict words number <= 1000 
 1 <= sentence words number <= 1000  
 1 <= root length <= 100 
 1 <= sentence words length <= 1000










## 649 - Dota2 Senate
~2~  ['Greedy']
In the world of Dota2, there are two parties: the Radiant and the Dire.



The Dota2 senate consists of senators coming from two parties. Now the senate wants to make a decision about a change in the Dota2 game. The voting for this change is a round-based procedure. In each round, each senator can exercise one of the two rights:

Ban one senator's right: A senator can make another senator lose all his rights in this and all the following rounds.
Announce the victory: If this senator found the senators who still have rights to vote are all from the same party, he can announce the victory and make the decision about the change in the game.




Given a string representing each senator's party belonging. The character 'R' and 'D' represent the Radiant party and the Dire party respectively. Then if there are n senators, the size of the given string will be n.



The round-based procedure starts from the first senator to the last senator in the given order. This procedure will last until the end of voting. All the senators who have lost their rights will be skipped during the procedure.



Suppose every senator is smart enough and will play the best strategy for his own party, you need to predict which party will finally announce the victory and make the change in the Dota2 game. The output should be Radiant or Dire.


Example 1:

Input: "RD"
Output: "Radiant"
Explanation: The first senator comes from Radiant and he can just ban the next senator's right in the round 1. And the second senator can't exercise any rights any more since his right has been banned. And in the round 2, the first senator can just announce the victory since he is the only guy in the senate who can vote.




Example 2:

Input: "RDD"
Output: "Dire"
Explanation: 
The first senator comes from Radiant and he can just ban the next senator's right in the round 1. And the second senator can't exercise any rights anymore since his right has been banned. And the third senator comes from Dire and he can ban the first senator's right in the round 1. And in the round 2, the third senator can just announce the victory since he is the only guy in the senate who can vote.



Note:

The length of the given string will in the range [1, 10,000].










## 650 - 2 Keys Keyboard
~2~  ['Dynamic Programming']
Initially on a notepad only one character 'A' is present. You can perform two operations on this notepad for each step: 

Copy All: You can copy all the characters present on the notepad (partial copy is not allowed).
Paste: You can paste the characters which are copied last time.




Given a number n. You have to get exactly n 'A' on the notepad by performing the minimum number of steps permitted. Output the minimum number of steps to get n 'A'. 


Example 1:

Input: 3
Output: 3
Explanation:
Intitally, we have one character 'A'.
In step 1, we use Copy All operation.
In step 2, we use Paste operation to get 'AA'.
In step 3, we use Paste operation to get 'AAA'.




Note:

The n will be in the range [1, 1000].










## 651 - 4 Keys Keyboard
~2~  []
Imagine you have a special keyboard with the following keys:

`Key 1: (A)`: Print one 'A' on screen.

`Key 2: (Ctrl-A)`: Select the whole screen.

`Key 3: (Ctrl-C)`: Copy selection to buffer.

`Key 4: (Ctrl-V)`: Print buffer on screen appending it after what has already
been printed.

Now, you can only press the keyboard for N times (with the above four keys),
find out the maximum numbers of 'A' you can print on screen.

Example 1:



    Input: N = 3Output: 3Explanation: We can at most get 3 A's on screen by pressing following key sequence:A, A, A



Example 2:



    Input: N = 7Output: 9Explanation: We can at most get 9 A's on screen by pressing following key sequence:A, A, A, Ctrl A, Ctrl C, Ctrl V, Ctrl V



Note:

  1. 1 <= N <= 50
  2. Answers will be in the range of 32-bit signed integer.










## 652 - Find Duplicate Subtrees
~2~  ['Tree']
Given a binary tree, return all duplicate subtrees. For each kind of duplicate subtrees, you only need to return the root node of any one of them. 


Two trees are duplicate if they have the same structure with same node values.


Example 1: 

        1
       / \
      2   3
     /   / \
    4   2   4
       /
      4

The following are two duplicate subtrees:

      2
     /
    4

and

    4

Therefore, you need to return above trees' root in the form of a list.










## 653 - Two Sum IV - Input is a BST
~1~  ['Tree']
Given a Binary Search Tree and a target number, return true if there exist two elements in the BST such that their sum is equal to the given target.

Example 1:

Input: 
    5
   / \
  3   6
 / \   \
2   4   7

Target = 9

Output: True




Example 2:

Input: 
    5
   / \
  3   6
 / \   \
2   4   7

Target = 28

Output: False










## 654 - Maximum Binary Tree
~2~  ['Tree']
Given an integer array with no duplicates. A maximum tree building on this array is defined as follow:

The root is the maximum number in the array. 
The left subtree is the maximum tree constructed from left part subarray divided by the maximum number.
The right subtree is the maximum tree constructed from right part subarray divided by the maximum number. 




Construct the maximum tree by the given array and output the root node of this tree.


Example 1:

Input: [3,2,1,6,0,5]
Output: return the tree root node representing the following tree:

      6
    /   \
   3     5
    \    / 
     2  0   
       \
        1



Note:

The size of the given array will be in the range [1,1000].










## 655 - Print Binary Tree
~2~  ['Tree']
Print a binary tree in an m*n 2D string array following these rules: 


The row number m should be equal to the height of the given binary tree.
The column number n should always be an odd number.
The root node's value (in string format) should be put in the exactly middle of the first row it can be put. The column and the row where the root node belongs will separate the rest space into two parts (left-bottom part and right-bottom part). You should print the left subtree in the left-bottom part and print the right subtree in the right-bottom part. The left-bottom part and the right-bottom part should have the same size. Even if one subtree is none while the other is not, you don't need to print anything for the none subtree but still need to leave the space as large as that for the other subtree. However, if two subtrees are none, then you don't need to leave space for both of them. 
Each unused space should contain an empty string "".
Print the subtrees following the same rules.


Example 1:

Input:
     1
    /
   2
Output:
[["", "1", ""],
 ["2", "", ""]]




Example 2:

Input:
     1
    / \
   2   3
    \
     4
Output:
[["", "", "", "1", "", "", ""],
 ["", "2", "", "", "", "3", ""],
 ["", "", "4", "", "", "", ""]]



Example 3:

Input:
      1
     / \
    2   5
   / 
  3 
 / 
4 
Output:

[["",  "",  "", "",  "", "", "", "1", "",  "",  "",  "",  "", "", ""]
 ["",  "",  "", "2", "", "", "", "",  "",  "",  "",  "5", "", "", ""]
 ["",  "3", "", "",  "", "", "", "",  "",  "",  "",  "",  "", "", ""]
 ["4", "",  "", "",  "", "", "", "",  "",  "",  "",  "",  "", "", ""]]



Note:
The height of binary tree is in the range of [1, 10].










## 656 - Coin Path
~3~  []
Given an array `A` (index starts at `1`) consisting of N integers: A1, A2,
..., AN and an integer `B`. The integer `B`denotes that from any place
(suppose the index is `i`) in the array `A`, you can jump to any one of the
place in the array `A` indexed `i+1`, `i+2`, …, `i+B` if this place can be
jumped to. Also, if you step on the index `i`, you have to pay Ai coins. If Ai
is -1, it means you can't jump to the place indexed `i` in the array.

Now, you start from the place indexed `1` in the array `A`, and your aim is to
reach the place indexed `N` using the minimum coins. You need to return the
path of indexes (starting from 1 to N) in the array you should take to get to
the place indexed `N` using minimum coins.

If there are multiple paths with the same cost, return the lexicographically
smallest such path.

If it's not possible to reach the place indexed N then you need to return an
empty array.

Example 1:



    Input: [1,2,4,-1,2], 2Output: [1,3,5]



Example 2:



    Input: [1,2,4,-1,2], 1Output: []



Note:

  1. Path Pa1, Pa2, ..., Pan is lexicographically smaller than Pb1, Pb2, ..., Pbm, if and only if at the first `i` where Pai and Pbi differ, Pai < Pbi; when no such `i` exists, then `n` < `m`.
  2. A1 >= 0. A2, ..., AN (if exist) will in the range of [-1, 100].
  3. Length of A is in the range of [1, 1000].
  4. B is in the range of [1, 100].










## 657 - Judge Route Circle
~1~  ['String']
Initially, there is a Robot at position (0, 0). Given a sequence of its moves, judge if this robot makes a circle, which means it moves back to the original place. 



The move sequence is represented by a string. And each move is represent by a character. The valid robot moves are R (Right), L (Left), U (Up) and D (down). The output should be true or false representing whether the robot makes a circle.


Example 1:

Input: "UD"
Output: true



Example 2:

Input: "LL"
Output: false










## 658 - Find K Closest Elements
~2~  ['Binary Search']
Given a sorted array, two integers k and x, find the k closest elements to x in the array.  The result should also be sorted in ascending order.
If there is a tie,  the smaller elements are always preferred.


Example 1:

Input: [1,2,3,4,5], k=4, x=3
Output: [1,2,3,4]




Example 2:

Input: [1,2,3,4,5], k=4, x=-1
Output: [1,2,3,4]



Note:

The value k is positive and will always be smaller than the length of the sorted array.
 Length of the given array is positive and will not exceed 104
 Absolute value of elements in the array and x will not exceed 104






UPDATE (2017/9/19):
The arr parameter had been changed to an array of integers (instead of a list of integers). Please reload the code definition to get the latest changes.










## 659 - Split Array into Consecutive Subsequences
~2~  ['Heap', 'Greedy']
You are given an integer array sorted in ascending order (may contain duplicates), you need to split them into several subsequences, where each subsequences consist of at least 3 consecutive integers. Return whether you can make such a split.

Example 1:

Input: [1,2,3,3,4,5]
Output: True
Explanation:
You can split them into two consecutive subsequences : 
1, 2, 3
3, 4, 5



Example 2:

Input: [1,2,3,3,4,4,5,5]
Output: True
Explanation:
You can split them into two consecutive subsequences : 
1, 2, 3, 4, 5
3, 4, 5



Example 3:

Input: [1,2,3,4,4,5]
Output: False



Note:

The length of the input is in range of [1, 10000]










## 660 - Remove 9
~3~  []
Start from integer 1, remove any integer that contains 9 such as 9, 19, 29...

So now, you will have a new integer sequence: 1, 2, 3, 4, 5, 6, 7, 8, 10, 11,
...

Given a positive integer `n`, you need to return the n-th integer after
removing. Note that 1 will be the first integer.

**Example 1:**


    **Input:** 9**Output:** 10

**Hint** : n will not exceed `9 x 10^8`.










## 661 - Image Smoother
~1~  ['Array']
Given a 2D integer matrix M representing the gray scale of an image, you need to design a smoother to make the gray scale of each cell becomes the average gray scale (rounding down) of all the 8 surrounding cells and itself.  If a cell has less than 8 surrounding cells, then use as many as you can.

Example 1:

Input:
[[1,1,1],
 [1,0,1],
 [1,1,1]]
Output:
[[0, 0, 0],
 [0, 0, 0],
 [0, 0, 0]]
Explanation:
For the point (0,0), (0,2), (2,0), (2,2): floor(3/4) = floor(0.75) = 0
For the point (0,1), (1,0), (1,2), (2,1): floor(5/6) = floor(0.83333333) = 0
For the point (1,1): floor(8/9) = floor(0.88888889) = 0



Note:

The value in the given matrix is in the range of [0, 255].
The length and width of the given matrix are in the range of [1, 150].










## 662 - Maximum Width of Binary Tree
~2~  ['Tree']
Given a binary tree, write a function to get the maximum width of the given tree. The width of a tree is the maximum width among all levels. The binary tree has the same structure as a full binary tree, but some nodes are null. 

The width of one level is defined as the length between the end-nodes (the leftmost and right most non-null nodes in the level, where the null nodes between the end-nodes are also counted into the length calculation.

Example 1:

Input: 

           1
         /   \
        3     2
       / \     \  
      5   3     9 

Output: 4
Explanation: The maximum width existing in the third level with the length 4 (5,3,null,9).



Example 2:

Input: 

          1
         /  
        3    
       / \       
      5   3     

Output: 2
Explanation: The maximum width existing in the third level with the length 2 (5,3).



Example 3:

Input: 

          1
         / \
        3   2 
       /        
      5      

Output: 2
Explanation: The maximum width existing in the second level with the length 2 (3,2).


Example 4:

Input: 

          1
         / \
        3   2
       /     \  
      5       9 
     /         \
    6           7
Output: 8
Explanation:The maximum width existing in the fourth level with the length 8 (6,null,null,null,null,null,null,7).




Note:
Answer will in the range of 32-bit signed integer.










## 663 - Equal Tree Partition
~2~  []
Given a binary tree with `n` nodes, your task is to check if it's possible to
partition the tree to two trees which have the equal sum of values after
removing exactly one edge on the original tree.

Example 1:



    Input:         5   / \  10 10    /  \   2   3Output: TrueExplanation:     5   /   10      Sum: 15   10  /  \ 2    3Sum: 15



Example 2:



    Input:         1   / \  2  10    /  \   2   20Output: FalseExplanation: You can't split the tree into two trees with equal sum after removing exactly one edge on the tree.










## 664 - Strange Printer
~3~  ['Dynamic Programming', 'Depth-first Search']
There is a strange printer with the following two special requirements:


The printer can only print a sequence of the same character each time.
At each turn, the printer can print new characters starting from and ending at any places, and will cover the original existing characters.





Given a string consists of lower English letters only, your job is to count the minimum number of turns the printer needed in order to print it.


Example 1:

Input: "aaabbb"
Output: 2
Explanation: Print "aaa" first and then print "bbb".



Example 2:

Input: "aba"
Output: 2
Explanation: Print "aaa" first and then print "b" from the second place of the string, which will cover the existing character 'a'.



Hint: Length of the given string will not exceed 100.










## 665 - Non-decreasing Array
~1~  ['Array']
Given an array with n integers, your task is to check if it could become non-decreasing by modifying at most 1 element.



We define an array is non-decreasing if array[i] <= array[i + 1] holds for every i (1 <= i < n).


Example 1:

Input: [4,2,3]
Output: True
Explanation: You could modify the first 4 to 1 to get a non-decreasing array.



Example 2:

Input: [4,2,1]
Output: False
Explanation: You can't get a non-decreasing array by modify at most one element.



Note:
The n belongs to [1, 10,000].










## 666 - Path Sum IV
~2~  []
If the depth of a tree is smaller than `5`, then this tree can be represented
by a list of three-digits integers.

For each integer in this list:

  1. The hundreds digit represents the depth `D` of this node, `1 <= D <= 4.`
  2. The tens digit represents the position `P` of this node in the level it belongs to, `1 <= P <= 8`. The position is the same as that in a full binary tree.
  3. The units digit represents the value `V` of this node, `0 <= V <= 9.`



Given a list of `ascending` three-digits integers representing a binary with
the depth smaller than 5. You need to return the sum of all paths from the
root towards the leaves.

Example 1:



    Input: [113, 215, 221]Output: 12Explanation: The tree that the list represents is:    3   / \  5   1The path sum is (3 + 5) + (3 + 1) = 12.



Example 2:



    Input: [113, 221]Output: 4Explanation: The tree that the list represents is:     3     \      1The path sum is (3 + 1) = 4.










## 667 - Beautiful Arrangement II
~2~  ['Array']
Given two integers n and k, you need to construct a list which contains n different positive integers ranging from 1 to n and obeys the following requirement: 

Suppose this list is [a1, a2, a3, ... , an], then the list [|a1 - a2|, |a2 - a3|, |a3 - a4|, ... , |an-1 - an|] has exactly k distinct integers.



If there are multiple answers, print any of them.


Example 1:

Input: n = 3, k = 1
Output: [1, 2, 3]
Explanation: The [1, 2, 3] has three different positive integers ranging from 1 to 3, and the [1, 1] has exactly 1 distinct integer: 1.



Example 2:

Input: n = 3, k = 2
Output: [1, 3, 2]
Explanation: The [1, 3, 2] has three different positive integers ranging from 1 to 3, and the [2, 1] has exactly 2 distinct integers: 1 and 2.



Note:

The n and k are in the range 1 <= k < n <= 104.










## 668 - Kth Smallest Number in Multiplication Table
~3~  ['Binary Search']
Nearly every one have used the Multiplication Table. But could you find out the k-th smallest number quickly from the multiplication table?



Given the height m and the length n of a m * n Multiplication Table, and a positive integer k, you need to return the k-th smallest number in this table.


Example 1:

Input: m = 3, n = 3, k = 5
Output: 
Explanation: 
The Multiplication Table:
1	2	3
2	4	6
3	6	9

The 5-th smallest number is 3 (1, 2, 2, 3, 3).




Example 2:

Input: m = 2, n = 3, k = 6
Output: 
Explanation: 
The Multiplication Table:
1	2	3
2	4	6

The 6-th smallest number is 6 (1, 2, 2, 3, 4, 6).




Note:

The m and n will be in the range [1, 30000].
The k will be in the range [1, m * n]










## 669 - Trim a Binary Search Tree
~1~  ['Tree']
Given a binary search tree and the lowest and highest boundaries as L and R, trim the tree so that all its elements lies in [L, R] (R >= L). You might need to change the root of the tree, so the result should return the new root of the trimmed binary search tree.


Example 1:

Input: 
    1
   / \
  0   2

  L = 1
  R = 2

Output: 
    1
      \
       2



Example 2:

Input: 
    3
   / \
  0   4
   \
    2
   /
  1

  L = 1
  R = 3

Output: 
      3
     / 
   2   
  /
 1










## 670 - Maximum Swap
~2~  ['Array', 'Math']
Given a non-negative integer, you could swap two digits at most once to get the maximum valued number. Return the maximum valued number you could get.


Example 1:

Input: 2736
Output: 7236
Explanation: Swap the number 2 and the number 7.



Example 2:

Input: 9973
Output: 9973
Explanation: No swap.




Note:

The given number is in the range [0, 108]










## 671 - Second Minimum Node In a Binary Tree
~1~  ['Tree']
Given a non-empty special binary tree consisting of nodes with the non-negative value, where each node in this tree has exactly two or zero sub-node. If the node has two sub-nodes, then this node's value is the smaller value among its two sub-nodes. 



Given such a binary tree, you need to output the second minimum value in the set made of all the nodes' value in the whole tree. 



If no such second minimum value exists, output -1 instead.


Example 1:

Input: 
    2
   / \
  2   5
     / \
    5   7

Output: 5
Explanation: The smallest value is 2, the second smallest value is 5.



Example 2:

Input: 
    2
   / \
  2   2

Output: -1
Explanation: The smallest value is 2, but there isn't any second smallest value.










## 672 - Bulb Switcher II
~2~  ['Math']
There is a room with n lights which are turned on initially and 4 buttons on the wall. After performing exactly m unknown operations towards buttons, you need to return how many different kinds of status of the n lights could be.



Suppose n lights are labeled as number [1, 2, 3 ..., n], function of these 4 buttons are given below:


Flip all the lights.
Flip lights with even numbers.
Flip lights with odd numbers.
Flip lights with (3k + 1) numbers, k = 0, 1, 2, ...




Example 1:

Input: n = 1, m = 1.
Output: 2
Explanation: Status can be: [on], [off]




Example 2:

Input: n = 2, m = 1.
Output: 3
Explanation: Status can be: [on, off], [off, on], [off, off]




Example 3:

Input: n = 3, m = 1.
Output: 4
Explanation: Status can be: [off, on, off], [on, off, on], [off, off, off], [off, on, on].



Note:
n and m both fit in range [0, 1000].










## 673 - Number of Longest Increasing Subsequence
~2~  ['Dynamic Programming']
Given an unsorted array of integers, find the number of longest increasing subsequence.


Example 1:

Input: [1,3,5,4,7]
Output: 2
Explanation: The two longest increasing subsequence are [1, 3, 4, 7] and [1, 3, 5, 7].



Example 2:

Input: [2,2,2,2,2]
Output: 5
Explanation: The length of longest continuous increasing subsequence is 1, and there are 5 subsequences' length is 1, so output 5.



Note:
Length of the given array will be not exceed 2000 and the answer is guaranteed to be fit in 32-bit signed int.










## 674 - Longest Continuous Increasing Subsequence
~1~  ['Array']
Given an unsorted array of integers, find the length of longest continuous increasing subsequence.


Example 1:

Input: [1,3,5,4,7]
Output: 3
Explanation: The longest continuous increasing subsequence is [1,3,5], its length is 3. 
Even though [1,3,5,7] is also an increasing subsequence, it's not a continuous one where 5 and 7 are separated by 4. 



Example 2:

Input: [2,2,2,2,2]
Output: 1
Explanation: The longest continuous increasing subsequence is [2], its length is 1. 



Note:
Length of the array will not exceed 10,000.










## 675 - Cut Off Trees for Golf Event
~3~  ['Breadth-first Search']
You are asked to cut off trees in a forest for a golf event. The forest is represented as a non-negative 2D map, in this map:

0 represents the obstacle can't be reached.
1 represents the ground can be walked through.
The place with number bigger than 1 represents a tree can be walked through, and this positive number represents the tree's height.




You are asked to cut off all the trees in this forest in the order of tree's height - always cut off the tree with lowest height first. And after cutting, the original place has the tree will become a grass (value 1). 



You will start from the point (0, 0) and you should output the minimum steps you need to walk to cut off all the trees. If you can't cut off all the trees, output -1 in that situation.



You are guaranteed that no two trees have the same height and there is at least one tree needs to be cut off.


Example 1:

Input: 
[
 [1,2,3],
 [0,0,4],
 [7,6,5]
]
Output: 6



Example 2:

Input: 
[
 [1,2,3],
 [0,0,0],
 [7,6,5]
]
Output: -1



Example 3:

Input: 
[
 [2,3,4],
 [0,0,5],
 [8,7,6]
]
Output: 6
Explanation: You started from the point (0,0) and you can cut off the tree in (0,0) directly without walking.




Hint: size of the given matrix will not exceed 50x50.










## 676 - Implement Magic Dictionary
~2~  ['Hash Table', 'Trie']
Implement a magic directory with buildDict, and search methods.



For the method buildDict, you'll be given a list of non-repetitive words to build a dictionary.



For the method search, you'll be given a word, and judge whether if you modify exactly one character into another character in this word, the modified word is in the dictionary you just built.


Example 1:

Input: buildDict(["hello", "leetcode"]), Output: Null
Input: search("hello"), Output: False
Input: search("hhllo"), Output: True
Input: search("hell"), Output: False
Input: search("leetcoded"), Output: False



Note:

You may assume that all the inputs are consist of lowercase letters a-z.
For contest purpose, the test data is rather small by now. You could think about highly efficient algorithm after the contest.
Please remember to RESET your class variables declared in class MagicDictionary, as static/class variables are persisted across multiple test cases. Please see here for more details.










## 677 - Map Sum Pairs
~2~  ['Trie']
Implement a MapSum class with insert, and sum methods.



For the method insert, you'll be given a pair of (string, integer). The string represents the key and the integer represents the value. If the key already existed, then the original key-value pair will be overridden to the new one.



For the method sum, you'll be given a string representing the prefix, and you need to return the sum of all the pairs' value whose key starts with the prefix.


Example 1:

Input: insert("apple", 3), Output: Null
Input: sum("ap"), Output: 3
Input: insert("app", 2), Output: Null
Input: sum("ap"), Output: 5










## 678 - Valid Parenthesis String
~2~  ['String']
Given a string containing only three types of characters: '(', ')' and '*', write a function to check whether this string is valid. We define the validity of a string by these rules:

Any left parenthesis '(' must have a corresponding right parenthesis ')'.
Any right parenthesis ')' must have a corresponding left parenthesis '('.
Left parenthesis '(' must go before the corresponding right parenthesis ')'.
'*' could be treated as a single right parenthesis ')' or a single left parenthesis '(' or an empty string.
An empty string is also valid.



Example 1:

Input: "()"
Output: True



Example 2:

Input: "(*)"
Output: True



Example 3:

Input: "(*))"
Output: True



Note:

The string size will be in the range [1, 100].










## 679 - 24 Game
~3~  ['Depth-first Search']
You have 4 cards each containing a number from 1 to 9.  You need to judge whether they could operated through *, /, +, -, (, ) to get the value of 24.


Example 1:

Input: [4, 1, 8, 7]
Output: True
Explanation: (8-4) * (7-1) = 24



Example 2:

Input: [1, 2, 1, 2]
Output: False



Note:

The division operator / represents real division, not integer division.  For example, 4 / (1 - 2/3) = 12.
Every operation done is between two numbers.  In particular, we cannot use - as a unary operator.  For example, with [1, 1, 1, 1] as input, the expression -1 - 1 - 1 - 1 is not allowed.
You cannot concatenate numbers together.  For example, if the input is [1, 2, 1, 2], we cannot write this as 12 + 12.










## 680 - Valid Palindrome II
~1~  ['String']
Given a non-empty string s, you may delete at most one character.  Judge whether you can make it a palindrome.


Example 1:

Input: "aba"
Output: True



Example 2:

Input: "abca"
Output: True
Explanation: You could delete the character 'c'.



Note:

The string will only contain lowercase characters a-z.
The maximum length of the string is 50000.










## 681 - Next Closest Time
~2~  ['String']
Given a time represented in the format "HH:MM", form the next closest time by reusing the current digits. There is no limit on how many times a digit can be reused.

You may assume the given input string is always valid. For example, "01:34", "12:09" are all valid. "1:34", "12:9" are all invalid.

Example 1:

Input: "19:34"
Output: "19:39"
Explanation: The next closest time choosing from digits 1, 9, 3, 4, is 19:39, which occurs 5 minutes later.  It is not 19:33, because this occurs 23 hours and 59 minutes later.



Example 2:

Input: "23:59"
Output: "22:22"
Explanation: The next closest time choosing from digits 2, 3, 5, 9, is 22:22. It may be assumed that the returned time is next day's time since it is smaller than the input time numerically.










## 682 - Baseball Game
~1~  ['Stack']
You're now a baseball game point recorder.



Given a list of strings, each string can be one of the 4 following types:

Integer (one round's score): Directly represents the number of points you get in this round.
"+" (one round's score): Represents that the points you get in this round are the sum of the last two valid round's points.
"D" (one round's score): Represents that the points you get in this round are the doubled data of the last valid round's points.
"C" (an operation, which isn't a round's score): Represents the last valid round's points you get were invalid and should be removed.




Each round's operation is permanent and could have an impact on the round before and the round after.



You need to return the sum of the points you could get in all the rounds.


Example 1:

Input: ["5","2","C","D","+"]
Output: 30
Explanation: 
Round 1: You could get 5 points. The sum is: 5.
Round 2: You could get 2 points. The sum is: 7.
Operation 1: The round 2's data was invalid. The sum is: 5.  
Round 3: You could get 10 points (the round 2's data has been removed). The sum is: 15.
Round 4: You could get 5 + 10 = 15 points. The sum is: 30.



Example 2:

Input: ["5","-2","4","C","D","9","+","+"]
Output: 27
Explanation: 
Round 1: You could get 5 points. The sum is: 5.
Round 2: You could get -2 points. The sum is: 3.
Round 3: You could get 4 points. The sum is: 7.
Operation 1: The round 3's data is invalid. The sum is: 3.  
Round 4: You could get -4 points (the round 3's data has been removed). The sum is: -1.
Round 5: You could get 9 points. The sum is: 8.
Round 6: You could get -4 + 9 = 5 points. The sum is 13.
Round 7: You could get 9 + 5 = 14 points. The sum is 27.



Note:
The size of the input list will be between 1 and 1000.
Every integer represented in the list will be between -30000 and 30000.










## 683 - K Empty Slots
~3~  ['Array', 'Binary Search Tree']
There is a garden with N slots. In each slot, there is a flower. The N flowers will bloom one by one in N days. In each day, there will be exactly one flower blooming and it will be in the status of blooming since then.



Given an array flowers consists of number from 1 to N. Each number in the array represents the place where the flower will open in that day.



For example, flowers[i] = x means that the unique flower that blooms at day i will be at position x, where i and x will be in the range from 1 to N.



Also given an integer k, you need to output in which day there exists two flowers in the status of blooming, and also the number of flowers between them is k and these flowers are not blooming.



If there isn't such day, output -1.


Example 1:

Input: 
flowers: [1,3,2]
k: 1
Output: 2
Explanation: In the second day, the first and the third flower have become blooming.



Example 2:

Input: 
flowers: [1,2,3]
k: 1
Output: -1




Note:

The given array will be in the range [1, 20000].










## 684 - Redundant Connection
~2~  ['Tree', 'Union Find', 'Graph']
In this problem, a tree is an undirected graph that is connected and has no cycles.

The given input is a graph that started as a tree with N nodes (with distinct values 1, 2, ..., N), with one additional edge added.  The added edge has two different vertices chosen from 1 to N, and was not an edge that already existed.

The resulting graph is given as a 2D-array of edges.  Each element of edges is a pair [u, v] with u < v, that represents an undirected edge connecting nodes u and v.

Return an edge that can be removed so that the resulting graph is a tree of N nodes.  If there are multiple answers, return the answer that occurs last in the given 2D-array.  The answer edge [u, v] should be in the same format, with u < v.
Example 1:

Input: [[1,2], [1,3], [2,3]]
Output: [2,3]
Explanation: The given undirected graph will be like this:
  1
 / \
2 - 3


Example 2:

Input: [[1,2], [2,3], [3,4], [1,4], [1,5]]
Output: [1,4]
Explanation: The given undirected graph will be like this:
5 - 1 - 2
    |   |
    4 - 3


Note:
The size of the input 2D-array will be between 3 and 1000.
Every integer represented in the 2D-array will be between 1 and N, where N is the size of the input array.





Update (2017-09-26):
We have overhauled the problem description + test cases and specified clearly the graph is an undirected graph. For the directed graph follow up please see Redundant Connection II). We apologize for any inconvenience caused.










## 685 - Redundant Connection II
~3~  ['Tree', 'Depth-first Search', 'Union Find', 'Graph']
In this problem, a rooted tree is a directed graph such that, there is exactly one node (the root) for which all other nodes are descendants of this node, plus every node has exactly one parent, except for the root node which has no parents.

The given input is a directed graph that started as a rooted tree with N nodes (with distinct values 1, 2, ..., N), with one additional directed edge added.  The added edge has two different vertices chosen from 1 to N, and was not an edge that already existed.

The resulting graph is given as a 2D-array of edges.  Each element of edges is a pair [u, v] that represents a directed edge connecting nodes u and v, where u is a parent of child v.

Return an edge that can be removed so that the resulting graph is a rooted tree of N nodes.  If there are multiple answers, return the answer that occurs last in the given 2D-array.
Example 1:

Input: [[1,2], [1,3], [2,3]]
Output: [2,3]
Explanation: The given directed graph will be like this:
  1
 / \
v   v
2-->3


Example 2:

Input: [[1,2], [2,3], [3,4], [4,1], [1,5]]
Output: [4,1]
Explanation: The given directed graph will be like this:
5 <- 1 -> 2
     ^    |
     |    v
     4 <- 3


Note:
The size of the input 2D-array will be between 3 and 1000.
Every integer represented in the 2D-array will be between 1 and N, where N is the size of the input array.










## 686 - Repeated String Match
~1~  ['String']
Given two strings A and B, find the minimum number of times A has to be repeated such that B is a substring of it. If no such solution, return -1.


For example, with A = "abcd" and B = "cdabcdab". 


Return 3, because by repeating A three times (“abcdabcdabcd”), B is a substring of it; and B is not a substring of A repeated two times ("abcdabcd").


Note:
The length of A and B will be between 1 and 10000.










## 687 - Longest Univalue Path
~1~  ['Tree', 'Recursion']
Given a binary tree, find the length of the longest path where each node in the path has the same value. This path may or may not pass through the root.

Note: The length of path between two nodes is represented by the number of edges between them.


Example 1:




Input:

              5
             / \
            4   5
           / \   \
          1   1   5




Output:

2




Example 2:




Input:

              1
             / \
            4   5
           / \   \
          4   4   5




Output:

2



Note:
The given binary tree has not more than 10000 nodes.  The height of the tree is not more than 1000.










## 688 - Knight Probability in Chessboard
~2~  ['Dynamic Programming']
On an NxN chessboard, a knight starts at the r-th row and c-th column and attempts to make exactly K moves.  The rows and columns are 0 indexed, so the top-left square is (0, 0), and the bottom-right square is (N-1, N-1).



A chess knight has 8 possible moves it can make, as illustrated below.  Each move is two squares in a cardinal direction, then one square in an orthogonal direction.





Each time the knight is to move, it chooses one of eight possible moves uniformly at random (even if the piece would go off the chessboard) and moves there.



The knight continues moving until it has made exactly K moves or has moved off the chessboard.  Return the probability that the knight remains on the board after it has stopped moving.


Example:

Input: 3, 2, 0, 0
Output: 0.0625
Explanation: There are two moves (to (1,2), (2,1)) that will keep the knight on the board.
From each of those positions, there are also two moves that will keep the knight on the board.
The total probability the knight stays on the board is 0.0625.



Note:
N will be between 1 and 25.
K will be between 0 and 100.
The knight always initially starts on the board.










## 689 - Maximum Sum of 3 Non-Overlapping Subarrays
~3~  ['Array', 'Dynamic Programming']
In a given array nums of positive integers, find three non-overlapping subarrays with maximum sum.


Each subarray will be of size k, and we want to maximize the sum of all 3*k entries.


Return the result as a list of indices representing the starting position of each interval (0-indexed).  If there are multiple answers, return the lexicographically smallest one.

Example:

Input: [1,2,1,2,6,7,5,1], 2
Output: [0, 3, 5]
Explanation: Subarrays [1, 2], [2, 6], [7, 5] correspond to the starting indices [0, 3, 5].
We could have also taken [2, 1], but an answer of [1, 3, 5] would be lexicographically larger.



Note:
nums.length will be between 1 and 20000.
nums[i] will be between 1 and 65535.
k will be between 1 and floor(nums.length / 3).










## 690 - Employee Importance
~1~  ['Hash Table', 'Depth-first Search', 'Breadth-first Search']
You are given a data structure of employee information, which includes the employee's unique id, his importance value and his direct subordinates' id. 

For example, employee 1 is the leader of employee 2, and employee 2 is the leader of employee 3. They have importance value 15, 10 and 5, respectively. Then employee 1 has a data structure like [1, 15, [2]], and employee 2 has [2, 10, [3]], and employee 3 has [3, 5, []]. Note that although employee 3 is also a subordinate of employee 1, the relationship is not direct.

Now given the employee information of a company, and an employee id, you need to return the total importance value of this employee and all his subordinates.

Example 1:

Input: [[1, 5, [2, 3]], [2, 3, []], [3, 3, []]], 1
Output: 11
Explanation:
Employee 1 has importance value 5, and he has two direct subordinates: employee 2 and employee 3. They both have importance value 3. So the total importance value of employee 1 is 5 + 3 + 3 = 11.



Note:

One employee has at most one direct leader and may have several subordinates.
The maximum number of employees won't exceed 2000.










## 691 - Stickers to Spell Word
~3~  ['Dynamic Programming', 'Backtracking']
We are given N different types of stickers.  Each sticker has a lowercase English word on it.

You would like to spell out the given target string by cutting individual letters from your collection of stickers and rearranging them.

You can use each sticker more than once if you want, and you have infinite quantities of each sticker.

What is the minimum number of stickers that you need to spell out the target?  If the task is impossible, return -1.


Example 1:
Input:
["with", "example", "science"], "thehat"


Output:
3


Explanation:
We can use 2 "with" stickers, and 1 "example" sticker.
After cutting and rearrange the letters of those stickers, we can form the target "thehat".
Also, this is the minimum number of stickers necessary to form the target string.


Example 2:
Input:
["notice", "possible"], "basicbasic"


Output:
-1


Explanation:
We can't form the target "basicbasic" from cutting letters from the given stickers.


Note:
stickers has length in the range [1, 50].
stickers consists of lowercase English words (without apostrophes).
target has length in the range [1, 15], and consists of lowercase English letters.
In all test cases, all words were chosen randomly from the 1000 most common US English words, and the target was chosen as a concatenation of two random words.
The time limit may be more challenging than usual.  It is expected that a 50 sticker test case can be solved within 35ms on average.










## 692 - Top K Frequent Words
~2~  ['Hash Table', 'Heap', 'Trie']
Given a non-empty list of words, return the k most frequent elements.
Your answer should be sorted by frequency from highest to lowest. If two words have the same frequency, then the word with the lower alphabetical order comes first.

Example 1:

Input: ["i", "love", "leetcode", "i", "love", "coding"], k = 2
Output: ["i", "love"]
Explanation: "i" and "love" are the two most frequent words.
    Note that "i" comes before "love" due to a lower alphabetical order.



Example 2:

Input: ["the", "day", "is", "sunny", "the", "the", "the", "sunny", "is", "is"], k = 4
Output: ["the", "is", "sunny", "day"]
Explanation: "the", "is", "sunny" and "day" are the four most frequent words,
    with the number of occurrence being 4, 3, 2 and 1 respectively.



Note:

You may assume k is always valid, 1 ≤ k ≤ number of unique elements.
Input words contain only lowercase letters.



Follow up:

Try to solve it in O(n log k) time and O(n) extra space.










## 693 - Binary Number with Alternating Bits
~1~  ['Bit Manipulation']
Given a positive integer, check whether it has alternating bits: namely, if two adjacent bits will always have different values.

Example 1:

Input: 5
Output: True
Explanation:
The binary representation of 5 is: 101



Example 2:

Input: 7
Output: False
Explanation:
The binary representation of 7 is: 111.



Example 3:

Input: 11
Output: False
Explanation:
The binary representation of 11 is: 1011.



Example 4:

Input: 10
Output: True
Explanation:
The binary representation of 10 is: 1010.










## 694 - Number of Distinct Islands
~2~  []
Given a non-empty 2D array `grid` of 0's and 1's, an island is a group of
`1`'s (representing land) connected 4-directionally (horizontal or vertical.)
You may assume all four edges of the grid are surrounded by water.

Count the number of distinct islands. An island is considered to be the same
as another if and only if one island can be translated (and not rotated or
reflected) to equal the other.

Example 1:



    11000110000001100011

Given the above grid map, return `1`.



Example 2:



    11011100000000111011

Given the above grid map, return `3`.

Notice that:



    111

and



     111

are considered different island shapes, because we do not consider reflection
/ rotation.



Note: The length of each dimension in the given `grid` does not exceed 50.










## 695 - Max Area of Island
~1~  ['Array', 'Depth-first Search']
Given a non-empty 2D array grid of 0's and 1's, an island is a group of 1's (representing land) connected 4-directionally (horizontal or vertical.)  You may assume all four edges of the grid are surrounded by water.

Find the maximum area of an island in the given 2D array.
(If there is no island, the maximum area is 0.)

Example 1:

[[0,0,1,0,0,0,0,1,0,0,0,0,0],
 [0,0,0,0,0,0,0,1,1,1,0,0,0],
 [0,1,1,0,1,0,0,0,0,0,0,0,0],
 [0,1,0,0,1,1,0,0,1,0,1,0,0],
 [0,1,0,0,1,1,0,0,1,1,1,0,0],
 [0,0,0,0,0,0,0,0,0,0,1,0,0],
 [0,0,0,0,0,0,0,1,1,1,0,0,0],
 [0,0,0,0,0,0,0,1,1,0,0,0,0]]

Given the above grid, return 6.

Note the answer is not 11, because the island must be connected 4-directionally.


Example 2:
[[0,0,0,0,0,0,0,0]]
Given the above grid, return 0.


Note:
The length of each dimension in the given grid does not exceed 50.










## 696 - Count Binary Substrings
~1~  ['String']
Give a string s, count the number of non-empty (contiguous) substrings that have the same number of 0's and 1's, and all the 0's and all the 1's in these substrings are grouped consecutively. 

Substrings that occur multiple times are counted the number of times they occur.

Example 1:

Input: "00110011"
Output: 6
Explanation: There are 6 substrings that have equal number of consecutive 1's and 0's: "0011", "01", "1100", "10", "0011", and "01".
Notice that some of these substrings repeat and are counted the number of times they occur.
Also, "00110011" is not a valid substring because all the 0's (and 1's) are not grouped together.



Example 2:

Input: "10101"
Output: 4
Explanation: There are 4 substrings: "10", "01", "10", "01" that have equal number of consecutive 1's and 0's.



Note:
s.length will be between 1 and 50,000.
s will only consist of "0" or "1" characters.










## 697 - Degree of an Array
~1~  ['Array']
Given a non-empty array of non-negative integers nums, the degree of this array is defined as the maximum frequency of any one of its elements.
Your task is to find the smallest possible length of a (contiguous) subarray of nums, that has the same degree as nums.

Example 1:

Input: [1, 2, 2, 3, 1]
Output: 2
Explanation: 
The input array has a degree of 2 because both elements 1 and 2 appear twice.
Of the subarrays that have the same degree:
[1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]
The shortest length is 2. So return 2.




Example 2:

Input: [1,2,2,3,1,4,2]
Output: 6



Note:
nums.length will be between 1 and 50,000.
nums[i] will be an integer between 0 and 49,999.










## 698 - Partition to K Equal Sum Subsets
~2~  ['Dynamic Programming', 'Recursion']
Given an array of integers nums and a positive integer k, find whether it's possible to divide this array into k non-empty subsets whose sums are all equal.

Example 1:

Input: nums = [4, 3, 2, 3, 5, 2, 1], k = 4
Output: True
Explanation: It's possible to divide it into 4 subsets (5), (1, 4), (2,3), (2,3) with equal sums.



Note:
1 <= k <= len(nums) <= 16.
0 < nums[i] < 10000.










## 699 - Falling Squares
~3~  ['Segment Tree', 'Binary Search Tree']
On an infinite number line (x-axis), we drop given squares in the order they are given.
The i-th square dropped (positions[i] = (left, side_length)) is a square with the left-most point being positions[i][0] and sidelength positions[i][1].
The square is dropped with the bottom edge parallel to the number line, and from a higher height than all currently landed squares.  We wait for each square to stick before dropping the next.
The squares are infinitely sticky on their bottom edge, and will remain fixed to any positive length surface they touch (either the number line or another square).  Squares dropped adjacent to each other will not stick together prematurely.


Return a list ans of heights.  Each height ans[i] represents the current highest height of any square we have dropped, after dropping squares represented by positions[0], positions[1], ..., positions[i].


Example 1:

Input: [[1, 2], [2, 3], [6, 1]]
Output: [2, 5, 5]
Explanation:

After the first drop of positions[0] = [1, 2]:
_aa
_aa
-------
The maximum height of any square is 2.

After the second drop of positions[1] = [2, 3]:
__aaa
__aaa
__aaa
_aa__
_aa__
--------------
The maximum height of any square is 5.  
The larger square stays on top of the smaller square despite where its center
of gravity is, because squares are infinitely sticky on their bottom edge.

After the third drop of positions[1] = [6, 1]:
__aaa
__aaa
__aaa
_aa
_aa___a
--------------
The maximum height of any square is still 5.

Thus, we return an answer of [2, 5, 5].





Example 2:

Input: [[100, 100], [200, 100]]
Output: [100, 100]
Explanation: Adjacent squares don't get stuck prematurely - only their bottom edge can stick to surfaces.



Note:
1 <= positions.length <= 1000.
1 <= positions[i][0] <= 10^8.
1 <= positions[i][1] <= 10^6.










## 711 - Number of Distinct Islands II
~3~  []
Given a non-empty 2D array `grid` of 0's and 1's, an island is a group of
`1`'s (representing land) connected 4-directionally (horizontal or vertical.)
You may assume all four edges of the grid are surrounded by water.

Count the number of distinct islands. An island is considered to be the same
as another if they have the same shape, or have the same shape after rotation
(90, 180, or 270 degrees only) or reflection (left/right direction or up/down
direction).

Example 1:



    11000100000000100011

Given the above grid map, return `1`.

Notice that:



    111

and



     111

are considered same island shapes. Because if we make a 180 degrees clockwise
rotation on the first island, then two islands will have the same shapes.



Example 2:



    11100100010100101110

Given the above grid map, return `2`.

Here are the two distinct islands:



    1111

and



    11


Notice that:



    1111

and



    1111

are considered same island shapes. Because if we flip the first array in the
up/down direction, then they have the same shapes.



Note: The length of each dimension in the given `grid` does not exceed 50.



s



posted @ 2018-03-10 23:55 [Grandyang](http://www.cnblogs.com/grandyang/)
阅读(...) 评论(...) [编辑](https://i.cnblogs.com/EditPosts.aspx?postid=8542820) 收藏

[刷新评论](javascript:void\(0\);)刷新页面返回顶部

### 公告

Copyright (C)2018 Grandyang










## 712 - Minimum ASCII Delete Sum for Two Strings
~2~  ['Dynamic Programming']
Given two strings s1, s2, find the lowest ASCII sum of deleted characters to make two strings equal.

Example 1:

Input: s1 = "sea", s2 = "eat"
Output: 231
Explanation: Deleting "s" from "sea" adds the ASCII value of "s" (115) to the sum.
Deleting "t" from "eat" adds 116 to the sum.
At the end, both strings are equal, and 115 + 116 = 231 is the minimum sum possible to achieve this.



Example 2:

Input: s1 = "delete", s2 = "leet"
Output: 403
Explanation: Deleting "dee" from "delete" to turn the string into "let",
adds 100[d]+101[e]+101[e] to the sum.  Deleting "e" from "leet" adds 101[e] to the sum.
At the end, both strings are equal to "let", and the answer is 100+101+101+101 = 403.
If instead we turned both strings into "lee" or "eet", we would get answers of 433 or 417, which are higher.



Note:
0 < s1.length, s2.length <= 1000.
All elements of each string will have an ASCII value in [97, 122].










## 713 - Subarray Product Less Than K
~2~  ['Array', 'Two Pointers']
Your are given an array of positive integers nums.
Count and print the number of (contiguous) subarrays where the product of all the elements in the subarray is less than k.

Example 1:

Input: nums = [10, 5, 2, 6], k = 100
Output: 8
Explanation: The 8 subarrays that have product less than 100 are: [10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6].
Note that [10, 5, 2] is not included as the product of 100 is not strictly less than k.



Note:
0 < nums.length <= 50000.
0 < nums[i] < 1000.
0 <= k < 10^6.










## 714 - Best Time to Buy and Sell Stock with Transaction Fee
~2~  ['Array', 'Dynamic Programming', 'Greedy']
Your are given an array of integers prices, for which the i-th element is the price of a given stock on day i; and a non-negative integer fee representing a transaction fee.
You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction.  You may not buy more than 1 share of a stock at a time (ie. you must sell the stock share before you buy again.)
Return the maximum profit you can make.

Example 1:

Input: prices = [1, 3, 2, 8, 4, 9], fee = 2
Output: 8
Explanation: The maximum profit can be achieved by:
Buying at prices[0] = 1Selling at prices[3] = 8Buying at prices[4] = 4Selling at prices[5] = 9The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.



Note:
0 < prices.length <= 50000.
0 < prices[i] < 50000.
0 <= fee < 50000.










## 715 - Range Module
~3~  ['Array', 'Segment Tree', 'Binary Search Tree']
A Range Module is a module that tracks ranges of numbers. Your task is to design and implement the following interfaces in an efficient manner.

addRange(int left, int right) Adds the half-open interval [left, right), tracking every real number in that interval.  Adding an interval that partially overlaps with currently tracked numbers should add any numbers in the interval [left, right) that are not already tracked.

queryRange(int left, int right) Returns true if and only if every real number in the interval [left, right)
 is currently being tracked.

removeRange(int left, int right) Stops tracking every real number currently being tracked in the interval [left, right).

Example 1:

addRange(10, 20): null
removeRange(14, 16): null
queryRange(10, 14): true (Every number in [10, 14) is being tracked)
queryRange(13, 15): false (Numbers like 14, 14.03, 14.17 in [13, 15) are not being tracked)
queryRange(16, 17): true (The number 16 in [16, 17) is still being tracked, despite the remove operation)



Note:
A half open interval [left, right) denotes all real numbers left <= x < right.

0 < left < right < 10^9 in all calls to addRange, queryRange, removeRange.
The total number of calls to addRange in a single test case is at most 1000.
The total number of calls to queryRange in a single test case is at most 5000.
The total number of calls to removeRange in a single test case is at most 1000.










## 716 - Max Stack
~3~  []
Design a max stack that supports push, pop, top, peekMax and popMax.



  1. push(x) -- Push element x onto stack.
  2. pop() -- Remove the element on top of the stack and return it.
  3. top() -- Get the element on the top.
  4. peekMax() -- Retrieve the maximum element in the stack.
  5. popMax() -- Retrieve the maximum element in the stack, and remove it. If you find more than one maximum elements, only remove the top-most one.



Example 1:



    MaxStack stack = new MaxStack();stack.push(5); stack.push(1);stack.push(5);stack.top(); -> 5stack.popMax(); -> 5stack.top(); -> 1stack.peekMax(); -> 5stack.pop(); -> 1stack.top(); -> 5



Note:

  1. -1e7 <= x <= 1e7
  2. Number of operations won't exceed 10000.
  3. The last four operations won't be called when stack is empty.










## 717 - 1-bit and 2-bit Characters
~1~  ['Array']
We have two special characters. The first character can be represented by one bit 0. The second character can be represented by two bits (10 or 11).  

Now given a string represented by several bits. Return whether the last character must be a one-bit character or not. The given string will always end with a zero.

Example 1:

Input: 
bits = [1, 0, 0]
Output: True
Explanation: 
The only way to decode it is two-bit character and one-bit character. So the last character is one-bit character.



Example 2:

Input: 
bits = [1, 1, 1, 0]
Output: False
Explanation: 
The only way to decode it is two-bit character and two-bit character. So the last character is NOT one-bit character.



Note:
1 <= len(bits) <= 1000.
bits[i] is always 0 or 1.










## 718 - Maximum Length of Repeated Subarray
~2~  ['Array', 'Hash Table', 'Binary Search', 'Dynamic Programming']
Given two integer arrays A and B, return the maximum length of an subarray that appears in both arrays.

Example 1:

Input:
A: [1,2,3,2,1]
B: [3,2,1,4,7]
Output: 3
Explanation: 
The repeated subarray with maximum length is [3, 2, 1].



Note:

1 <= len(A), len(B) <= 1000
0 <= A[i], B[i] < 100










## 719 - Find K-th Smallest Pair Distance
~3~  ['Array', 'Binary Search', 'Heap']
Given an integer array, return the k-th smallest distance among all the pairs. The distance of a pair (A, B) is defined as the absolute difference between A and B. 

Example 1:

Input:
nums = [1,3,1]
k = 1
Output: 0 
Explanation:
Here are all the pairs:
(1,3) -> 2
(1,1) -> 0
(3,1) -> 2
Then the 1st smallest distance pair is (1,1), and its distance is 0.



Note:

2 <= len(nums) <= 10000.
0 <= nums[i] < 1000000.
1 <= k <= len(nums) * (len(nums) - 1) / 2.










## 720 - Longest Word in Dictionary
~1~  ['Hash Table', 'Trie']
Given a list of strings words representing an English Dictionary, find the longest word in words that can be built one character at a time by other words in words.  If there is more than one possible answer, return the longest word with the smallest lexicographical order.  If there is no answer, return the empty string.

Example 1:

Input: 
words = ["w","wo","wor","worl", "world"]
Output: "world"
Explanation: 
The word "world" can be built one character at a time by "w", "wo", "wor", and "worl".



Example 2:

Input: 
words = ["a", "banana", "app", "appl", "ap", "apply", "apple"]
Output: "apple"
Explanation: 
Both "apply" and "apple" can be built from other words in the dictionary. However, "apple" is lexicographically smaller than "apply".



Note:
All the strings in the input will only contain lowercase letters.
The length of words will be in the range [1, 1000].
The length of words[i] will be in the range [1, 30].










## 721 - Accounts Merge
~2~  ['Depth-first Search', 'Union Find']
Given a list accounts, each element accounts[i] is a list of strings, where the first element accounts[i][0] is a name, and the rest of the elements are emails representing emails of the account, in sorted order.

Now, we would like to merge these accounts.  Two accounts definitely belong to the same person if there is some email that is common to both accounts.  Note that even if two accounts have the same name, they may belong to different people as people could have the same name.  A person can have any number of accounts initially, but all of their accounts definitely have the same name.

After merging the accounts, return the accounts in the format they were given: the first element of each account is the name, and the rest of the elements are emails in sorted order.  The accounts themselves can be returned in any order.

Example 1:

Input: 
accounts = [["John", "johnsmith@mail.com", "john00@mail.com"], ["John", "johnnybravo@mail.com"], ["John", "johnsmith@mail.com", "john_newyork@mail.com"], ["Mary", "mary@mail.com"]]
Output: [["John", 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com'],  ["John", "johnnybravo@mail.com"], ["Mary", "mary@mail.com"]]
Explanation: 
The first and third John's are the same person as they have the common email "johnsmith@mail.com".
The second John and Mary are different people as none of their email addresses are used by other accounts.
We could return these lists in any order, for example the answer [['Mary', 'mary@mail.com'], ['John', 'johnnybravo@mail.com'], 
['John', 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com']] would still be accepted.



Note:
The length of accounts will be in the range [1, 1000].
The length of accounts[i] will be in the range [1, 10].
The length of accounts[i][j] will be in the range [1, 30].










## 722 - Remove Comments
~2~  ['String']
Given a C++ program, remove comments from it. The program source is an array where source[i] is the i-th line of the source code.  This represents the result of splitting the original source code string by the newline character \n.

In C++, there are two types of comments, line comments, and block comments.

The string // denotes a line comment, which represents that it and rest of the characters to the right of it in the same line should be ignored.

The string /* denotes a block comment, which represents that all characters until the next (non-overlapping) occurrence of */ should be ignored.  (Here, occurrences happen in reading order: line by line from left to right.)  To be clear, the string /*/ does not yet end the block comment, as the ending would be overlapping the beginning.

The first effective comment takes precedence over others: if the string // occurs in a block comment, it is ignored. Similarly, if the string /* occurs in a line or block comment, it is also ignored.

If a certain line of code is empty after removing comments, you must not output that line: each string in the answer list will be non-empty.

There will be no control characters, single quote, or double quote characters.  For example, source = "string s = "/* Not a comment. */";" will not be a test case.  (Also, nothing else such as defines or macros will interfere with the comments.)

It is guaranteed that every open block comment will eventually be closed, so /* outside of a line or block comment always starts a new comment.

Finally, implicit newline characters can be deleted by block comments.  Please see the examples below for details.


After removing the comments from the source code, return the source code in the same format.

Example 1:

Input: 
source = ["/*Test program */", "int main()", "{ ", "  // variable declaration ", "int a, b, c;", "/* This is a test", "   multiline  ", "   comment for ", "   testing */", "a = b + c;", "}"]

The line by line code is visualized as below:
/*Test program */
int main()
{ 
  // variable declaration 
int a, b, c;
/* This is a test
   multiline  
   comment for 
   testing */
a = b + c;
}

Output: ["int main()","{ ","  ","int a, b, c;","a = b + c;","}"]

The line by line code is visualized as below:
int main()
{ 
  
int a, b, c;
a = b + c;
}

Explanation: 
The string /* denotes a block comment, including line 1 and lines 6-9. The string // denotes line 4 as comments.



Example 2:

Input: 
source = ["a/*comment", "line", "more_comment*/b"]
Output: ["ab"]
Explanation: The original source string is "a/*comment\nline\nmore_comment*/b", where we have bolded the newline characters.  After deletion, the implicit newline characters are deleted, leaving the string "ab", which when delimited by newline characters becomes ["ab"].



Note:
The length of source is in the range [1, 100].
The length of source[i] is in the range [0, 80].
Every open block comment is eventually closed.
There are no single-quote, double-quote, or control characters in the source code.










## 723 - Candy Crush
~2~  ['Array', 'Two Pointers']
This question is about implementing a basic elimination algorithm for Candy Crush.

Given a 2D integer array board representing the grid of candy, different positive integers board[i][j] represent different types of candies.  A value of board[i][j] = 0 represents that the cell at position (i, j) is empty.  The given board represents the state of the game following the player's move.  Now, you need to restore the board to a stable state by crushing candies according to the following rules:


If three or more candies of the same type are adjacent vertically or horizontally, "crush" them all at the same time - these positions become empty.
After crushing all candies simultaneously, if an empty space on the board has candies on top of itself, then these candies will drop until they hit a candy or bottom at the same time. (No new candies will drop outside the top boundary.)
After the above steps, there may exist more candies that can be crushed.  If so, you need to repeat the above steps.
If there does not exist more candies that can be crushed (ie. the board is stable), then return the current board.


You need to perform the above rules until the board becomes stable, then return the current board.

Example 1:

Input:
board = 
[[110,5,112,113,114],[210,211,5,213,214],[310,311,3,313,314],[410,411,412,5,414],[5,1,512,3,3],[610,4,1,613,614],[710,1,2,713,714],[810,1,2,1,1],[1,1,2,2,2],[4,1,4,4,1014]]
Output:
[[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[110,0,0,0,114],[210,0,0,0,214],[310,0,0,113,314],[410,0,0,213,414],[610,211,112,313,614],[710,311,412,613,714],[810,411,512,713,1014]]
Explanation: 




Note:

The length of board will be in the range [3, 50].
The length of board[i] will be in the range [3, 50].
Each board[i][j] will initially start as an integer in the range [1, 2000].










## 724 - Find Pivot Index
~1~  []
Given an array of integers nums, write a method that returns the "pivot" index of this array.

We define the pivot index as the index where the sum of the numbers to the left of the index is equal to the sum of the numbers to the right of the index.

If no such index exists, we should return -1. If there are multiple pivot indexes, you should return the left-most pivot index.


Example 1:

Input: 
nums = [1, 7, 3, 6, 5, 6]
Output: 3
Explanation: 
The sum of the numbers to the left of index 3 (nums[3] = 6) is equal to the sum of numbers to the right of index 3.
Also, 3 is the first index where this occurs.



Example 2:

Input: 
nums = [1, 2, 3]
Output: -1
Explanation: 
There is no index that satisfies the conditions in the problem statement.



Note:
The length of nums will be in the range [0, 10000].
Each element nums[i] will be an integer in the range [-1000, 1000].










## 725 - Split Linked List in Parts
~2~  []
Given a (singly) linked list with head node root, write a function to split the linked list into k consecutive linked list "parts".

The length of each part should be as equal as possible: no two parts should have a size differing by more than 1.  This may lead to some parts being null.

The parts should be in order of occurrence in the input list, and parts occurring earlier should always have a size greater than or equal parts occurring later.

Return a List of ListNode's representing the linked list parts that are formed.


Examples
1->2->3->4, k = 5 // 5 equal parts
[ [1], 
[2],
[3],
[4],
null ]

Example 1:

Input: 
root = [1, 2, 3], k = 5
Output: [[1],[2],[3],[],[]]
Explanation:
The input and each element of the output are ListNodes, not arrays.
For example, the input root has root.val = 1, root.next.val = 2, \root.next.next.val = 3, and root.next.next.next = null.
The first element output[0] has output[0].val = 1, output[0].next = null.
The last element output[4] is null, but it's string representation as a ListNode is [].



Example 2:

Input: 
root = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], k = 3
Output: [[1, 2, 3, 4], [5, 6, 7], [8, 9, 10]]
Explanation:
The input has been split into consecutive parts with size difference at most 1, and earlier parts are a larger size than the later parts.



Note:
The length of root will be in the range [0, 1000].
Each value of a node in the input will be an integer in the range [0, 999].
k will be an integer in the range [1, 50].










## 726 - Number of Atoms
~3~  []
Given a chemical formula (given as a string), return the count of each atom.

An atomic element always starts with an uppercase character, then zero or more lowercase letters, representing the name.

1 or more digits representing the count of that element may follow if the count is greater than 1.  If the count is 1, no digits will follow.  For example, H2O and H2O2 are possible, but H1O2 is impossible.

Two formulas concatenated together produce another formula.  For example, H2O2He3Mg4 is also a formula.  

A formula placed in parentheses, and a count (optionally added) is also a formula.  For example, (H2O2) and (H2O2)3 are formulas.

Given a formula, output the count of all elements as a string in the following form: the first name (in sorted order), followed by its count (if that count is more than 1), followed by the second name (in sorted order), followed by its count (if that count is more than 1), and so on.

Example 1:

Input: 
formula = "H2O"
Output: "H2O"
Explanation: 
The count of elements are {'H': 2, 'O': 1}.



Example 2:

Input: 
formula = "Mg(OH)2"
Output: "H2MgO2"
Explanation: 
The count of elements are {'H': 2, 'Mg': 1, 'O': 2}.



Example 3:

Input: 
formula = "K4(ON(SO3)2)2"
Output: "K4N2O14S4"
Explanation: 
The count of elements are {'K': 4, 'N': 2, 'O': 14, 'S': 4}.



Note:
All atom names consist of lowercase letters, except for the first character which is uppercase.
The length of formula will be in the range [1, 1000].
formula will only consist of letters, digits, and round parentheses, and is a valid formula as defined in the problem.










## 728 - Self Dividing Numbers
~1~  []
A self-dividing number is a number that is divisible by every digit it contains.

For example, 128 is a self-dividing number because 128 % 1 == 0, 128 % 2 == 0, and 128 % 8 == 0.

Also, a self-dividing number is not allowed to contain the digit zero.

Given a lower and upper number bound, output a list of every possible self dividing number, including the bounds if possible.

Example 1:

Input: 
left = 1, right = 22
Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]



Note:
The boundaries of each input argument are 1 <= left <= right <= 10000.










## 729 - My Calendar I
~2~  []
Implement a MyCalendar class to store your events. A new event can be added if adding the event will not cause a double booking.

Your class will have the method, book(int start, int end).  Formally, this represents a booking on the half open interval [start, end), the range of real numbers x such that start <= x < end.

A double booking happens when two events have some non-empty intersection (ie., there is some time that is common to both events.)

For each call to the method MyCalendar.book, return true if the event can be added to the calendar successfully without causing a double booking.  Otherwise, return false and do not add the event to the calendar.


Your class will be called like this:
MyCalendar cal = new MyCalendar();
MyCalendar.book(start, end)

Example 1:

MyCalendar();
MyCalendar.book(10, 20); // returns true
MyCalendar.book(15, 25); // returns false
MyCalendar.book(20, 30); // returns true
Explanation: 
The first event can be booked.  The second can't because time 15 is already booked by another event.
The third event can be booked, as the first event takes every time less than 20, but not including 20.



Note:
The number of calls to MyCalendar.book per test case will be at most 1000.
In calls to MyCalendar.book(start, end), start and end are integers in the range [0, 10^9].










## 730 - Count Different Palindromic Subsequences
~3~  []
Given a string S, find the number of different non-empty palindromic subsequences in S, and return that number modulo 10^9 + 7.

A subsequence of a string S is obtained by deleting 0 or more characters from S.

A sequence is palindromic if it is equal to the sequence reversed.

Two sequences A_1, A_2, ... and B_1, B_2, ... are different if there is some i for which A_i != B_i.


Example 1:

Input: 
S = 'bccb'
Output: 6
Explanation: 
The 6 different non-empty palindromic subsequences are 'b', 'c', 'bb', 'cc', 'bcb', 'bccb'.
Note that 'bcb' is counted only once, even though it occurs twice.



Example 2:

Input: 
S = 'abcdabcdabcdabcdabcdabcdabcdabcddcbadcbadcbadcbadcbadcbadcbadcba'
Output: 104860361
Explanation: 
There are 3104860382 different non-empty palindromic subsequences, which is 104860361 modulo 10^9 + 7.



Note:
The length of S will be in the range [1, 1000].
Each character S[i] will be in the set {'a', 'b', 'c', 'd'}.










## 731 - My Calendar II
~2~  []
Implement a MyCalendarTwo class to store your events. A new event can be added if adding the event will not cause a triple booking.

Your class will have one method, book(int start, int end).  Formally, this represents a booking on the half open interval [start, end), the range of real numbers x such that start <= x < end.

A triple booking happens when three events have some non-empty intersection (ie., there is some time that is common to all 3 events.)

For each call to the method MyCalendar.book, return true if the event can be added to the calendar successfully without causing a triple booking.  Otherwise, return false and do not add the event to the calendar.


Your class will be called like this:
MyCalendar cal = new MyCalendar();
MyCalendar.book(start, end)

Example 1:

MyCalendar();
MyCalendar.book(10, 20); // returns true
MyCalendar.book(50, 60); // returns true
MyCalendar.book(10, 40); // returns true
MyCalendar.book(5, 15); // returns false
MyCalendar.book(5, 10); // returns true
MyCalendar.book(25, 55); // returns true
Explanation: 
The first two events can be booked.  The third event can be double booked.
The fourth event (5, 15) can't be booked, because it would result in a triple booking.
The fifth event (5, 10) can be booked, as it does not use time 10 which is already double booked.
The sixth event (25, 55) can be booked, as the time in [25, 40) will be double booked with the third event;
the time [40, 50) will be single booked, and the time [50, 55) will be double booked with the second event.



Note:
The number of calls to MyCalendar.book per test case will be at most 1000.
In calls to MyCalendar.book(start, end), start and end are integers in the range [0, 10^9].










## 732 - My Calendar III
~3~  []
Implement a MyCalendarThree class to store your events. A new event can always be added.

Your class will have one method, book(int start, int end).  Formally, this represents a booking on the half open interval [start, end), the range of real numbers x such that start <= x < end.

A K-booking happens when K events have some non-empty intersection (ie., there is some time that is common to all K events.)

For each call to the method MyCalendar.book, return an integer K representing the largest integer such that there exists a K-booking in the calendar.


Your class will be called like this:
MyCalendarThree cal = new MyCalendarThree();
MyCalendarThree.book(start, end)

Example 1:

MyCalendarThree();
MyCalendarThree.book(10, 20); // returns 1
MyCalendarThree.book(50, 60); // returns 1
MyCalendarThree.book(10, 40); // returns 2
MyCalendarThree.book(5, 15); // returns 3
MyCalendarThree.book(5, 10); // returns 3
MyCalendarThree.book(25, 55); // returns 3
Explanation: 
The first two events can be booked and are disjoint, so the maximum K-booking is a 1-booking.
The third event [10, 40) intersects the first event, and the maximum K-booking is a 2-booking.
The remaining events cause the maximum K-booking to be only a 3-booking.
Note that the last event locally causes a 2-booking, but the answer is still 3 because
eg. [10, 20), [10, 40), and [5, 15) are still triple booked.



Note:
The number of calls to MyCalendarThree.book per test case will be at most 400.
In calls to MyCalendarThree.book(start, end), start and end are integers in the range [0, 10^9].










## 733 - Flood Fill
~1~  []
An image is represented by a 2-D array of integers, each integer representing the pixel value of the image (from 0 to 65535).

Given a coordinate (sr, sc) representing the starting pixel (row and column) of the flood fill, and a pixel value newColor, "flood fill" the image.

To perform a "flood fill", consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color as the starting pixel), and so on.  Replace the color of all of the aforementioned pixels with the newColor.

At the end, return the modified image.

Example 1:

Input: 
image = [[1,1,1],[1,1,0],[1,0,1]]
sr = 1, sc = 1, newColor = 2
Output: [[2,2,2],[2,2,0],[2,0,1]]
Explanation: 
From the center of the image (with position (sr, sc) = (1, 1)), all pixels connected 
by a path of the same color as the starting pixel are colored with the new color.
Note the bottom corner is not colored 2, because it is not 4-directionally connected
to the starting pixel.



Note:
The length of image and image[0] will be in the range [1, 50].
The given starting pixel will satisfy 0 <= sr < image.length and 0 <= sc < image[0].length.
The value of each color in image[i][j] and newColor will be an integer in [0, 65535].










## 734 - Sentence Similarity
~1~  []
Given two sentences `words1, words2` (each represented as an array of
strings), and a list of similar word pairs `pairs`, determine if two sentences
are similar.

For example, "great acting skills" and "fine drama talent" are similar, if the
similar word pairs are `pairs = [["great", "fine"], ["acting","drama"],
["skills","talent"]]`.

Note that the similarity relation is not transitive. For example, if "great"
and "fine" are similar, and "fine" and "good" are similar, "great" and "good"
are not necessarily similar.

However, similarity is symmetric. For example, "great" and "fine" being
similar is the same as "fine" and "great" being similar.

Also, a word is always similar with itself. For example, the sentences `words1
= ["great"], words2 = ["great"], pairs = []` are similar, even though there
are no specified similar word pairs.

Finally, sentences can only be similar if they have the same number of words.
So a sentence like `words1 = ["great"]` can never be similar to `words2 =
["doubleplus","good"]`.

Note:

  * The length of `words1` and `words2` will not exceed `1000`.
  * The length of `pairs` will not exceed `2000`.
  * The length of each `pairs[i]` will be `2`.
  * The length of each `words[i]` and `pairs[i][j]` will be in the range `[1, 20]`.










## 735 - Asteroid Collision
~2~  []
We are given an array asteroids of integers representing asteroids in a row.

For each asteroid, the absolute value represents its size, and the sign represents its direction (positive meaning right, negative meaning left).  Each asteroid moves at the same speed.

Find out the state of the asteroids after all collisions.  If two asteroids meet, the smaller one will explode.  If both are the same size, both will explode.  Two asteroids moving in the same direction will never meet.


Example 1:

Input: 
asteroids = [5, 10, -5]
Output: [5, 10]
Explanation: 
The 10 and -5 collide resulting in 10.  The 5 and 10 never collide.



Example 2:

Input: 
asteroids = [8, -8]
Output: []
Explanation: 
The 8 and -8 collide exploding each other.



Example 3:

Input: 
asteroids = [10, 2, -5]
Output: [10]
Explanation: 
The 2 and -5 collide resulting in -5.  The 10 and -5 collide resulting in 10.



Example 4:

Input: 
asteroids = [-2, -1, 1, 2]
Output: [-2, -1, 1, 2]
Explanation: 
The -2 and -1 are moving left, while the 1 and 2 are moving right.
Asteroids moving the same direction never meet, so no asteroids will meet each other.



Note:
The length of asteroids will be at most 10000.
Each asteroid will be a non-zero integer in the range [-1000, 1000]..










## 736 - Parse Lisp Expression
~3~  []
You are given a string expression representing a Lisp-like expression to return the integer value of.

The syntax for these expressions is given as follows.

An expression is either an integer, a let-expression, an add-expression, a mult-expression, or an assigned variable.  Expressions always evaluate to a single integer.

(An integer could be positive or negative.)

A let-expression takes the form (let v1 e1 v2 e2 ... vn en expr), where let is always the string "let", then there are 1 or more pairs of alternating variables and expressions, meaning that the first variable v1 is assigned the value of the expression e1, the second variable v2 is assigned the value of the expression e2, and so on sequentially; and then the value of this let-expression is the value of the expression expr.

An add-expression takes the form (add e1 e2) where add is always the string "add", there are always two expressions e1, e2, and this expression evaluates to the addition of the evaluation of e1 and the evaluation of e2.

A mult-expression takes the form (mult e1 e2) where mult is always the string "mult", there are always two expressions e1, e2, and this expression evaluates to the multiplication of the evaluation of e1 and the evaluation of e2.

For the purposes of this question, we will use a smaller subset of variable names.  A variable starts with a lowercase letter, then zero or more lowercase letters or digits.  Additionally for your convenience, the names "add", "let", or "mult" are protected and will never be used as variable names.

Finally, there is the concept of scope.  When an expression of a variable name is evaluated, within the context of that evaluation, the innermost scope (in terms of parentheses) is checked first for the value of that variable, and then outer scopes are checked sequentially.  It is guaranteed that every expression is legal.  Please see the examples for more details on scope.


Evaluation Examples:

Input: (add 1 2)
Output: 3

Input: (mult 3 (add 2 3))
Output: 15

Input: (let x 2 (mult x 5))
Output: 10

Input: (let x 2 (mult x (let x 3 y 4 (add x y))))
Output: 14
Explanation: In the expression (add x y), when checking for the value of the variable x,
we check from the innermost scope to the outermost in the context of the variable we are trying to evaluate.
Since x = 3 is found first, the value of x is 3.

Input: (let x 3 x 2 x)
Output: 2
Explanation: Assignment in let statements is processed sequentially.

Input: (let x 1 y 2 x (add x y) (add x y))
Output: 5
Explanation: The first (add x y) evaluates as 3, and is assigned to x.
The second (add x y) evaluates as 3+2 = 5.

Input: (let x 2 (add (let x 3 (let x 4 x)) x))
Output: 6
Explanation: Even though (let x 4 x) has a deeper scope, it is outside the context
of the final x in the add-expression.  That final x will equal 2.

Input: (let a1 3 b2 (add a1 1) b2) 
Output 4
Explanation: Variable names can contain digits after the first character.



Note:
The given string expression is well formatted: There are no leading or trailing spaces, there is only a single space separating different components of the string, and no space between adjacent parentheses.  The expression is guaranteed to be legal and evaluate to an integer.
The length of expression is at most 2000.  (It is also non-empty, as that would not be a legal expression.)
The answer and all intermediate calculations of that answer are guaranteed to fit in a 32-bit integer.










## 737 - Sentence Similarity II
~2~  []
Given two sentences `words1, words2` (each represented as an array of
strings), and a list of similar word pairs `pairs`, determine if two sentences
are similar.

For example, `words1 = ["great", "acting", "skills"]` and `words2 = ["fine",
"drama", "talent"]` are similar, if the similar word pairs are `pairs =
[["great", "good"], ["fine", "good"], ["acting","drama"],
["skills","talent"]]`.

Note that the similarity relation is transitive. For example, if "great" and
"good" are similar, and "fine" and "good" are similar, then "great" and "fine"
are similar.

Similarity is also symmetric. For example, "great" and "fine" being similar is
the same as "fine" and "great" being similar.

Also, a word is always similar with itself. For example, the sentences `words1
= ["great"], words2 = ["great"], pairs = []` are similar, even though there
are no specified similar word pairs.

Finally, sentences can only be similar if they have the same number of words.
So a sentence like `words1 = ["great"]` can never be similar to `words2 =
["doubleplus","good"]`.

Note:

  * The length of `words1` and `words2` will not exceed `1000`.
  * The length of `pairs` will not exceed `2000`.
  * The length of each `pairs[i]` will be `2`.
  * The length of each `words[i]` and `pairs[i][j]` will be in the range `[1, 20]`.










## 738 - Monotone Increasing Digits
~2~  []
Given a non-negative integer N, find the largest number that is less than or equal to N with monotone increasing digits.

(Recall that an integer has monotone increasing digits if and only if each pair of adjacent digits x and y satisfy x <= y.)


Example 1:

Input: N = 10
Output: 9



Example 2:

Input: N = 1234
Output: 1234



Example 3:

Input: N = 332
Output: 299



Note:
N is an integer in the range [0, 10^9].










## 739 - Daily Temperatures
~2~  []
Given a list of daily temperatures, produce a list that, for each day in the input, tells you how many days you would have to wait until a warmer temperature.  If there is no future day for which this is possible, put 0 instead.

For example, given the list temperatures = [73, 74, 75, 71, 69, 72, 76, 73], your output should be [1, 1, 4, 2, 1, 1, 0, 0].


Note:
The length of temperatures will be in the range [1, 30000].
Each temperature will be an integer in the range [30, 100].










## 740 - Delete and Earn
~2~  []
Given an array nums of integers, you can perform operations on the array.

In each operation, you pick any nums[i] and delete it to earn nums[i] points.  After, you must delete every element equal to nums[i] - 1 or nums[i] + 1.

You start with 0 points.  Return the maximum number of points you can earn by applying such operations.


Example 1:

Input: nums = [3, 4, 2]
Output: 6
Explanation: 
Delete 4 to earn 4 points, consequently 3 is also deleted.
Then, delete 2 to earn 2 points. 6 total points are earned.



Example 2:

Input: nums = [2, 2, 3, 3, 3, 4]
Output: 9
Explanation: 
Delete 3 to earn 3 points, deleting both 2's and the 4.
Then, delete 3 again to earn 3 points, and 3 again to earn 3 points.
9 total points are earned.



Note:
The length of nums is at most 20000.
Each element nums[i] is an integer in the range [1, 10000].










## 741 - Cherry Pickup
~3~  []
In a N x N grid representing a field of cherries, each cell is one of three possible integers.

0 means the cell is empty, so you can pass through;
1 means the cell contains a cherry, that you can pick up and pass through;
-1 means the cell contains a thorn that blocks your way.

Your task is to collect maximum number of cherries possible by following the rules below:

Starting at the position (0, 0) and reaching (N-1, N-1) by moving right or down through valid path cells (cells with value 0 or 1);
After reaching (N-1, N-1), returning to (0, 0) by moving left or up through valid path cells;
When passing through a path cell containing a cherry, you pick it up and the cell becomes an empty cell (0);
If there is no valid path between (0, 0) and (N-1, N-1), then no cherries can be collected.


Example 1:

Input: grid =
[[0, 1, -1],
 [1, 0, -1],
 [1, 1,  1]]
Output: 5
Explanation: 
The player started at (0, 0) and went down, down, right right to reach (2, 2).
4 cherries were picked up during this single trip, and the matrix becomes [[0,1,-1],[0,0,-1],[0,0,0]].
Then, the player went left, up, up, left to return home, picking up one more cherry.
The total number of cherries picked up is 5, and this is the maximum possible.



Note:
grid is an N by N 2D array, with 1 <= N <= 50.
Each grid[i][j] is an integer in the set {-1, 0, 1}.
It is guaranteed that grid[0][0] and grid[N-1][N-1] are not -1.










## 742 - To Lower Case
~1~  []
Implement function ToLowerCase() that has a string parameter str, and returns the same string in lowercase.

 


Example 1:


Input: "Hello"
Output: "hello"



Example 2:


Input: "here"
Output: "here"



Example 3:


Input: "LOVELY"
Output: "lovely"










## 744 - Network Delay Time
~2~  []
There are N network nodes, labelled 1 to N.

Given times, a list of travel times as directed edges times[i] = (u, v, w), where u is the source node, v is the target node, and w is the time it takes for a signal to travel from source to target.

Now, we send a signal from a certain node K.  How long will it take for all nodes to receive the signal?  If it is impossible, return -1.


Note:

N will be in the range [1, 100].
K will be in the range [1, N].
The length of times will be in the range [1, 6000].
All edges times[i] = (u, v, w) will have 1 <= u, v <= N and 1 <= w <= 100.










## 745 - Find Smallest Letter Greater Than Target
~1~  []
Given a list of sorted characters letters containing only lowercase letters, and given a target letter target, find the smallest element in the list that is larger than the given target.

Letters also wrap around.  For example, if the target is target = 'z' and letters = ['a', 'b'], the answer is 'a'.


Examples:

Input:
letters = ["c", "f", "j"]
target = "a"
Output: "c"

Input:
letters = ["c", "f", "j"]
target = "c"
Output: "f"

Input:
letters = ["c", "f", "j"]
target = "d"
Output: "f"

Input:
letters = ["c", "f", "j"]
target = "g"
Output: "j"

Input:
letters = ["c", "f", "j"]
target = "j"
Output: "c"

Input:
letters = ["c", "f", "j"]
target = "k"
Output: "c"



Note:

letters has a length in range [2, 10000].
letters consists of lowercase letters, and contains at least 2 unique letters.
target is a lowercase letter.










## 746 - Prefix and Suffix Search
~3~  []
Given many words, words[i] has weight i.

Design a class WordFilter that supports one function, WordFilter.f(String prefix, String suffix).
It will return the word with given prefix and suffix with maximum weight.  If no word exists, return -1.


Examples:

Input:
WordFilter(["apple"])
WordFilter.f("a", "e") // returns 0
WordFilter.f("b", "") // returns -1


Note:

words has length in range [1, 15000].
For each test case, up to words.length queries WordFilter.f may be made.
words[i] has length in range [1, 10].
prefix, suffix have lengths in range [0, 10].
words[i] and prefix, suffix queries consist of lowercase letters only.










## 747 - Min Cost Climbing Stairs
~1~  []
On a staircase, the i-th step has some non-negative cost cost[i] assigned (0 indexed).

Once you pay the cost, you can either climb one or two steps. You need to find minimum cost to reach the top of the floor, and you can either start from the step with index 0, or the step with index 1.


Example 1:

Input: cost = [10, 15, 20]
Output: 15
Explanation: Cheapest is start on cost[1], pay that cost and go to the top.



Example 2:

Input: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]
Output: 6
Explanation: Cheapest is start on cost[0], and only step on 1s, skipping cost[3].



Note:

cost will have a length in the range [2, 1000].
Every cost[i] will be an integer in the range [0, 999].










## 748 - Largest Number At Least Twice of Others
~1~  []
In a given integer array nums, there is always exactly one largest element.

Find whether the largest element in the array is at least twice as much as every other number in the array.

If it is, return the index of the largest element, otherwise return -1.

Example 1:


Input: nums = [3, 6, 1, 0]
Output: 1
Explanation: 6 is the largest integer, and for every other number in the array x,
6 is more than twice as big as x.  The index of value 6 is 1, so we return 1.


 

Example 2:


Input: nums = [1, 2, 3, 4]
Output: -1
Explanation: 4 isn't at least as big as twice the value of 3, so we return -1.


 

Note:


	nums will have a length in the range [1, 50].
	Every nums[i] will be an integer in the range [0, 99].


 










## 749 - Shortest Completing Word
~2~  []
Find the minimum length word from a given dictionary words, which has all the letters from the string licensePlate.  Such a word is said to complete the given string licensePlate

Here, for letters we ignore case.  For example, "P" on the licensePlate still matches "p" on the word.

It is guaranteed an answer exists.  If there are multiple answers, return the one that occurs first in the array.

The license plate might have the same letter occurring multiple times.  For example, given a licensePlate of "PP", the word "pair" does not complete the licensePlate, but the word "supper" does.


Example 1:

Input: licensePlate = "1s3 PSt", words = ["step", "steps", "stripe", "stepple"]
Output: "steps"
Explanation: The smallest length word that contains the letters "S", "P", "S", and "T".
Note that the answer is not "step", because the letter "s" must occur in the word twice.
Also note that we ignored case for the purposes of comparing whether a letter exists in the word.



Example 2:

Input: licensePlate = "1s3 456", words = ["looks", "pest", "stew", "show"]
Output: "pest"
Explanation: There are 3 smallest length words that contains the letters "s".
We return the one that occurred first.



Note:

licensePlate will be a string with length in range [1, 7].
licensePlate will contain digits, spaces, or letters (uppercase or lowercase).
words will have a length in the range [10, 1000].
Every words[i] will consist of lowercase letters, and have length in range [1, 15].










## 750 - Contain Virus
~3~  []
A virus is spreading rapidly, and your task is to quarantine the infected area by installing walls.

The world is modeled as a 2-D array of cells, where 0 represents uninfected cells, and 1 represents cells contaminated with the virus.  A wall (and only one wall) can be installed between any two 4-directionally adjacent cells, on the shared boundary.

Every night, the virus spreads to all neighboring cells in all four directions unless blocked by a wall.
Resources are limited. Each day, you can install walls around only one region -- the affected area (continuous block of infected cells) that threatens the most uninfected cells the following night. There will never be a tie.

Can you save the day? If so, what is the number of walls required? If not, and the world becomes fully infected, return the number of walls used.


Example 1:

Input: grid = 
[[0,1,0,0,0,0,0,1],
 [0,1,0,0,0,0,0,1],
 [0,0,0,0,0,0,0,1],
 [0,0,0,0,0,0,0,0]]
Output: 10
Explanation:
There are 2 contaminated regions.
On the first day, add 5 walls to quarantine the viral region on the left. The board after the virus spreads is:

[[0,1,0,0,0,0,1,1],
 [0,1,0,0,0,0,1,1],
 [0,0,0,0,0,0,1,1],
 [0,0,0,0,0,0,0,1]]

On the second day, add 5 walls to quarantine the viral region on the right. The virus is fully contained.



Example 2:

Input: grid = 
[[1,1,1],
 [1,0,1],
 [1,1,1]]
Output: 4
Explanation: Even though there is only one cell saved, there are 4 walls built.
Notice that walls are only built on the shared boundary of two different cells.



Example 3:

Input: grid = 
[[1,1,1,0,0,0,0,0,0],
 [1,0,1,0,1,1,1,1,1],
 [1,1,1,0,0,0,0,0,0]]
Output: 13
Explanation: The region on the left only builds two new walls.



Note:

The number of rows and columns of grid will each be in the range [1, 50].
Each grid[i][j] will be either 0 or 1.
Throughout the described process, there is always a contiguous viral region that will infect strictly more uncontaminated squares in the next round.










## 751 - Number Of Corner Rectangles
~2~  []
Given a start IP address `ip` and a number of ips we need to cover `n`, return
a representation of the range as a list (of smallest possible length) of CIDR
blocks.

A CIDR block is a string consisting of an IP, followed by a slash, and then
the prefix length. For example: "123.45.67.89/20". That prefix length "20"
represents the number of common prefix bits in the specified range.

**Example 1:**


    **Input:** ip = "255.0.0.7", n = 10**Output:** ["255.0.0.7/32","255.0.0.8/29","255.0.0.16/32"]**Explanation:**The initial ip address, when converted to binary, looks like this (spaces added for clarity):255.0.0.7 - > 11111111 00000000 00000000 00000111The address "255.0.0.7/32" specifies all addresses with a common prefix of 32 bits to the given address,ie. just this one address.The address "255.0.0.8/29" specifies all addresses with a common prefix of 29 bits to the given address:255.0.0.8 -> 11111111 00000000 00000000 00001000Addresses with common prefix of 29 bits are:11111111 00000000 00000000 0000100011111111 00000000 00000000 0000100111111111 00000000 00000000 0000101011111111 00000000 00000000 0000101111111111 00000000 00000000 0000110011111111 00000000 00000000 0000110111111111 00000000 00000000 0000111011111111 00000000 00000000 00001111The address "255.0.0.16/32" specifies all addresses with a common prefix of 32 bits to the given address,ie. just 11111111 00000000 00000000 00010000.In total, the answer specifies the range of 10 ips starting with the address 255.0.0.7 .There were other representations, such as:["255.0.0.7/32","255.0.0.8/30", "255.0.0.12/30", "255.0.0.16/32"],but our answer was the shortest possible.Also note that a representation beginning with say, "255.0.0.7/30" would be incorrect,because it includes addresses like 255.0.0.4 = 11111111 00000000 00000000 00000100 that are outside the specified range.

**Note:**
    1. `ip` will be a valid IPv4 address.
    2. Every implied address `ip + x` (for `x < n`) will be a valid IPv4 address.
    3. `n` will be an integer in the range `[1, 1000]`.










## 753 - Open the Lock
~2~  []
You have a lock in front of you with 4 circular wheels.  Each wheel has 10 slots: '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'.  The wheels can rotate freely and wrap around: for example we can turn '9' to be '0', or '0' to be '9'.  Each move consists of turning one wheel one slot.

The lock initially starts at '0000', a string representing the state of the 4 wheels.

You are given a list of deadends dead ends, meaning if the lock displays any of these codes, the wheels of the lock will stop turning and you will be unable to open it.

Given a target representing the value of the wheels that will unlock the lock, return the minimum total number of turns required to open the lock, or -1 if it is impossible.


Example 1:

Input: deadends = ["0201","0101","0102","1212","2002"], target = "0202"
Output: 6
Explanation:
A sequence of valid moves would be "0000" -> "1000" -> "1100" -> "1200" -> "1201" -> "1202" -> "0202".
Note that a sequence like "0000" -> "0001" -> "0002" -> "0102" -> "0202" would be invalid,
because the wheels of the lock become stuck after the display becomes the dead end "0102".



Example 2:

Input: deadends = ["8888"], target = "0009"
Output: 1
Explanation:
We can turn the last wheel in reverse to move from "0000" -> "0009".



Example 3:

Input: deadends = ["8887","8889","8878","8898","8788","8988","7888","9888"], target = "8888"
Output: -1
Explanation:
We can't reach the target without getting stuck.



Example 4:

Input: deadends = ["0000"], target = "8888"
Output: -1



Note:

The length of deadends will be in the range [1, 500].
target will not be in the list deadends.
Every string in deadends and the string target will be a string of 4 digits from the 10,000 possibilities '0000' to '9999'.










## 754 - Cracking the Safe
~3~  []
There is a box protected by a password.  The password is n digits, where each letter can be one of the first k digits 0, 1, ..., k-1.

You can keep inputting the password, the password will automatically be matched against the last n digits entered.

For example, assuming the password is "345", I can open it when I type "012345", but I enter a total of 6 digits.

Please return any string of minimum length that is guaranteed to open the box after the entire string is inputted.


Example 1:

Input: n = 1, k = 2
Output: "01"
Note: "10" will be accepted too.



Example 2:

Input: n = 2, k = 2
Output: "00110"
Note: "01100", "10011", "11001" will be accepted too.



Note:

n will be in the range [1, 4].
k will be in the range [1, 10].
k^n will be at most 4096.










## 755 - Reach a Number
~2~  []
You are standing at position 0 on an infinite number line.  There is a goal at position target.

On each move, you can either go left or right.  During the n-th move (starting from 1), you take n steps.

Return the minimum number of steps required to reach the destination.


Example 1:

Input: target = 3
Output: 2
Explanation:
On the first move we step from 0 to 1.
On the second step we step from 1 to 3.



Example 2:

Input: target = 2
Output: 3
Explanation:
On the first move we step from 0 to 1.
On the second move we step  from 1 to -1.
On the third move we step from -1 to 2.



Note:
target will be a non-zero integer in the range [-10^9, 10^9].










## 757 - Pyramid Transition Matrix
~2~  []
We are stacking blocks to form a pyramid.  Each block has a color which is a one letter string, like `'Z'`.

For every block of color `C` we place not in the bottom row, we are placing it on top of a left block of color `A` and right block of color `B`.  We are allowed to place the block there only if `(A, B, C)` is an allowed triple.

We start with a bottom row of bottom, represented as a single string.  We also start with a list of allowed triples allowed.  Each allowed triple is represented as a string of length 3.

Return true if we can build the pyramid all the way to the top, otherwise false.


Example 1:

Input: bottom = "XYZ", allowed = ["XYD", "YZE", "DEA", "FFF"]
Output: true
Explanation:
We can stack the pyramid like this:
    A
   / \
  D   E
 / \ / \
X   Y   Z

This works because ('X', 'Y', 'D'), ('Y', 'Z', 'E'), and ('D', 'E', 'A') are allowed triples.



Example 2:

Input: bottom = "XXYX", allowed = ["XXX", "XXY", "XYX", "XYY", "YXZ"]
Output: false
Explanation:
We can't stack the pyramid to the top.
Note that there could be allowed triples (A, B, C) and (A, B, D) with C != D.



Note:

bottom will be a string with length in range [2, 8].
allowed will have length in range [0, 200].
Letters in all strings will be chosen from the set {'A', 'B', 'C', 'D', 'E', 'F', 'G'}.










## 758 - Convert Binary Search Tree to Sorted Doubly Linked List
~2~  []
Given a set of keywords `words` and a string `S`, make all appearances of all
keywords in `S` bold. Any letters between `<b>` and `</b>` tags become bold.

The returned string should use the least number of tags possible, and of
course the tags should form a valid combination.

For example, given that `words = ["ab", "bc"]` and `S = "aabcd"`, we should
return `"a<b>abc</b>d"`. Note that returning `"a<b>a<b>b</b>c</b>d"` would use
more tags, so it is incorrect.

Note:

  1. `words` has length in range `[0, 50]`.
  2. `words[i]` has length in range `[1, 10]`.
  3. `S` has length in range `[0, 500]`.
  4. All characters in `words[i]` and `S` are lowercase letters.










## 759 - Set Intersection Size At Least Two
~3~  []
An integer interval [a, b] (for integers a < b) is a set of all consecutive integers from a to b, including a and b.

Find the minimum size of a set S such that for every integer interval A in intervals, the intersection of S with A has size at least 2.


Example 1:

Input: intervals = [[1, 3], [1, 4], [2, 5], [3, 5]]
Output: 3
Explanation:
Consider the set S = {2, 3, 4}.  For each interval, there are at least 2 elements from S in the interval.
Also, there isn't a smaller size set that fulfills the above condition.
Thus, we output the size of this set, which is 3.



Example 2:

Input: intervals = [[1, 2], [2, 3], [2, 4], [4, 5]]
Output: 5
Explanation:
An example of a minimum sized set is {1, 2, 3, 4, 5}.



Note:
intervals will have length in range [1, 3000].
intervals[i] will have length 2, representing some integer interval.
intervals[i][j] will be an integer in [0, 10^8].










## 760 - Bold Words in String
~1~  []
Given two lists `A `and `B`, and `B` is an anagram of `A`. `B` is an anagram
of `A` means `B` is made by randomizing the order of the elements in `A`.

We want to find an  _index mapping_  `P`, from `A` to `B`. A mapping `P[i] =
j` means the `i`th element in `A` appears in `B` at index `j`.

These lists `A` and `B` may contain duplicates. If there are multiple answers,
output any of them.

For example, given



    A = [12, 28, 46, 32, 50]B = [50, 12, 32, 46, 28]



We should return



    [1, 4, 3, 2, 0]

as `P[0] = 1` because the `0`th element of `A` appears at `B[1]`, and `P[1] =
4` because the `1`st element of `A`appears at `B[4]`, and so on.



Note:

  1. `A, B` have equal lengths in range `[1, 100]`.
  2. `A[i], B[i]` are integers in range `[0, 10^5]`.










## 763 - Special Binary String
~3~  []
Special binary strings are binary strings with the following two properties:

The number of 0's is equal to the number of 1's.
Every prefix of the binary string has at least as many 1's as 0's.

Given a special string S, a move consists of choosing two consecutive, non-empty, special substrings of S, and swapping them.  (Two strings are consecutive if the last character of the first string is exactly one index before the first character of the second string.)

At the end of any number of moves, what is the lexicographically largest resulting string possible?


Example 1:

Input: S = "11011000"
Output: "11100100"
Explanation:
The strings "10" [occuring at S[1]] and "1100" [at S[3]] are swapped.
This is the lexicographically largest string possible after some number of swaps.



Note:
S has length at most 50.
S is guaranteed to be a special binary string as defined above.










## 764 - N-ary Tree Level Order Traversal
~1~  []
Given an n-ary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).

For example, given a 3-ary tree:
 


 

We should return its level order traversal:

 

 


[
     [1],
     [3,2,4],
     [5,6]
]


 

Note:


	The depth of the tree is at most 1000.
	The total number of nodes is at most 5000.


 










## 766 - Flatten a Multilevel Doubly Linked List
~2~  []
You are given a doubly linked list which in addition to the next and previous pointers, it could have a child pointer, which may or may not point to a separate doubly linked list. These child lists may have one or more children of their own, and so on, to produce a multilevel data structure, as shown in the example below.

Flatten the list so that all the nodes appear in a single-level, doubly linked list. You are given the head of the first level of the list.

Example:


Input:
 1---2---3---4---5---6--NULL
         |
         7---8---9---10--NULL
             |
             11--12--NULL

Output:
1-2-3-7-8-11-12-9-10-4-5-6-NULL


Explanation for the above example:

Given the following multilevel doubly linked list:



We should return the following flattened doubly linked list:










## 767 - Prime Number of Set Bits in Binary Representation
~1~  []
Given two integers L and R, find the count of numbers in the range [L, R] (inclusive) having a prime number of set bits in their binary representation.

(Recall that the number of set bits an integer has is the number of 1s present when written in binary.  For example, 21 written in binary is 10101 which has 3 set bits.  Also, 1 is not a prime.)


Example 1:
Input: L = 6, R = 10
Output: 4
Explanation:
6 -> 110 (2 set bits, 2 is prime)
7 -> 111 (3 set bits, 3 is prime)
9 -> 1001 (2 set bits , 2 is prime)
10->1010 (2 set bits , 2 is prime)


Example 2:
Input: L = 10, R = 15
Output: 5
Explanation:
10 -> 1010 (2 set bits, 2 is prime)
11 -> 1011 (3 set bits, 3 is prime)
12 -> 1100 (2 set bits, 2 is prime)
13 -> 1101 (3 set bits, 3 is prime)
14 -> 1110 (3 set bits, 3 is prime)
15 -> 1111 (4 set bits, 4 is not prime)


Note:
L, R will be integers L <= R in the range [1, 10^6].
R - L will be at most 10000.










## 768 - Partition Labels
~2~  []
A string S of lowercase letters is given.  We want to partition this string into as many parts as possible so that each letter appears in at most one part, and return a list of integers representing the size of these parts.


Example 1:

Input: S = "ababcbacadefegdehijhklij"
Output: [9,7,8]
Explanation:
The partition is "ababcbaca", "defegde", "hijhklij".
This is a partition so that each letter appears in at most one part.
A partition like "ababcbacadefegde", "hijhklij" is incorrect, because it splits S into less parts.



Note:
S will have length in range [1, 500].
S will consist of lowercase letters ('a' to 'z') only.










## 769 - Largest Plus Sign
~2~  []
In a 2D grid from (0, 0) to (N-1, N-1), every cell contains a 1, except those cells in the given list mines which are 0.  What is the largest axis-aligned plus sign of 1s contained in the grid?  Return the order of the plus sign.  If there is none, return 0.

An "axis-aligned plus sign of 1s of order k" has some center grid[x][y] = 1 along with 4 arms of length k-1 going up, down, left, and right, and made of 1s.  This is demonstrated in the diagrams below.  Note that there could be 0s or 1s beyond the arms of the plus sign, only the relevant area of the plus sign is checked for 1s.


Examples of Axis-Aligned Plus Signs of Order k:
Order 1:
000
010
000

Order 2:
00000
00100
01110
00100
00000

Order 3:
0000000
0001000
0001000
0111110
0001000
0001000
0000000


Example 1:
Input: N = 5, mines = [[4, 2]]
Output: 2
Explanation:
11111
11111
11111
11111
11011
In the above grid, the largest plus sign can only be order 2.  One of them is marked in bold.


Example 2:
Input: N = 2, mines = []
Output: 1
Explanation:
There is no plus sign of order 2, but there is of order 1.


Example 3:
Input: N = 1, mines = [[0, 0]]
Output: 0
Explanation:
There is no plus sign, so return 0.


Note:
N will be an integer in the range [1, 500].
mines will have length at most 5000.
mines[i] will be length 2 and consist of integers in the range [0, N-1].
(Additionally, programs submitted in C, C++, or C# will be judged with a slightly smaller time limit.)










## 770 - Couples Holding Hands
~3~  []
N couples sit in 2N seats arranged in a row and want to hold hands.  We want to know the minimum number of swaps so that every couple is sitting side by side.  A swap consists of choosing any two people, then they stand up and switch seats. 

The people and seats are represented by an integer from 0 to 2N-1, the couples are numbered in order, the first couple being (0, 1), the second couple being (2, 3), and so on with the last couple being (2N-2, 2N-1).

The couples' initial seating is given by row[i] being the value of the person who is initially sitting in the i-th seat.

Example 1:
Input: row = [0, 2, 1, 3]
Output: 1
Explanation: We only need to swap the second (row[1]) and third (row[2]) person.


Example 2:
Input: row = [3, 2, 0, 1]
Output: 0
Explanation: All couples are already seated side by side.



Note:
 
 len(row) is even and in the range of [4, 60].
 row is guaranteed to be a permutation of 0...len(row)-1.










## 772 - Construct Quad Tree
~1~  []
We want to use quad trees to store an N x N boolean grid. Each cell in the grid can only be true or false. The root node represents the whole grid. For each node, it will be subdivided into four children nodes until the values in the region it represents are all the same.

Each node has another two boolean attributes : isLeaf and val. isLeaf is true if and only if the node is a leaf node. The val attribute for a leaf node contains the value of the region it represents.

Your task is to use a quad tree to represent a given grid. The following example may help you understand the problem better:

Given the 8 x 8 grid below, we want to construct the corresponding quad tree:



It can be divided according to the definition above:



 

The corresponding quad tree should be as following, where each node is represented as a (isLeaf, val) pair.

For the non-leaf nodes, val can be arbitrary, so it is represented as *.



Note:


	N is less than 1000 and guaranteened to be a power of 2.
	If you want to know more about the quad tree, you can refer to its wiki.










## 773 - Quad Tree Intersection
~1~  []
A quadtree is a tree data in which each internal node has exactly four children: topLeft, topRight, bottomLeft and bottomRight. Quad trees are often used to partition a two-dimensional space by recursively subdividing it into four quadrants or regions.

We want to store True/False information in our quad tree. The quad tree is used to represent a N * N boolean grid. For each node, it will be subdivided into four children nodes until the values in the region it represents are all the same. Each node has another two boolean attributes : isLeaf and val. isLeaf is true if and only if the node is a leaf node. The val attribute for a leaf node contains the value of the region it represents.

For example, below are two quad trees A and B:


A:
+-------+-------+   T: true
|       |       |   F: false
|   T   |   T   |
|       |       |
+-------+-------+
|       |       |
|   F   |   F   |
|       |       |
+-------+-------+
topLeft: T
topRight: T
bottomLeft: F
bottomRight: F

B:               
+-------+---+---+
|       | F | F |
|   T   +---+---+
|       | T | T |
+-------+---+---+
|       |       |
|   T   |   F   |
|       |       |
+-------+-------+
topLeft: T
topRight:
     topLeft: F
     topRight: F
     bottomLeft: T
     bottomRight: T
bottomLeft: T
bottomRight: F


 

Your task is to implement a function that will take two quadtrees and return a quadtree that represents the logical OR (or union) of the two trees.


A:                 B:                 C (A or B):
+-------+-------+  +-------+---+---+  +-------+-------+
|       |       |  |       | F | F |  |       |       |
|   T   |   T   |  |  T    +---+---+  |   T   |   T   |
|       |       |  |       | T | T |  |       |       |
+-------+-------+  +-------+---+---+  +-------+-------+
|       |       |  |       |       |  |       |       |
|   F   |   F   |  |   T   |   F   |  |   T   |   F   |
|       |       |  |       |       |  |       |       |
+-------+-------+  +-------+-------+  +-------+-------+


Note:


	N is guaranteened to be a power of 2.
	If you want to know more about the quad tree, you can refer to its wiki.
	The logic OR operation is define as this: "A or B" is true if A is true, or if B is true, or if both A and B are true.










## 774 - Maximum Depth of N-ary Tree
~1~  []
Given a n-ary tree, find its maximum depth.

The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.

For example, given a 3-ary tree:
 


 

We should return its max depth, which is 3.

Note:


	The depth of the tree is at most 1000.
	The total number of nodes is at most 5000.


 










## 775 - N-ary Tree Preorder Traversal
~1~  []
Given an n-ary tree, return the preorder traversal of its nodes' values.
 

For example, given a 3-ary tree:


 

Return its preorder traversal as: [1,3,5,6,2,4].
 

Note: Recursive solution is trivial, could you do it iteratively?










## 776 - N-ary Tree Postorder Traversal
~1~  []
Given an n-ary tree, return the postorder traversal of its nodes' values.
 

For example, given a 3-ary tree:


 

Return its postorder traversal as: [5,6,3,2,4,1].
 

Note: Recursive solution is trivial, could you do it iteratively?










## 777 - Toeplitz Matrix
~1~  []
A matrix is Toeplitz if every diagonal from top-left to bottom-right has the same element.

Now given an M x N matrix, return True if and only if the matrix is Toeplitz.
 

Example 1:


Input:
matrix = [
  [1,2,3,4],
  [5,1,2,3],
  [9,5,1,2]
]
Output: True
Explanation:
In the above grid, the diagonals are:
"[9]", "[5, 5]", "[1, 1, 1]", "[2, 2, 2]", "[3, 3]", "[4]".
In each diagonal all elements are the same, so the answer is True.


Example 2:


Input:
matrix = [
  [1,2],
  [2,2]
]
Output: False
Explanation:
The diagonal "[1, 2]" has different elements.



Note:


	matrix will be a 2D array of integers.
	matrix will have a number of rows and columns in range [1, 20].
	matrix[i][j] will be integers in range [0, 99].



Follow up:


	What if the matrix is stored on disk, and the memory is limited such that you can only load at most one row of the matrix into the memory at once?
	What if the matrix is so large that you can only load up a partial row into the memory at once?










## 778 - Reorganize String
~2~  []
Given a string S, check if the letters can be rearranged so that two characters that are adjacent to each other are not the same.

If possible, output any possible result.  If not possible, return the empty string.

Example 1:


Input: S = "aab"
Output: "aba"


Example 2:


Input: S = "aaab"
Output: ""


Note:


	S will consist of lowercase letters and have length in range [1, 500].


 










## 779 - Max Chunks To Make Sorted II
~3~  []
This question is the same as "Max Chunks to Make Sorted" except the integers of the given array are not necessarily distinct, the input array could be up to length 2000, and the elements could be up to 10**8.



Given an array arr of integers (not necessarily distinct), we split the array into some number of "chunks" (partitions), and individually sort each chunk.  After concatenating them, the result equals the sorted array.

What is the most number of chunks we could have made?

Example 1:


Input: arr = [5,4,3,2,1]
Output: 1
Explanation:
Splitting into two or more chunks will not return the required result.
For example, splitting into [5, 4], [3, 2, 1] will result in [4, 5, 1, 2, 3], which isn't sorted.


Example 2:


Input: arr = [2,1,3,4,4]
Output: 4
Explanation:
We can split into two chunks, such as [2, 1], [3, 4, 4].
However, splitting into [2, 1], [3], [4], [4] is the highest number of chunks possible.


Note:


	arr will have length in range [1, 2000].
	arr[i] will be an integer in range [0, 10**8].


 










## 780 - Max Chunks To Make Sorted
~2~  []
Given an array arr that is a permutation of [0, 1, ..., arr.length - 1], we split the array into some number of "chunks" (partitions), and individually sort each chunk.  After concatenating them, the result equals the sorted array.

What is the most number of chunks we could have made?

Example 1:


Input: arr = [4,3,2,1,0]
Output: 1
Explanation:
Splitting into two or more chunks will not return the required result.
For example, splitting into [4, 3], [2, 1, 0] will result in [3, 4, 0, 1, 2], which isn't sorted.


Example 2:


Input: arr = [1,0,2,3,4]
Output: 4
Explanation:
We can split into two chunks, such as [1, 0], [2, 3, 4].
However, splitting into [1, 0], [2], [3], [4] is the highest number of chunks possible.


Note:


	arr will have length in range [1, 10].
	arr[i] will be a permutation of [0, 1, ..., arr.length - 1].


 










## 781 - Basic Calculator IV
~3~  []
Given an expression such as expression = "e + 8 - a + 5" and an evaluation map such as {"e": 1} (given in terms of evalvars = ["e"] and evalints = [1]), return a list of tokens representing the simplified expression, such as ["-1*a","14"]


	An expression alternates chunks and symbols, with a space separating each chunk and symbol.
	A chunk is either an expression in parentheses, a variable, or a non-negative integer.
	A variable is a string of lowercase letters (not including digits.) Note that variables can be multiple letters, and note that variables never have a leading coefficient or unary operator like "2x" or "-x".


Expressions are evaluated in the usual order: brackets first, then multiplication, then addition and subtraction. For example, expression = "1 + 2 * 3" has an answer of ["7"].

The format of the output is as follows:


	For each term of free variables with non-zero coefficient, we write the free variables within a term in sorted order lexicographically. For example, we would never write a term like "b*a*c", only "a*b*c".
	Terms have degree equal to the number of free variables being multiplied, counting multiplicity. (For example, "a*a*b*c" has degree 4.) We write the largest degree terms of our answer first, breaking ties by lexicographic order ignoring the leading coefficient of the term.
	The leading coefficient of the term is placed directly to the left with an asterisk separating it from the variables (if they exist.)  A leading coefficient of 1 is still printed.
	An example of a well formatted answer is ["-2*a*a*a", "3*a*a*b", "3*b*b", "4*a", "5*c", "-6"] 
	Terms (including constant terms) with coefficient 0 are not included.  For example, an expression of "0" has an output of [].


Examples:


Input: expression = "e + 8 - a + 5", evalvars = ["e"], evalints = [1]
Output: ["-1*a","14"]

Input: expression = "e - 8 + temperature - pressure",
evalvars = ["e", "temperature"], evalints = [1, 12]
Output: ["-1*pressure","5"]

Input: expression = "(e + 8) * (e - 8)", evalvars = [], evalints = []
Output: ["1*e*e","-64"]

Input: expression = "7 - 7", evalvars = [], evalints = []
Output: []

Input: expression = "a * b * c + b * a * c * 4", evalvars = [], evalints = []
Output: ["5*a*b*c"]

Input: expression = "((a - b) * (b - c) + (c - a)) * ((a - b) + (b - c) * (c - a))",
evalvars = [], evalints = []
Output: ["-1*a*a*b*b","2*a*a*b*c","-1*a*a*c*c","1*a*b*b*b","-1*a*b*b*c","-1*a*b*c*c","1*a*c*c*c","-1*b*b*b*c","2*b*b*c*c","-1*b*c*c*c","2*a*a*b","-2*a*a*c","-2*a*b*b","2*a*c*c","1*b*b*b","-1*b*b*c","1*b*c*c","-1*c*c*c","-1*a*a","1*a*b","1*a*c","-1*b*c"]


Note:


	expression will have length in range [1, 250].
	evalvars, evalints will have equal lengths in range [0, 100].










## 782 - Jewels and Stones
~1~  []
You're given strings J representing the types of stones that are jewels, and S representing the stones you have.  Each character in S is a type of stone you have.  You want to know how many of the stones you have are also jewels.

The letters in J are guaranteed distinct, and all characters in J and S are letters. Letters are case sensitive, so "a" is considered a different type of stone from "A".

Example 1:


Input: J = "aA", S = "aAAbbbb"
Output: 3


Example 2:


Input: J = "z", S = "ZZ"
Output: 0


Note:


	S and J will consist of letters and have length at most 50.
	The characters in J are distinct.










## 783 - Search in a Binary Search Tree
~1~  []
Given the root node of a binary search tree (BST) and a value. You need to find the node in the BST that the node's value equals the given value. Return the subtree rooted with that node. If such node doesn't exist, you should return NULL.

For example, 


Given the tree:
        4
       / \
      2   7
     / \
    1   3

And the value to search: 2


You should return this subtree:


      2     
     / \   
    1   3


In the example above, if we want to search the value 5, since there is no node with value 5, we should return NULL.

Note that an empty tree is represented by NULL, therefore you would see the expected output (serialized tree format) as [], not null.










## 784 - Insert into a Binary Search Tree
~2~  []
Given the root node of a binary search tree (BST) and a value to be inserted into the tree, insert the value into the BST. Return the root node of the BST after the insertion. It is guaranteed that the new value does not exist in the original BST.

Note that there may exist multiple valid ways for the insertion, as long as the tree remains a BST after insertion. You can return any of them.

For example, 


Given the tree:
        4
       / \
      2   7
     / \
    1   3
And the value to insert: 5


You can return this binary search tree:


         4
       /   \
      2     7
     / \   /
    1   3 5


This tree is also valid:


         5
       /   \
      2     7
     / \   
    1   3
         \
          4










## 787 - Sliding Puzzle
~3~  []
On a 2x3 board, there are 5 tiles represented by the integers 1 through 5, and an empty square represented by 0.

A move consists of choosing 0 and a 4-directionally adjacent number and swapping it.

The state of the board is solved if and only if the board is [[1,2,3],[4,5,0]].

Given a puzzle board, return the least number of moves required so that the state of the board is solved. If it is impossible for the state of the board to be solved, return -1.

Examples:


Input: board = [[1,2,3],[4,0,5]]
Output: 1
Explanation: Swap the 0 and the 5 in one move.



Input: board = [[1,2,3],[5,4,0]]
Output: -1
Explanation: No number of moves will make the board solved.



Input: board = [[4,1,2],[5,0,3]]
Output: 5
Explanation: 5 is the smallest number of moves that solves the board.
An example path:
After move 0: [[4,1,2],[5,0,3]]
After move 1: [[4,1,2],[0,5,3]]
After move 2: [[0,1,2],[4,5,3]]
After move 3: [[1,0,2],[4,5,3]]
After move 4: [[1,2,0],[4,5,3]]
After move 5: [[1,2,3],[4,5,0]]



Input: board = [[3,2,4],[1,5,0]]
Output: 14


Note:


	board will be a 2 x 3 array as described above.
	board[i][j] will be a permutation of [0, 1, 2, 3, 4, 5].










## 789 - Kth Largest Element in a Stream
~1~  []
Design a class to find the kth largest element in a stream. Note that it is the kth largest element in the sorted order, not the kth distinct element.

Your KthLargest class will have a constructor which accepts an integer k and an integer array nums, which contains initial elements from the stream. For each call to the method KthLargest.add, return the element representing the kth largest element in the stream.

Example:


int k = 3;
int[] arr = [4,5,8,2];
KthLargest kthLargest = new KthLargest(3, arr);
kthLargest.add(3);   // returns 4
kthLargest.add(5);   // returns 5
kthLargest.add(10);  // returns 5
kthLargest.add(9);   // returns 8
kthLargest.add(4);   // returns 8


Note: 
You may assume that nums' length ≥ k-1 and k ≥ 1.










## 790 - Global and Local Inversions
~2~  []
We have some permutation A of [0, 1, ..., N - 1], where N is the length of A.

The number of (global) inversions is the number of i < j with 0 <= i < j < N and A[i] > A[j].

The number of local inversions is the number of i with 0 <= i < N and A[i] > A[i+1].

Return true if and only if the number of global inversions is equal to the number of local inversions.

Example 1:


Input: A = [1,0,2]
Output: true
Explanation: There is 1 global inversion, and 1 local inversion.


Example 2:


Input: A = [1,2,0]
Output: false
Explanation: There are 2 global inversions, and 1 local inversion.


Note:


	A will be a permutation of [0, 1, ..., A.length - 1].
	A will have length in range [1, 5000].
	The time limit for this problem has been reduced.










## 792 - Binary Search
~1~  []
Given a sorted (in ascending order) integer array nums of n elements and a target value, write a function to search target in nums. If target exists, then return its index, otherwise return -1.


Example 1:


Input: nums = [-1,0,3,5,9,12], target = 9
Output: 4
Explanation: 9 exists in nums and its index is 4



Example 2:


Input: nums = [-1,0,3,5,9,12], target = 2
Output: -1
Explanation: 2 does not exist in nums so return -1


 

Note:


	You may assume that all elements in nums are unique.
	n will be in the range [1, 10000].
	The value of each element in nums will be in the range [-9999, 9999].










## 793 - Swap Adjacent in LR String
~2~  []
In a string composed of 'L', 'R', and 'X' characters, like "RXXLRXRXL", a move consists of either replacing one occurrence of "XL" with "LX", or replacing one occurrence of "RX" with "XR". Given the starting string start and the ending string end, return True if and only if there exists a sequence of moves to transform one string to the other.

Example:


Input: start = "RXXLRXRXL", end = "XRLXXRRLX"
Output: True
Explanation:
We can transform start to end following these steps:
RXXLRXRXL ->
XRXLRXRXL ->
XRLXRXRXL ->
XRLXXRRXL ->
XRLXXRRLX


Note:


	1 <= len(start) = len(end) <= 10000.
	Both start and end will only consist of characters in {'L', 'R', 'X'}.










## 794 - Swim in Rising Water
~3~  []
On an N x N grid, each square grid[i][j] represents the elevation at that point (i,j).

Now rain starts to fall. At time t, the depth of the water everywhere is t. You can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most t. You can swim infinite distance in zero time. Of course, you must stay within the boundaries of the grid during your swim.

You start at the top left square (0, 0). What is the least time until you can reach the bottom right square (N-1, N-1)?

Example 1:


Input: [[0,2],[1,3]]
Output: 3
Explanation:
At time 0, you are in grid location (0, 0).
You cannot go anywhere else because 4-directionally adjacent neighbors have a higher elevation than t = 0.

You cannot reach point (1, 1) until time 3.
When the depth of water is 3, we can swim anywhere inside the grid.


Example 2:


Input: [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]]
Output: 16
Explanation:
 0  1  2  3  4
24 23 22 21  5
12 13 14 15 16
11 17 18 19 20
10  9  8  7  6

The final route is marked in bold.
We need to wait until time 16 so that (0, 0) and (4, 4) are connected.


Note:


	2 <= N <= 50.
	grid[i][j] is a permutation of [0, ..., N*N - 1].










## 795 - K-th Symbol in Grammar
~2~  []
On the first row, we write a 0. Now in every subsequent row, we look at the previous row and replace each occurrence of 0 with 01, and each occurrence of 1 with 10.

Given row N and index K, return the K-th indexed symbol in row N. (The values of K are 1-indexed.) (1 indexed).


Examples:
Input: N = 1, K = 1
Output: 0

Input: N = 2, K = 1
Output: 0

Input: N = 2, K = 2
Output: 1

Input: N = 4, K = 5
Output: 1

Explanation:
row 1: 0
row 2: 01
row 3: 0110
row 4: 01101001


Note:


	N will be an integer in the range [1, 30].
	K will be an integer in the range [1, 2^(N-1)].










## 796 - Reaching Points
~3~  []
A move consists of taking a point (x, y) and transforming it to either (x, x+y) or (x+y, y).

Given a starting point (sx, sy) and a target point (tx, ty), return True if and only if a sequence of moves exists to transform the point (sx, sy) to (tx, ty). Otherwise, return False.


Examples:
Input: sx = 1, sy = 1, tx = 3, ty = 5
Output: True
Explanation:
One series of moves that transforms the starting point to the target is:
(1, 1) -> (1, 2)
(1, 2) -> (3, 2)
(3, 2) -> (3, 5)

Input: sx = 1, sy = 1, tx = 2, ty = 2
Output: False

Input: sx = 1, sy = 1, tx = 1, ty = 1
Output: True



Note:


	sx, sy, tx, ty will all be integers in the range [1, 10^9].










## 797 - Rabbits in Forest
~2~  []
In a forest, each rabbit has some color. Some subset of rabbits (possibly all of them) tell you how many other rabbits have the same color as them. Those answers are placed in an array.

Return the minimum number of rabbits that could be in the forest.


Examples:
Input: answers = [1, 1, 2]
Output: 5
Explanation:
The two rabbits that answered "1" could both be the same color, say red.
The rabbit than answered "2" can't be red or the answers would be inconsistent.
Say the rabbit that answered "2" was blue.
Then there should be 2 other blue rabbits in the forest that didn't answer into the array.
The smallest possible number of rabbits in the forest is therefore 5: 3 that answered plus 2 that didn't.

Input: answers = [10, 10, 10]
Output: 11

Input: answers = []
Output: 0


Note:


	answers will have length at most 1000.
	Each answers[i] will be an integer in the range [0, 999].










## 798 - Transform to Chessboard
~3~  []
An N x N board contains only 0s and 1s. In each move, you can swap any 2 rows with each other, or any 2 columns with each other.

What is the minimum number of moves to transform the board into a "chessboard" - a board where no 0s and no 1s are 4-directionally adjacent? If the task is impossible, return -1.


Examples:
Input: board = [[0,1,1,0],[0,1,1,0],[1,0,0,1],[1,0,0,1]]
Output: 2
Explanation:
One potential sequence of moves is shown below, from left to right:

0110     1010     1010
0110 --> 1010 --> 0101
1001     0101     1010
1001     0101     0101

The first move swaps the first and second column.
The second move swaps the second and third row.


Input: board = [[0, 1], [1, 0]]
Output: 0
Explanation:
Also note that the board with 0 in the top left corner,
01
10

is also a valid chessboard.

Input: board = [[1, 0], [1, 0]]
Output: -1
Explanation:
No matter what sequence of moves you make, you cannot end with a valid chessboard.


Note:


	board will have the same number of rows and columns, a number in the range [2, 30].
	board[i][j] will be only 0s or 1s.










## 799 - Minimum Distance Between BST Nodes
~1~  []
Given a Binary Search Tree (BST) with the root node root, return the minimum difference between the values of any two different nodes in the tree.

Example :


Input: root = [4,2,6,1,3,null,null]
Output: 1
Explanation:
Note that root is a TreeNode object, not an array.

The given tree [4,2,6,1,3,null,null] is represented by the following diagram:

          4
        /   \
      2      6
     / \    
    1   3  

while the minimum difference in this tree is 1, it occurs between node 1 and node 2, also between node 3 and node 2.


Note:


	The size of the BST will be between 2 and 100.
	The BST is always valid, each node's value is an integer, and each node's value is different.










## 800 - Letter Case Permutation
~1~  []
Given a string S, we can transform every letter individually to be lowercase or uppercase to create another string.  Return a list of all possible strings we could create.


Examples:
Input: S = "a1b2"
Output: ["a1b2", "a1B2", "A1b2", "A1B2"]

Input: S = "3z4"
Output: ["3z4", "3Z4"]

Input: S = "12345"
Output: ["12345"]


Note:


	S will be a string with length at most 12.
	S will consist only of letters or digits.










## 801 - Is Graph Bipartite?
~2~  []
Given an undirected graph, return true if and only if it is bipartite.

Recall that a graph is bipartite if we can split it's set of nodes into two independent subsets A and B such that every edge in the graph has one node in A and another node in B.

The graph is given in the following form: graph[i] is a list of indexes j for which the edge between nodes i and j exists.  Each node is an integer between 0 and graph.length - 1.  There are no self edges or parallel edges: graph[i] does not contain i, and it doesn't contain any element twice.


Example 1:
Input: [[1,3], [0,2], [1,3], [0,2]]
Output: true
Explanation: 
The graph looks like this:
0----1
|    |
|    |
3----2
We can divide the vertices into two groups: {0, 2} and {1, 3}.



Example 2:
Input: [[1,2,3], [0,2], [0,1,3], [0,2]]
Output: false
Explanation: 
The graph looks like this:
0----1
| \  |
|  \ |
3----2
We cannot find a way to divide the set of nodes into two independent subsets.


 

Note:


	graph will have length in range [1, 100].
	graph[i] will contain integers in range [0, graph.length - 1].
	graph[i] will not contain i or duplicate values.
	The graph is undirected: if any element j is in graph[i], then i will be in graph[j].










## 802 - K-th Smallest Prime Fraction
~3~  []
A sorted list A contains 1, plus some number of primes.  Then, for every p < q in the list, we consider the fraction p/q.

What is the K-th smallest fraction considered?  Return your answer as an array of ints, where answer[0] = p and answer[1] = q.


Examples:
Input: A = [1, 2, 3, 5], K = 3
Output: [2, 5]
Explanation:
The fractions to be considered in sorted order are:
1/5, 1/3, 2/5, 1/2, 3/5, 2/3.
The third fraction is 2/5.

Input: A = [1, 7], K = 1
Output: [1, 7]


Note:


	A will have length between 2 and 2000.
	Each A[i] will be between 1 and 30000.
	K will be between 1 and A.length * (A.length - 1) / 2.










## 803 - Cheapest Flights Within K Stops
~2~  []
There are n cities connected by m flights. Each fight starts from city u and arrives at v with a price w.

Now given all the cities and fights, together with starting city src and the destination dst, your task is to find the cheapest price from src to dst with up to k stops. If there is no such route, output -1.


Example 1:
Input: 
n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]
src = 0, dst = 2, k = 1
Output: 200
Explanation: 
The graph looks like this:


The cheapest price from city 0 to city 2 with at most 1 stop costs 200, as marked red in the picture.


Example 2:
Input: 
n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]
src = 0, dst = 2, k = 0
Output: 500
Explanation: 
The graph looks like this:


The cheapest price from city 0 to city 2 with at most 0 stop costs 500, as marked blue in the picture.

Note:


	The number of nodes n will be in range [1, 100], with nodes labeled from 0 to n - 1.
	The size of flights will be in range [0, n * (n - 1) / 2].
	The format of each flight will be (src, dst, price).
	The price of each flight will be in the range [1, 10000].
	k is in the range of [0, n - 1].
	There will not be any duplicated flights or self cycles.










## 804 - Rotated Digits
~1~  []
X is a good number if after rotating each digit individually by 180 degrees, we get a valid number that is different from X.  Each digit must be rotated - we cannot choose to leave it alone.

A number is valid if each digit remains a digit after rotation. 0, 1, and 8 rotate to themselves; 2 and 5 rotate to each other; 6 and 9 rotate to each other, and the rest of the numbers do not rotate to any other number and become invalid.

Now given a positive number N, how many numbers X from 1 to N are good?


Example:
Input: 10
Output: 4
Explanation: 
There are four good numbers in the range [1, 10] : 2, 5, 6, 9.
Note that 1 and 10 are not good numbers, since they remain unchanged after rotating.


Note:


	N  will be in range [1, 10000].










## 805 - Escape The Ghosts
~2~  []
You are playing a simplified Pacman game. You start at the point (0, 0), and your destination is (target[0], target[1]). There are several ghosts on the map, the i-th ghost starts at (ghosts[i][0], ghosts[i][1]).

Each turn, you and all ghosts simultaneously *may* move in one of 4 cardinal directions: north, east, west, or south, going from the previous point to a new point 1 unit of distance away.

You escape if and only if you can reach the target before any ghost reaches you (for any given moves the ghosts may take.)  If you reach any square (including the target) at the same time as a ghost, it doesn't count as an escape.

Return True if and only if it is possible to escape.


Example 1:
Input: 
ghosts = [[1, 0], [0, 3]]
target = [0, 1]
Output: true
Explanation: 
You can directly reach the destination (0, 1) at time 1, while the ghosts located at (1, 0) or (0, 3) have no way to catch up with you.



Example 2:
Input: 
ghosts = [[1, 0]]
target = [2, 0]
Output: false
Explanation: 
You need to reach the destination (2, 0), but the ghost at (1, 0) lies between you and the destination.



Example 3:
Input: 
ghosts = [[2, 0]]
target = [1, 0]
Output: false
Explanation: 
The ghost can reach the target at the same time as you.


Note:


	All points have coordinates with absolute value <= 10000.
	The number of ghosts will not exceed 100.










## 806 - Domino and Tromino Tiling
~2~  []
We have two types of tiles: a 2x1 domino shape, and an "L" tromino shape. These shapes may be rotated.


XX  <- domino

XX  <- "L" tromino
X


Given N, how many ways are there to tile a 2 x N board? Return your answer modulo 10^9 + 7.

(In a tiling, every square must be covered by a tile. Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile.)



Example:
Input: 3
Output: 5
Explanation: 
The five different ways are listed below, different letters indicates different tiles:
XYZ XXZ XYY XXY XYY
XYZ YYZ XZZ XYY XXY

Note:


	N  will be in range [1, 1000].


 










## 807 - Custom Sort String
~2~  []
S and T are strings composed of lowercase letters. In S, no letter occurs more than once.

S was sorted in some custom order previously. We want to permute the characters of T so that they match the order that S was sorted. More specifically, if x occurs before y in S, then x should occur before y in the returned string.

Return any permutation of T (as a string) that satisfies this property.


Example :
Input: 
S = "cba"
T = "abcd"
Output: "cbad"
Explanation: 
"a", "b", "c" appear in S, so the order of "a", "b", "c" should be "c", "b", and "a". 
Since "d" does not appear in S, it can be at any position in T. "dcba", "cdba", "cbda" are also valid outputs.


 

Note:


	S has length at most 26, and no character is repeated in S.
	T has length at most 200.
	S and T consist of lowercase letters only.










## 808 - Number of Matching Subsequences
~2~  []
Given string S and a dictionary of words words, find the number of words[i] that is a subsequence of S.


Example :
Input: 
S = "abcde"
words = ["a", "bb", "acd", "ace"]
Output: 3
Explanation: There are three words in words that are a subsequence of S: "a", "acd", "ace".


Note:


	All words in words and S will only consists of lowercase letters.
	The length of S will be in the range of [1, 50000].
	The length of words will be in the range of [1, 5000].
	The length of words[i] will be in the range of [1, 50].










## 809 - Preimage Size of Factorial Zeroes Function
~3~  []
Let f(x) be the number of zeroes at the end of x!. (Recall that x! = 1 * 2 * 3 * ... * x, and by convention, 0! = 1.)

For example, f(3) = 0 because 3! = 6 has no zeroes at the end, while f(11) = 2 because 11! = 39916800 has 2 zeroes at the end. Given K, find how many non-negative integers x have the property that f(x) = K.


Example 1:
Input: K = 0
Output: 5
Explanation: 0!, 1!, 2!, 3!, and 4! end with K = 0 zeroes.

Example 2:
Input: K = 5
Output: 0
Explanation: There is no x such that x! ends in K = 5 zeroes.


Note:


	K will be an integer in the range [0, 10^9].










## 810 - Valid Tic-Tac-Toe State
~2~  []
A Tic-Tac-Toe board is given as a string array board. Return True if and only if it is possible to reach this board position during the course of a valid tic-tac-toe game.

The board is a 3 x 3 array, and consists of characters " ", "X", and "O".  The " " character represents an empty square.

Here are the rules of Tic-Tac-Toe:


	Players take turns placing characters into empty squares (" ").
	The first player always places "X" characters, while the second player always places "O" characters.
	"X" and "O" characters are always placed into empty squares, never filled ones.
	The game ends when there are 3 of the same (non-empty) character filling any row, column, or diagonal.
	The game also ends if all squares are non-empty.
	No more moves can be played if the game is over.



Example 1:
Input: board = ["O  ", "   ", "   "]
Output: false
Explanation: The first player always plays "X".

Example 2:
Input: board = ["XOX", " X ", "   "]
Output: false
Explanation: Players take turns making moves.

Example 3:
Input: board = ["XXX", "   ", "OOO"]
Output: false

Example 4:
Input: board = ["XOX", "O O", "XOX"]
Output: true


Note:


	board is a length-3 array of strings, where each string board[i] has length 3.
	Each board[i][j] is a character in the set {" ", "X", "O"}.










## 811 - Number of Subarrays with Bounded Maximum
~2~  []
We are given an array A of positive integers, and two positive integers L and R (L <= R).

Return the number of (contiguous, non-empty) subarrays such that the value of the maximum array element in that subarray is at least L and at most R.


Example :
Input: 
A = [2, 1, 4, 3]
L = 2
R = 3
Output: 3
Explanation: There are three subarrays that meet the requirements: [2], [2, 1], [3].


Note:


	L, R  and A[i] will be an integer in the range [0, 10^9].
	The length of A will be in the range of [1, 50000].










## 812 - Rotate String
~1~  []
We are given two strings, A and B.

A shift on A consists of taking string A and moving the leftmost character to the rightmost position. For example, if A = 'abcde', then it will be 'bcdea' after one shift on A. Return True if and only if A can become B after some number of shifts on A.


Example 1:
Input: A = 'abcde', B = 'cdeab'
Output: true

Example 2:
Input: A = 'abcde', B = 'abced'
Output: false


Note:


	A and B will have length at most 100.










## 813 - All Paths From Source to Target
~2~  []
Given a directed, acyclic graph of N nodes.  Find all possible paths from node 0 to node N-1, and return them in any order.

The graph is given as follows:  the nodes are 0, 1, ..., graph.length - 1.  graph[i] is a list of all nodes j for which the edge (i, j) exists.


Example:
Input: [[1,2], [3], [3], []] 
Output: [[0,1,3],[0,2,3]] 
Explanation: The graph looks like this:
0--->1
|    |
v    v
2--->3
There are two paths: 0 -> 1 -> 3 and 0 -> 2 -> 3.


Note:


	The number of nodes in the graph will be in the range [2, 15].
	You can print different paths in any order, but you should keep the order of nodes inside one path.










## 814 - Smallest Rotation with Highest Score
~3~  []
 Given an array A, we may rotate it by a non-negative integer K so that the array becomes A[K], A[K+1], A{K+2], ... A[A.length - 1], A[0], A[1], ..., A[K-1].  Afterward, any entries that are less than or equal to their index are worth 1 point. 

For example, if we have [2, 4, 1, 3, 0], and we rotate by K = 2, it becomes [1, 3, 0, 2, 4].  This is worth 3 points because 1 > 0 [no points], 3 > 1 [no points], 0 <= 2 [one point], 2 <= 3 [one point], 4 <= 4 [one point].

Over all possible rotations, return the rotation index K that corresponds to the highest score we could receive.  If there are multiple answers, return the smallest such index K.


Example 1:
Input: [2, 3, 1, 4, 0]
Output: 3
Explanation:  
Scores for each K are listed below: 
K = 0,  A = [2,3,1,4,0],    score 2
K = 1,  A = [3,1,4,0,2],    score 3
K = 2,  A = [1,4,0,2,3],    score 3
K = 3,  A = [4,0,2,3,1],    score 4
K = 4,  A = [0,2,3,1,4],    score 3


So we should choose K = 3, which has the highest score.

 


Example 2:
Input: [1, 3, 0, 2, 4]
Output: 0
Explanation:  A will always have 3 points no matter how it shifts.
So we will choose the smallest K, which is 0.


Note:


	A will have length at most 20000.
	A[i] will be in the range [0, A.length].










## 815 - Champagne Tower
~2~  []
We stack glasses in a pyramid, where the first row has 1 glass, the second row has 2 glasses, and so on until the 100th row.  Each glass holds one cup (250ml) of champagne.

Then, some champagne is poured in the first glass at the top.  When the top most glass is full, any excess liquid poured will fall equally to the glass immediately to the left and right of it.  When those glasses become full, any excess champagne will fall equally to the left and right of those glasses, and so on.  (A glass at the bottom row has it's excess champagne fall on the floor.)

For example, after one cup of champagne is poured, the top most glass is full.  After two cups of champagne are poured, the two glasses on the second row are half full.  After three cups of champagne are poured, those two cups become full - there are 3 full glasses total now.  After four cups of champagne are poured, the third row has the middle glass half full, and the two outside glasses are a quarter full, as pictured below.



Now after pouring some non-negative integer cups of champagne, return how full the j-th glass in the i-th row is (both i and j are 0 indexed.)

 


Example 1:
Input: poured = 1, query_glass = 1, query_row = 1
Output: 0.0
Explanation: We poured 1 cup of champange to the top glass of the tower (which is indexed as (0, 0)). There will be no excess liquid so all the glasses under the top glass will remain empty.

Example 2:
Input: poured = 2, query_glass = 1, query_row = 1
Output: 0.5
Explanation: We poured 2 cups of champange to the top glass of the tower (which is indexed as (0, 0)). There is one cup of excess liquid. The glass indexed as (1, 0) and the glass indexed as (1, 1) will share the excess liquid equally, and each will get half cup of champange.


 

Note:


	poured will be in the range of [0, 10 ^ 9].
	query_glass and query_row will be in the range of [0, 99].


 










## 816 - Design HashSet
~1~  []
Design a HashSet without using any built-in hash table libraries.

To be specific, your design should include these functions:


	add(value): Insert a value into the HashSet. 
	contains(value) : Return whether the value exists in the HashSet or not.
	remove(value): Remove a value in the HashSet. If the value does not exist in the HashSet, do nothing.



Example:


MyHashSet hashSet = new MyHashSet();
hashSet.add(1);         
hashSet.add(2);         
hashSet.contains(1);    // returns true
hashSet.contains(3);    // returns false (not found)
hashSet.add(2);          
hashSet.contains(2);    // returns true
hashSet.remove(2);          
hashSet.contains(2);    // returns false (already removed)



Note:


	All values will be in the range of [0, 1000000].
	The number of operations will be in the range of [1, 10000].
	Please do not use the built-in HashSet library.










## 817 - Design HashMap
~1~  []
Design a HashMap without using any built-in hash table libraries.

To be specific, your design should include these functions:


	put(key, value) : Insert a (key, value) pair into the HashMap. If the value already exists in the HashMap, update the value.
	get(key): Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key.
	remove(key) : Remove the mapping for the value key if this map contains the mapping for the key.



Example:


MyHashMap hashMap = new MyHashMap();
hashMap.put(1, 1);          
hashMap.put(2, 2);         
hashMap.get(1);            // returns 1
hashMap.get(3);            // returns -1 (not found)
hashMap.put(2, 1);          // update the existing value
hashMap.get(2);            // returns 1 
hashMap.remove(2);          // remove the mapping for 2
hashMap.get(2);            // returns -1 (not found) 



Note:


	All keys and values will be in the range of [0, 1000000].
	The number of operations will be in the range of [1, 10000].
	Please do not use the built-in HashMap library.










## 819 - Minimum Swaps To Make Sequences Increasing
~2~  []
We have two integer sequences A and B of the same non-zero length.

We are allowed to swap elements A[i] and B[i].  Note that both elements are in the same index position in their respective sequences.

At the end of some number of swaps, A and B are both strictly increasing.  (A sequence is strictly increasing if and only if A[0] < A[1] < A[2] < ... < A[A.length - 1].)

Given A and B, return the minimum number of swaps to make both sequences strictly increasing.  It is guaranteed that the given input always makes it possible.


Example:
Input: A = [1,3,5,4], B = [1,2,3,7]
Output: 1
Explanation: 
Swap A[3] and B[3].  Then the sequences are:
A = [1, 3, 5, 7] and B = [1, 2, 3, 4]
which are both strictly increasing.


Note:


	A, B are arrays with the same length, and that length will be in the range [1, 1000].
	A[i], B[i] are integer values in the range [0, 2000].










## 820 - Find Eventual Safe States
~2~  []
In a directed graph, we start at some node and every turn, walk along a directed edge of the graph.  If we reach a node that is terminal (that is, it has no outgoing directed edges), we stop.

Now, say our starting node is eventually safe if and only if we must eventually walk to a terminal node.  More specifically, there exists a natural number K so that for any choice of where to walk, we must have stopped at a terminal node in less than K steps.

Which nodes are eventually safe?  Return them as an array in sorted order.

The directed graph has N nodes with labels 0, 1, ..., N-1, where N is the length of graph.  The graph is given in the following form: graph[i] is a list of labels j such that (i, j) is a directed edge of the graph.


Example:
Input: graph = [[1,2],[2,3],[5],[0],[5],[],[]]
Output: [2,4,5,6]
Here is a diagram of the above graph.





Note:


	graph will have length at most 10000.
	The number of edges in the graph will not exceed 32000.
	Each graph[i] will be a sorted list of different integers, chosen within the range [0, graph.length - 1].










## 821 - Bricks Falling When Hit
~3~  []
We have a grid of 1s and 0s; the 1s in a cell represent bricks.  A brick will not drop if and only if it is directly connected to the top of the grid, or at least one of its (4-way) adjacent bricks will not drop.

We will do some erasures sequentially. Each time we want to do the erasure at the location (i, j), the brick (if it exists) on that location will disappear, and then some other bricks may drop because of that erasure.

Return an array representing the number of bricks that will drop after each erasure in sequence.


Example 1:
Input: 
grid = [[1,0,0,0],[1,1,1,0]]
hits = [[1,0]]
Output: [2]
Explanation: 
If we erase the brick at (1, 0), the brick at (1, 1) and (1, 2) will drop. So we should return 2.


Example 2:
Input: 
grid = [[1,0,0,0],[1,1,0,0]]
hits = [[1,1],[1,0]]
Output: [0,0]
Explanation: 
When we erase the brick at (1, 0), the brick at (1, 1) has already disappeared due to the last move. So each erasure will cause no bricks dropping.  Note that the erased brick (1, 0) will not be counted as a dropped brick.

 

Note:


	The number of rows and columns in the grid will be in the range [1, 200].
	The number of erasures will not exceed the area of the grid.
	It is guaranteed that each erasure will be different from any other erasure, and located inside the grid.
	An erasure may refer to a location with no brick - if it does, no bricks drop.










## 822 - Unique Morse Code Words
~1~  []
International Morse Code defines a standard encoding where each letter is mapped to a series of dots and dashes, as follows: "a" maps to ".-", "b" maps to "-...", "c" maps to "-.-.", and so on.

For convenience, the full table for the 26 letters of the English alphabet is given below:


[".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."]

Now, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, "cab" can be written as "-.-.-....-", (which is the concatenation "-.-." + "-..." + ".-"). We'll call such a concatenation, the transformation of a word.

Return the number of different transformations among all words we have.


Example:
Input: words = ["gin", "zen", "gig", "msg"]
Output: 2
Explanation: 
The transformation of each word is:
"gin" -> "--...-."
"zen" -> "--...-."
"gig" -> "--...--."
"msg" -> "--...--."

There are 2 different transformations, "--...-." and "--...--.".


 

Note:


	The length of words will be at most 100.
	Each words[i] will have length in range [1, 12].
    words[i] will only consist of lowercase letters.










## 823 - Split Array With Same Average
~3~  []
In a given integer array A, we must move every element of A to either list B or list C. (B and C initially start empty.)

Return true if and only if after such a move, it is possible that the average value of B is equal to the average value of C, and B and C are both non-empty.


Example :
Input: 
[1,2,3,4,5,6,7,8]
Output: true
Explanation: We can split the array into [1,4,5,8] and [2,3,6,7], and both of them have the average of 4.5.


Note:


	The length of A will be in the range [1, 30].
	A[i] will be in the range of [0, 10000].


 










## 824 - Number of Lines To Write String
~1~  []
We are to write the letters of a given string S, from left to right into lines. Each line has maximum width 100 units, and if writing a letter would cause the width of the line to exceed 100 units, it is written on the next line. We are given an array widths, an array where widths[0] is the width of 'a', widths[1] is the width of 'b', ..., and widths[25] is the width of 'z'.

Now answer two questions: how many lines have at least one character from S, and what is the width used by the last such line? Return your answer as an integer list of length 2.

 


Example :
Input: 
widths = [10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10]
S = "abcdefghijklmnopqrstuvwxyz"
Output: [3, 60]
Explanation: 
All letters have the same length of 10. To write all 26 letters,
we need two full lines and one line with 60 units.



Example :
Input: 
widths = [4,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10]
S = "bbbcccdddaaa"
Output: [2, 4]
Explanation: 
All letters except 'a' have the same length of 10, and 
"bbbcccdddaa" will cover 9 * 10 + 2 * 4 = 98 units.
For the last 'a', it is written on the second line because
there is only 2 units left in the first line.
So the answer is 2 lines, plus 4 units in the second line.


 

Note:


	The length of S will be in the range [1, 1000].
	S will only contain lowercase letters.
	widths is an array of length 26.
	widths[i] will be in the range of [2, 10].










## 825 - Max Increase to Keep City Skyline
~2~  []
In a 2 dimensional array grid, each value grid[i][j] represents the height of a building located there. We are allowed to increase the height of any number of buildings, by any amount (the amounts can be different for different buildings). Height 0 is considered to be a building as well. 

At the end, the "skyline" when viewed from all four directions of the grid, i.e. top, bottom, left, and right, must be the same as the skyline of the original grid. A city's skyline is the outer contour of the rectangles formed by all the buildings when viewed from a distance. See the following example.

What is the maximum total sum that the height of the buildings can be increased?


Example:
Input: grid = [[3,0,8,4],[2,4,5,7],[9,2,6,3],[0,3,1,0]]
Output: 35
Explanation: 
The grid is:
[ [3, 0, 8, 4], 
  [2, 4, 5, 7],
  [9, 2, 6, 3],
  [0, 3, 1, 0] ]

The skyline viewed from top or bottom is: [9, 4, 8, 7]
The skyline viewed from left or right is: [8, 7, 9, 3]

The grid after increasing the height of buildings without affecting skylines is:

gridNew = [ [8, 4, 8, 7],
            [7, 4, 7, 7],
            [9, 4, 8, 7],
            [3, 3, 3, 3] ]



Notes: 


	1 < grid.length = grid[0].length <= 50.
	All heights grid[i][j] are in the range [0, 100].
	All buildings in grid[i][j] occupy the entire grid cell: that is, they are a 1 x 1 x grid[i][j] rectangular prism.










## 826 - Soup Servings
~2~  []
There are two types of soup: type A and type B. Initially we have N ml of each type of soup. There are four kinds of operations:


	Serve 100 ml of soup A and 0 ml of soup B
	Serve 75 ml of soup A and 25 ml of soup B
	Serve 50 ml of soup A and 50 ml of soup B
	Serve 25 ml of soup A and 75 ml of soup B


When we serve some soup, we give it to someone and we no longer have it.  Each turn, we will choose from the four operations with equal probability 0.25. If the remaining volume of soup is not enough to complete the operation, we will serve as much as we can.  We stop once we no longer have some quantity of both types of soup.

Note that we do not have the operation where all 100 ml's of soup B are used first.  

Return the probability that soup A will be empty first, plus half the probability that A and B become empty at the same time.

 


Example:
Input: N = 50
Output: 0.625
Explanation: 
If we choose the first two operations, A will become empty first. For the third operation, A and B will become empty at the same time. For the fourth operation, B will become empty first. So the total probability of A becoming empty first plus half the probability that A and B become empty at the same time, is 0.25 * (1 + 1 + 0.5 + 0) = 0.625.



Notes: 


	0 <= N <= 10^9. 
	Answers within 10^-6 of the true value will be accepted as correct.










## 827 - Expressive Words
~2~  []
Sometimes people repeat letters to represent extra feeling, such as "hello" -> "heeellooo", "hi" -> "hiiii".  Here, we have groups, of adjacent letters that are all the same character, and adjacent characters to the group are different.  A group is extended if that group is length 3 or more, so "e" and "o" would be extended in the first example, and "i" would be extended in the second example.  As another example, the groups of "abbcccaaaa" would be "a", "bb", "ccc", and "aaaa"; and "ccc" and "aaaa" are the extended groups of that string.

For some given string S, a query word is stretchy if it can be made to be equal to S by extending some groups.  Formally, we are allowed to repeatedly choose a group (as defined above) of characters c, and add some number of the same character c to it so that the length of the group is 3 or more.  Note that we cannot extend a group of size one like "h" to a group of size two like "hh" - all extensions must leave the group extended - ie., at least 3 characters long.

Given a list of query words, return the number of words that are stretchy. 


Example:
Input: 
S = "heeellooo"
words = ["hello", "hi", "helo"]
Output: 1
Explanation: 
We can extend "e" and "o" in the word "hello" to get "heeellooo".
We can't extend "helo" to get "heeellooo" because the group "ll" is not extended.


Notes: 


	0 <= len(S) <= 100.
	0 <= len(words) <= 100.
	0 <= len(words[i]) <= 100.
	S and all words in words consist only of lowercase letters


 










## 828 - Chalkboard XOR Game
~3~  []
We are given non-negative integers nums[i] which are written on a chalkboard.  Alice and Bob take turns erasing exactly one number from the chalkboard, with Alice starting first.  If erasing a number causes the bitwise XOR of all the elements of the chalkboard to become 0, then that player loses.  (Also, we'll say the bitwise XOR of one element is that element itself, and the bitwise XOR of no elements is 0.)

Also, if any player starts their turn with the bitwise XOR of all the elements of the chalkboard equal to 0, then that player wins.

Return True if and only if Alice wins the game, assuming both players play optimally.


Example:
Input: nums = [1, 1, 2]
Output: false
Explanation: 
Alice has two choices: erase 1 or erase 2. 
If she erases 1, the nums array becomes [1, 2]. The bitwise XOR of all the elements of the chalkboard is 1 XOR 2 = 3. Now Bob can remove any element he wants, because Alice will be the one to erase the last element and she will lose. 
If Alice erases 2 first, now nums becomes [1, 1]. The bitwise XOR of all the elements of the chalkboard is 1 XOR 1 = 0. Alice will lose.



Notes: 


	1 <= N <= 1000. 
	0 <= nums[i] <= 2^16.


 










## 829 - Subdomain Visit Count
~1~  []
A website domain like "discuss.leetcode.com" consists of various subdomains. At the top level, we have "com", at the next level, we have "leetcode.com", and at the lowest level, "discuss.leetcode.com". When we visit a domain like "discuss.leetcode.com", we will also visit the parent domains "leetcode.com" and "com" implicitly.

Now, call a "count-paired domain" to be a count (representing the number of visits this domain received), followed by a space, followed by the address. An example of a count-paired domain might be "9001 discuss.leetcode.com".

We are given a list cpdomains of count-paired domains. We would like a list of count-paired domains, (in the same format as the input, and in any order), that explicitly counts the number of visits to each subdomain.


Example 1:
Input: 
["9001 discuss.leetcode.com"]
Output: 
["9001 discuss.leetcode.com", "9001 leetcode.com", "9001 com"]
Explanation: 
We only have one website domain: "discuss.leetcode.com". As discussed above, the subdomain "leetcode.com" and "com" will also be visited. So they will all be visited 9001 times.




Example 2:
Input: 
["900 google.mail.com", "50 yahoo.com", "1 intel.mail.com", "5 wiki.org"]
Output: 
["901 mail.com","50 yahoo.com","900 google.mail.com","5 wiki.org","5 org","1 intel.mail.com","951 com"]
Explanation: 
We will visit "google.mail.com" 900 times, "yahoo.com" 50 times, "intel.mail.com" once and "wiki.org" 5 times. For the subdomains, we will visit "mail.com" 900 + 1 = 901 times, "com" 900 + 50 + 1 = 951 times, and "org" 5 times.



Notes: 


	The length of cpdomains will not exceed 100. 
	The length of each domain name will not exceed 100.
	Each address will have either 1 or 2 "." characters.
	The input count in any count-paired domain will not exceed 10000.
	The answer output can be returned in any order.










## 830 - Largest Triangle Area
~1~  []
You have a list of points in the plane. Return the area of the largest triangle that can be formed by any 3 of the points.


Example:
Input: points = [[0,0],[0,1],[1,0],[0,2],[2,0]]
Output: 2
Explanation: 
The five points are show in the figure below. The red triangle is the largest.




Notes: 


	3 <= points.length <= 50.
	No points will be duplicated.
	 -50 <= points[i][j] <= 50.
	Answers within 10^-6 of the true value will be accepted as correct.


 










## 831 - Largest Sum of Averages
~2~  []
We partition a row of numbers A into at most K adjacent (non-empty) groups, then our score is the sum of the average of each group. What is the largest score we can achieve?

Note that our partition must use every number in A, and that scores are not necessarily integers.


Example:
Input: 
A = [9,1,2,3,9]
K = 3
Output: 20
Explanation: 
The best choice is to partition A into [9], [1, 2, 3], [9]. The answer is 9 + (1 + 2 + 3) / 3 + 9 = 20.
We could have also partitioned A into [9, 1], [2], [3, 9], for example.
That partition would lead to a score of 5 + 2 + 6 = 13, which is worse.


 

Note: 


	1 <= A.length <= 100.
	1 <= A[i] <= 10000.
	1 <= K <= A.length.
	Answers within 10^-6 of the correct answer will be accepted as correct.










## 832 - Binary Tree Pruning
~2~  []
We are given the head node root of a binary tree, where additionally every node's value is either a 0 or a 1.

Return the same tree where every subtree (of the given tree) not containing a 1 has been removed.

(Recall that the subtree of a node X is X, plus every node that is a descendant of X.)


Example 1:
Input: [1,null,0,0,1]
Output: [1,null,0,null,1]
 
Explanation: 
Only the red nodes satisfy the property "every subtree not containing a 1".
The diagram on the right represents the answer.





Example 2:
Input: [1,0,1,0,0,0,1]
Output: [1,null,1,null,1]






Example 3:
Input: [1,1,0,1,1,0,1,0]
Output: [1,1,0,1,1,null,1]





Note: 


	The binary tree will have at most 100 nodes.
	The value of each node will only be 0 or 1.










## 833 - Bus Routes
~3~  []
We have a list of bus routes. Each routes[i] is a bus route that the i-th bus repeats forever. For example if routes[0] = [1, 5, 7], this means that the first bus (0-th indexed) travels in the sequence 1->5->7->1->5->7->1->... forever.

We start at bus stop S (initially not on a bus), and we want to go to bus stop T. Travelling by buses only, what is the least number of buses we must take to reach our destination? Return -1 if it is not possible.


Example:
Input: 
routes = [[1, 2, 7], [3, 6, 7]]
S = 1
T = 6
Output: 2
Explanation: 
The best strategy is take the first bus to the bus stop 7, then take the second bus to the bus stop 6.


Note: 


	1 <= routes.length <= 500.
	1 <= routes[i].length <= 500.
	0 <= routes[i][j] < 10 ^ 6.










## 834 - Ambiguous Coordinates
~2~  []
We had some 2-dimensional coordinates, like "(1, 3)" or "(2, 0.5)".  Then, we removed all commas, decimal points, and spaces, and ended up with the string S.  Return a list of strings representing all possibilities for what our original coordinates could have been.

Our original representation never had extraneous zeroes, so we never started with numbers like "00", "0.0", "0.00", "1.0", "001", "00.01", or any other number that can be represented with less digits.  Also, a decimal point within a number never occurs without at least one digit occuring before it, so we never started with numbers like ".1".

The final answer list can be returned in any order.  Also note that all coordinates in the final answer have exactly one space between them (occurring after the comma.)


Example 1:
Input: "(123)"
Output: ["(1, 23)", "(12, 3)", "(1.2, 3)", "(1, 2.3)"]



Example 2:
Input: "(00011)"
Output:  ["(0.001, 1)", "(0, 0.011)"]
Explanation: 
0.0, 00, 0001 or 00.01 are not allowed.



Example 3:
Input: "(0123)"
Output: ["(0, 123)", "(0, 12.3)", "(0, 1.23)", "(0.1, 23)", "(0.1, 2.3)", "(0.12, 3)"]



Example 4:
Input: "(100)"
Output: [(10, 0)]
Explanation: 
1.0 is not allowed.


 

Note: 


	4 <= S.length <= 12.
	S[0] = "(", S[S.length - 1] = ")", and the other elements in S are digits.


 










## 835 - Linked List Components
~2~  []
We are given head, the head node of a linked list containing unique integer values.

We are also given the list G, a subset of the values in the linked list.

Return the number of connected components in G, where two values are connected if they appear consecutively in the linked list.

Example 1:


Input: 
head: 0->1->2->3
G = [0, 1, 3]
Output: 2
Explanation: 
0 and 1 are connected, so [0, 1] and [3] are the two connected components.


Example 2:


Input: 
head: 0->1->2->3->4
G = [0, 3, 1, 4]
Output: 2
Explanation: 
0 and 1 are connected, 3 and 4 are connected, so [0, 1] and [3, 4] are the two connected components.


Note: 


	If N is the length of the linked list given by head, 1 <= N <= 10000.
	The value of each node in the linked list will be in the range [0, N - 1].
	1 <= G.length <= 10000.
	G is a subset of all values in the linked list.










## 836 - Race Car
~3~  []
Your car starts at position 0 and speed +1 on an infinite number line.  (Your car can go into negative positions.)

Your car drives automatically according to a sequence of instructions A (accelerate) and R (reverse).

When you get an instruction "A", your car does the following: position += speed, speed *= 2.

When you get an instruction "R", your car does the following: if your speed is positive then speed = -1 , otherwise speed = 1.  (Your position stays the same.)

For example, after commands "AAR", your car goes to positions 0->1->3->3, and your speed goes to 1->2->4->-1.

Now for some target position, say the length of the shortest sequence of instructions to get there.


Example 1:
Input: 
target = 3
Output: 2
Explanation: 
The shortest instruction sequence is "AA".
Your position goes from 0->1->3.



Example 2:
Input: 
target = 6
Output: 5
Explanation: 
The shortest instruction sequence is "AAARA".
Your position goes from 0->1->3->7->7->6.


 

Note: 


	1 <= target <= 10000.










## 837 - Most Common Word
~1~  []
Given a paragraph and a list of banned words, return the most frequent word that is not in the list of banned words.  It is guaranteed there is at least one word that isn't banned, and that the answer is unique.

Words in the list of banned words are given in lowercase, and free of punctuation.  Words in the paragraph are not case sensitive.  The answer is in lowercase.


Example:
Input: 
paragraph = "Bob hit a ball, the hit BALL flew far after it was hit."
banned = ["hit"]
Output: "ball"
Explanation: 
"hit" occurs 3 times, but it is a banned word.
"ball" occurs twice (and no other word does), so it is the most frequent non-banned word in the paragraph. 
Note that words in the paragraph are not case sensitive,
that punctuation is ignored (even if adjacent to words, such as "ball,"), 
and that "hit" isn't the answer even though it occurs more because it is banned.


 

Note: 


	1 <= paragraph.length <= 1000.
	1 <= banned.length <= 100.
	1 <= banned[i].length <= 10.
	The answer is unique, and written in lowercase (even if its occurrences in paragraph may have uppercase symbols, and even if it is a proper noun.)
	paragraph only consists of letters, spaces, or the punctuation symbols !?',;.
	Different words in paragraph are always separated by a space.
	There are no hyphens or hyphenated words.
	Words only consist of letters, never apostrophes or other punctuation symbols.


 










## 838 - Design Linked List
~1~  []
Design your implementation of the linked list. You can choose to use the singly linked list or the doubly linked list. A node in a singly linked list should have two attributes: val and next. val is the value of the current node, and next is a pointer/reference to the next node. If you want to use the doubly linked list, you will need one more attribute prev to indicate the previous node in the linked list. Assume all nodes in the linked list are 0-indexed.

Implement these functions in your linked list class:


	get(index) : Get the value of the index-th node in the linked list. If the index is invalid, return -1.
	addAtHead(val) : Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.
	addAtTail(val) : Append a node of value val to the last element of the linked list.
	addAtIndex(index, val) : Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted.
	deleteAtIndex(index) : Delete the index-th node in the linked list, if the index is valid.


Example:


MyLinkedList linkedList = new MyLinkedList();
linkedList.addAtHead(1);
linkedList.addAtTail(3);
linkedList.addAtIndex(1, 2);  // linked list becomes 1->2->3
linkedList.get(1);            // returns 2
linkedList.deleteAtIndex(1);  // now the linked list is 1->3
linkedList.get(1);            // returns 3


Note:


	All values will be in the range of [1, 1000].
	The number of operations will be in the range of [1, 1000].
	Please do not use the built-in LinkedList library.










## 839 - Short Encoding of Words
~2~  []
Given a list of words, we may encode it by writing a reference string S and a list of indexes A.

For example, if the list of words is ["time", "me", "bell"], we can write it as S = "time#bell#" and indexes = [0, 2, 5].

Then for each index, we will recover the word by reading from the reference string from that index until we reach a "#" character.

What is the length of the shortest reference string S possible that encodes the given words?

Example:


Input: words = ["time", "me", "bell"]
Output: 10
Explanation: S = "time#bell#" and indexes = [0, 2, 5].


Note:


	1 <= words.length <= 2000.
	1 <= words[i].length <= 7.
	Each word has only lowercase letters.










## 841 - Shortest Distance to a Character
~1~  []
Given a string S and a character C, return an array of integers representing the shortest distance from the character C in the string.

Example 1:


Input: S = "loveleetcode", C = 'e'
Output: [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0]


 

Note:


	S string length is in [1, 10000].
	C is a single character, and guaranteed to be in string S.
	All letters in S and C are lowercase.










## 842 - Card Flipping Game
~2~  []
On a table are N cards, with a positive integer printed on the front and back of each card (possibly different).

We flip any number of cards, and after we choose one card. 

If the number X on the back of the chosen card is not on the front of any card, then this number X is good.

What is the smallest number that is good?  If no number is good, output 0.

Here, fronts[i] and backs[i] represent the number on the front and back of card i. 

A flip swaps the front and back numbers, so the value on the front is now on the back and vice versa.

Example:


Input: fronts = [1,2,4,4,7], backs = [1,3,4,1,3]
Output: 2
Explanation: If we flip the second card, the fronts are [1,3,4,4,7] and the backs are [1,2,4,1,3].
We choose the second card, which has number 2 on the back, and it isn't on the front of any card, so 2 is good.

 

Note:


	1 <= fronts.length == backs.length <= 1000.
	1 <= fronts[i] <= 2000.
	1 <= backs[i] <= 2000.










## 843 - Binary Trees With Factors
~2~  []
Given an array of unique integers, each integer is strictly greater than 1.

We make a binary tree using these integers and each number may be used for any number of times.

Each non-leaf node's value should be equal to the product of the values of it's children.

How many binary trees can we make?  Return the answer modulo 10 ** 9 + 7.

Example 1:


Input: A = [2, 4]
Output: 3
Explanation: We can make these trees: [2], [4], [4, 2, 2]

Example 2:


Input: A = [2, 4, 5, 10]
Output: 7
Explanation: We can make these trees: [2], [4], [5], [10], [4, 2, 2], [10, 2, 5], [10, 5, 2].

 

Note:


	1 <= A.length <= 1000.
	2 <= A[i] <= 10 ^ 9.










## 851 - Goat Latin
~1~  []
A sentence S is given, composed of words separated by spaces. Each word consists of lowercase and uppercase letters only.

We would like to convert the sentence to "Goat Latin" (a made-up language similar to Pig Latin.)

The rules of Goat Latin are as follows:


	If a word begins with a vowel (a, e, i, o, or u), append "ma" to the end of the word.
	For example, the word 'apple' becomes 'applema'.
	 
	If a word begins with a consonant (i.e. not a vowel), remove the first letter and append it to the end, then add "ma".
	For example, the word "goat" becomes "oatgma".
	 
	Add one letter 'a' to the end of each word per its word index in the sentence, starting with 1.
	For example, the first word gets "a" added to the end, the second word gets "aa" added to the end and so on.


Return the final sentence representing the conversion from S to Goat Latin. 

 

Example 1:


Input: "I speak Goat Latin"
Output: "Imaa peaksmaaa oatGmaaaa atinLmaaaaa"


Example 2:


Input: "The quick brown fox jumped over the lazy dog"
Output: "heTmaa uickqmaaa rownbmaaaa oxfmaaaaa umpedjmaaaaaa overmaaaaaaa hetmaaaaaaaa azylmaaaaaaaaa ogdmaaaaaaaaaa"


 

Notes:


	S contains only uppercase, lowercase and spaces. Exactly one space between each word.
	1 <= S.length <= 150.










## 852 - Friends Of Appropriate Ages
~2~  []
Some people will make friend requests. The list of their ages is given and ages[i] is the age of the ith person. 

Person A will NOT friend request person B (B != A) if any of the following conditions are true:


	age[B] <= 0.5 * age[A] + 7
	age[B] > age[A]
	age[B] > 100 && age[A] < 100


Otherwise, A will friend request B.

Note that if A requests B, B does not necessarily request A.  Also, people will not friend request themselves.

How many total friend requests are made?

Example 1:


Input: [16,16]
Output: 2
Explanation: 2 people friend request each other.


Example 2:


Input: [16,17,18]
Output: 2
Explanation: Friend requests are made 17 -> 16, 18 -> 17.

Example 3:


Input: [20,30,100,110,120]
Output: 
Explanation: Friend requests are made 110 -> 100, 120 -> 110, 120 -> 100.


 

Notes:


	1 <= ages.length <= 20000.
	1 <= ages[i] <= 120.










## 853 - Most Profit Assigning Work
~2~  []
We have jobs: difficulty[i] is the difficulty of the ith job, and profit[i] is the profit of the ith job. 

Now we have some workers. worker[i] is the ability of the ith worker, which means that this worker can only complete a job with difficulty at most worker[i]. 

Every worker can be assigned at most one job, but one job can be completed multiple times.

For example, if 3 people attempt the same job that pays $1, then the total profit will be $3.  If a worker cannot complete any job, his profit is $0.

What is the most profit we can make?

Example 1:


Input: difficulty = [2,4,6,8,10], profit = [10,20,30,40,50], worker = [4,5,6,7]
Output: 100 
Explanation: Workers are assigned jobs of difficulty [4,4,6,6] and they get profit of [20,20,30,30] seperately.

Notes:


	1 <= difficulty.length = profit.length <= 10000
	1 <= worker.length <= 10000
	difficulty[i], profit[i], worker[i]  are in range [1, 10^5]










## 854 - Making A Large Island
~3~  []
In a 2D grid of 0s and 1s, we change at most one 0 to a 1.

After, what is the size of the largest island? (An island is a 4-directionally connected group of 1s).

Example 1:


Input: [[1, 0], [0, 1]]
Output: 3
Explanation: Change one 0 to 1 and connect two 1s, then we get an island with area = 3.


Example 2:


Input: [[1, 1], [1, 0]]
Output: 4
Explanation: Change the 0 to 1 and make the island bigger, only one island with area = 1.

Example 3:


Input: [[1, 1], [1, 1]]
Output: 4
Explanation: Can't change any 0 to 1, only one island with area = 1.

 

Notes:


	1 <= grid.length = grid[0].length <= 50.
	0 <= grid[i][j] <= 1.


 










## 855 - Unique Letter String
~3~  []
A character is unique in string S if it occurs exactly once in it.

For example, in string S = "LETTER", the only unique characters are "L" and "R".

Let's define UNIQ(S) as the number of unique characters in string S.

For example, UNIQ("LETTER") =  2.

Given a string S with only uppercases, calculate the sum of UNIQ(substring) over all non-empty substrings of S.

If there are two or more equal substrings at different positions in S, we consider them different.

Since the answer can be very large, return the answer modulo 10 ^ 9 + 7.

 

Example 1:


Input: "ABC"
Output: 10
Explanation: All possible substrings are: "A","B","C","AB","BC" and "ABC".
Evey substring is composed with only unique letters.
Sum of lengths of all substring is 1 + 1 + 1 + 2 + 2 + 3 = 10

Example 2:


Input: "ABA"
Output: 8
Explanation: The same as example 1, except uni("ABA") = 1.


 

Note: 0 <= S.length <= 10000.










## 856 - Consecutive Numbers Sum
~2~  []
Given a positive integer N, how many ways can we write it as a sum of consecutive positive integers?

Example 1:


Input: 5
Output: 2
Explanation: 5 = 5 = 2 + 3

Example 2:


Input: 9
Output: 3
Explanation: 9 = 9 = 4 + 5 = 2 + 3 + 4

Example 3:


Input: 15
Output: 4
Explanation: 15 = 15 = 8 + 7 = 4 + 5 + 6 = 1 + 2 + 3 + 4 + 5

Note: 1 <= N <= 10 ^ 9.










## 857 - Positions of Large Groups
~1~  []
In a string S of lowercase letters, these letters form consecutive groups of the same character.

For example, a string like S = "abbxxxxzyy" has the groups "a", "bb", "xxxx", "z" and "yy".

Call a group large if it has 3 or more characters.  We would like the starting and ending positions of every large group.

The final answer should be in lexicographic order.

 

Example 1:


Input: "abbxxxxzzy"
Output: [[3,6]]
Explanation: "xxxx" is the single large group with starting  3 and ending positions 6.


Example 2:


Input: "abc"
Output: []
Explanation: We have "a","b" and "c" but no large group.


Example 3:


Input: "abcdddeeeeaabbbcd"
Output: [[3,5],[6,9],[12,14]]

 

Note:  1 <= S.length <= 1000










## 858 - Masking Personal Information
~2~  []
We are given a personal information string S, which may represent either an email address or a phone number.

We would like to mask this personal information according to the following rules:


1. Email address:

We define a name to be a string of length ≥ 2 consisting of only lowercase letters a-z or uppercase letters A-Z.

An email address starts with a name, followed by the symbol '@', followed by a name, followed by the dot '.' and followed by a name. 

All email addresses are guaranteed to be valid and in the format of "name1@name2.name3".

To mask an email, all names must be converted to lowercase and all letters between the first and last letter of the first name must be replaced by 5 asterisks '*'.


2. Phone number:

A phone number is a string consisting of only the digits 0-9 or the characters from the set {'+', '-', '(', ')', ' '}. You may assume a phone number contains 10 to 13 digits.

The last 10 digits make up the local number, while the digits before those make up the country code. Note that the country code is optional. We want to expose only the last 4 digits and mask all other digits.

The local number should be formatted and masked as "***-***-1111", where 1 represents the exposed digits.

To mask a phone number with country code like "+111 111 111 1111", we write it in the form "+***-***-***-1111".  The '+' sign and the first '-' sign before the local number should only exist if there is a country code.  For example, a 12 digit phone number mask should start with "+**-".

Note that extraneous characters like "(", ")", " ", as well as extra dashes or plus signs not part of the above formatting scheme should be removed.

 

Return the correct "mask" of the information provided.

 

Example 1:


Input: "LeetCode@LeetCode.com"
Output: "l*****e@leetcode.com"
Explanation: All names are converted to lowercase, and the letters between the
             first and last letter of the first name is replaced by 5 asterisks.
             Therefore, "leetcode" -> "l*****e".


Example 2:


Input: "AB@qq.com"
Output: "a*****b@qq.com"
Explanation: There must be 5 asterisks between the first and last letter 
             of the first name "ab". Therefore, "ab" -> "a*****b".


Example 3:


Input: "1(234)567-890"
Output: "***-***-7890"
Explanation: 10 digits in the phone number, which means all digits make up the local number.


Example 4:


Input: "86-(10)12345678"
Output: "+**-***-***-5678"
Explanation: 12 digits, 2 digits for country code and 10 digits for local number. 


Notes:


	S.length <= 40.
	Emails have length at least 8.
	Phone numbers have length at least 10.










## 859 - Design Circular Deque
~2~  []
Design your implementation of the circular double-ended queue (deque).

Your implementation should support following operations:


	MyCircularDeque(k): Constructor, set the size of the deque to be k.
	insertFront(): Adds an item at the front of Deque. Return true if the operation is successful.
	insertLast(): Adds an item at the rear of Deque. Return true if the operation is successful.
	deleteFront(): Deletes an item from the front of Deque. Return true if the operation is successful.
	deleteLast(): Deletes an item from the rear of Deque. Return true if the operation is successful.
	getFront(): Gets the front item from the Deque. If the deque is empty, return -1.
	getRear(): Gets the last item from Deque. If the deque is empty, return -1.
	isEmpty(): Checks whether Deque is empty or not. 
	isFull(): Checks whether Deque is full or not.


 

Example:


MyCircularDeque circularDeque = new MycircularDeque(3); // set the size to be 3
circularDeque.insertLast(1);			// return true
circularDeque.insertLast(2);			// return true
circularDeque.insertFront(3);			// return true
circularDeque.insertFront(4);			// return false, the queue is full
circularDeque.getRear();  			// return 32
circularDeque.isFull();				// return true
circularDeque.deleteLast();			// return true
circularDeque.insertFront(4);			// return true
circularDeque.getFront();			// return 4


 

Note:


	All values will be in the range of [0, 1000].
	The number of operations will be in the range of [1, 1000].
	Please do not use the built-in Deque library.










## 860 - Design Circular Queue
~2~  []
Design your implementation of the circular queue. The circular queue is a linear data structure in which the operations are performed based on FIFO (First In First Out) principle and the last position is connected back to the first position to make a circle. It is also called "Ring Buffer".

One of the benefits of the circular queue is that we can make use of the spaces in front of the queue. In a normal queue, once the queue becomes full, we cannot insert the next element even if there is a space in front of the queue. But using the circular queue, we can use the space to store new values.

Your implementation should support following operations:


	MyCircularQueue(k): Constructor, set the size of the queue to be k.
	Front: Get the front item from the queue. If the queue is empty, return -1.
	Rear: Get the last item from the queue. If the queue is empty, return -1.
	enQueue(value): Insert an element into the circular queue. Return true if the operation is successful.
	deQueue(): Delete an element from the circular queue. Return true if the operation is successful.
	isEmpty(): Checks whether the circular queue is empty or not.
	isFull(): Checks whether the circular queue is full or not.


 

Example:


MyCircularQueue circularQueue = new MycircularQueue(3); // set the size to be 3
circularQueue.enQueue(1);  // return true
circularQueue.enQueue(2);  // return true
circularQueue.enQueue(3);  // return true
circularQueue.enQueue(4);  // return false, the queue is full
circularQueue.Rear();  // return 3
circularQueue.isFull();  // return true
circularQueue.deQueue();  // return true
circularQueue.enQueue(4);  // return true
circularQueue.Rear();  // return 4

 

Note:


	All values will be in the range of [0, 1000].
	The number of operations will be in the range of [1, 1000].
	Please do not use the built-in Queue library.










## 861 - Flipping an Image
~1~  []
Given a binary matrix A, we want to flip the image horizontally, then invert it, and return the resulting image.

To flip an image horizontally means that each row of the image is reversed.  For example, flipping [1, 1, 0] horizontally results in [0, 1, 1].

To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0. For example, inverting [0, 1, 1] results in [1, 0, 0].

Example 1:


Input: [[1,1,0],[1,0,1],[0,0,0]]
Output: [[1,0,0],[0,1,0],[1,1,1]]
Explanation: First reverse each row: [[0,1,1],[1,0,1],[0,0,0]].
Then, invert the image: [[1,0,0],[0,1,0],[1,1,1]]


Example 2:


Input: [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]
Output: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]
Explanation: First reverse each row: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]].
Then invert the image: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]


Notes:


	1 <= A.length = A[0].length <= 20
	0 <= A[i][j] <= 1










## 862 - Find And Replace in String
~2~  []
To some string S, we will perform some replacement operations that replace groups of letters with new ones (not necessarily the same size).

Each replacement operation has 3 parameters: a starting index i, a source word x and a target word y.  The rule is that if x starts at position i in the original string S, then we will replace that occurrence of x with y.  If not, we do nothing.

For example, if we have S = "abcd" and we have some replacement operation i = 2, x = "cd", y = "ffff", then because "cd" starts at position 2 in the original string S, we will replace it with "ffff".

Using another example on S = "abcd", if we have both the replacement operation i = 0, x = "ab", y = "eee", as well as another replacement operation i = 2, x = "ec", y = "ffff", this second operation does nothing because in the original string S[2] = 'c', which doesn't match x[0] = 'e'.

All these operations occur simultaneously.  It's guaranteed that there won't be any overlap in replacement: for example, S = "abc", indexes = [0, 1], sources = ["ab","bc"] is not a valid test case.

Example 1:


Input: S = "abcd", indexes = [0,2], sources = ["a","cd"], targets = ["eee","ffff"]
Output: "eeebffff"
Explanation: "a" starts at index 0 in S, so it's replaced by "eee".
"cd" starts at index 2 in S, so it's replaced by "ffff".


Example 2:


Input: S = "abcd", indexes = [0,2], sources = ["ab","ec"], targets = ["eee","ffff"]
Output: "eeecd"
Explanation: "ab" starts at index 0 in S, so it's replaced by "eee". 
"ec" doesn't starts at index 2 in the original S, so we do nothing.


Notes:


	0 <= indexes.length = sources.length = targets.length <= 100
	0 < indexes[i] < S.length <= 1000
	All characters in given inputs are lowercase letters.


 










## 863 - Sum of Distances in Tree
~3~  []
An undirected, connected tree with N nodes labelled 0...N-1 and N-1 edges are given.

The ith edge connects nodes edges[i][0] and edges[i][1] together.

Return a list ans, where ans[i] is the sum of the distances between node i and all other nodes.

Example 1:


Input: N = 6, edges = [[0,1],[0,2],[2,3],[2,4],[2,5]]
Output: [8,12,6,10,10,10]
Explanation: 
Here is a diagram of the given tree:
  0
 / \
1   2
   /|\
  3 4 5
We can see that dist(0,1) + dist(0,2) + dist(0,3) + dist(0,4) + dist(0,5)
equals 1 + 1 + 2 + 2 + 2 = 8.  Hence, answer[0] = 8, and so on.


Note: 1 <= N <= 10000










## 864 - Image Overlap
~2~  []
Two images A and B are given, represented as binary, square matrices of the same size.  (A binary matrix has only 0s and 1s as values.)

We translate one image however we choose (sliding it left, right, up, or down any number of units), and place it on top of the other image.  After, the overlap of this translation is the number of positions that have a 1 in both images.

(Note also that a translation does not include any kind of rotation.)

What is the largest possible overlap?

Example 1:


Input: A = [[1,1,0],
            [0,1,0],
            [0,1,0]]
       B = [[0,0,0],
            [0,1,1],
            [0,0,1]]
Output: 3
Explanation: We slide A to right by 1 unit and down by 1 unit.

Notes: 


	1 <= A.length = A[0].length = B.length = B[0].length <= 30
	0 <= A[i][j], B[i][j] <= 1










## 866 - Rectangle Overlap
~1~  []
A rectangle is represented as a list [x1, y1, x2, y2], where (x1, y1) are the coordinates of its bottom-left corner, and (x2, y2) are the coordinates of its top-right corner.

Two rectangles overlap if the area of their intersection is positive.  To be clear, two rectangles that only touch at the corner or edges do not overlap.

Given two (axis-aligned) rectangles, return whether they overlap.

Example 1:


Input: rec1 = [0,0,2,2], rec2 = [1,1,3,3]
Output: true


Example 2:


Input: rec1 = [0,0,1,1], rec2 = [1,0,2,1]
Output: false


Notes:


	Both rectangles rec1 and rec2 are lists of 4 integers.
	All coordinates in rectangles will be between -10^9 and 10^9.










## 867 - New 21 Game
~2~  []
Alice plays the following game, loosely based on the card game "21".

Alice starts with 0 points, and draws numbers while she has less than K points.  During each draw, she gains an integer number of points randomly from the range [1, W], where W is an integer.  Each draw is independent and the outcomes have equal probabilities.

Alice stops drawing numbers when she gets K or more points.  What is the probability that she has N or less points?

Example 1:


Input: N = 10, K = 1, W = 10
Output: 1.00000
Explanation:  Alice gets a single card, then stops.


Example 2:


Input: N = 6, K = 1, W = 10
Output: 0.60000
Explanation:  Alice gets a single card, then stops.
In 6 out of W = 10 possibilities, she is at or below N = 6 points.


Example 3:


Input: N = 21, K = 17, W = 10
Output: 0.73278

Note:


	0 <= K <= N <= 10000
	1 <= W <= 10000
	Answers will be accepted as correct if they are within 10^-5 of the correct answer.
	The judging time limit has been reduced for this question.










## 868 - Push Dominoes
~2~  []
There are N dominoes in a line, and we place each domino vertically upright.

In the beginning, we simultaneously push some of the dominoes either to the left or to the right.



After each second, each domino that is falling to the left pushes the adjacent domino on the left.

Similarly, the dominoes falling to the right push their adjacent dominoes standing on the right.

When a vertical domino has dominoes falling on it from both sides, it stays still due to the balance of the forces.

For the purposes of this question, we will consider that a falling domino expends no additional force to a falling or already fallen domino.

Given a string "S" representing the initial state. S[i] = 'L', if the i-th domino has been pushed to the left; S[i] = 'R', if the i-th domino has been pushed to the right; S[i] = '.', if the i-th domino has not been pushed.

Return a string representing the final state. 

Example 1:


Input: ".L.R...LR..L.."
Output: "LL.RR.LLRRLL.."


Example 2:


Input: "RR.L"
Output: "RR.L"
Explanation: The first domino expends no additional force on the second domino.


Note:


	0 <= N <= 10^5
	String dominoes contains only 'L', 'R' and '.'










## 869 - Similar String Groups
~3~  []
Two strings X and Y are similar if we can swap two letters (in different positions) of X, so that it equals Y.

For example, "tars" and "rats" are similar (swapping at positions 0 and 2), and "rats" and "arts" are similar, but "star" is not similar to "tars", "rats", or "arts".

Together, these form two connected groups by similarity: {"tars", "rats", "arts"} and {"star"}.  Notice that "tars" and "arts" are in the same group even though they are not similar.  Formally, each group is such that a word is in the group if and only if it is similar to at least one other word in the group.

We are given a list A of strings.  Every string in A is an anagram of every other string in A.  How many groups are there?

Example 1:


Input: ["tars","rats","arts","star"]
Output: 2

Note:


	A.length <= 2000
	A[i].length <= 1000
	A.length * A[i].length <= 20000
	All words in A consist of lowercase letters only.
	All words in A have the same length and are anagrams of each other.
	The judging time limit has been increased for this question.










## 870 - Magic Squares In Grid
~1~  []
A 3 x 3 magic square is a 3 x 3 grid filled with distinct numbers from 1 to 9 such that each row, column, and both diagonals all have the same sum.

Given an grid of integers, how many 3 x 3 "magic square" subgrids are there?  (Each subgrid is contiguous).

 

Example 1:


Input: [[4,3,8,4],
        [9,5,1,9],
        [2,7,6,2]]
Output: 1
Explanation: 
The following subgrid is a 3 x 3 magic square:
438
951
276

while this one is not:
384
519
762

In total, there is only one magic square inside the given grid.


Note:


	1 <= grid.length <= 10
	1 <= grid[0].length <= 10
	0 <= grid[i][j] <= 15










## 871 - Keys and Rooms
~2~  []
There are N rooms and you start in room 0.  Each room has a distinct number in 0, 1, 2, ..., N-1, and each room may have some keys to access the next room. 

Formally, each room i has a list of keys rooms[i], and each key rooms[i][j] is an integer in [0, 1, ..., N-1] where N = rooms.length.  A key rooms[i][j] = v opens the room with number v.

Initially, all the rooms start locked (except for room 0). 

You can walk back and forth between rooms freely.

Return true if and only if you can enter every room.




Example 1:


Input: [[1],[2],[3],[]]
Output: true
Explanation:  
We start in room 0, and pick up key 1.
We then go to room 1, and pick up key 2.
We then go to room 2, and pick up key 3.
We then go to room 3.  Since we were able to go to every room, we return true.


Example 2:


Input: [[1,3],[3,0,1],[2],[0]]
Output: false
Explanation: We can't enter the room with number 2.


Note:


	1 <= rooms.length <= 1000
	0 <= rooms[i].length <= 1000
	The number of keys in all rooms combined is at most 3000.










## 872 - Split Array into Fibonacci Sequence
~2~  []
Given a string S of digits, such as S = "123456579", we can split it into a Fibonacci-like sequence [123, 456, 579].

Formally, a Fibonacci-like sequence is a list F of non-negative integers such that:


	0 <= F[i] <= 2^31 - 1, (that is, each integer fits a 32-bit signed integer type);
	F.length >= 3;
	and F[i] + F[i+1] = F[i+2] for all 0 <= i < F.length - 2.


Also, note that when splitting the string into pieces, each piece must not have extra leading zeroes, except if the piece is the number 0 itself.

Return any Fibonacci-like sequence split from S, or return [] if it cannot be done.

Example 1:


Input: "123456579"
Output: [123,456,579]


Example 2:


Input: "11235813"
Output: [1,1,2,3,5,8,13]


Example 3:


Input: "112358130"
Output: []
Explanation: The task is impossible.


Example 4:


Input: "0123"
Output: []
Explanation: Leading zeroes are not allowed, so "01", "2", "3" is not valid.


Example 5:


Input: "1101111"
Output: [110, 1, 111]
Explanation: The output [11, 0, 11, 11] would also be accepted.


Note: 


	1 <= S.length <= 200
	S contains only digits.










## 873 - Guess the Word
~3~  []
This problem is an interactive problem new to the LeetCode platform.

We are given a word list of unique words, each word is 6 letters long, and one word in this list is chosen as secret.

You may call master.guess(word) to guess a word.  The guessed word should have type string and must be from the original list with 6 lowercase letters.

This function returns an integer type, representing the number of exact matches (value and position) of your guess to the secret word.  Also, if your guess is not in the given wordlist, it will return -1 instead.

For each test case, you have 10 guesses to guess the word. At the end of any number of calls, if you have made 10 or less calls to master.guess and at least one of these guesses was the secret, you pass the testcase.

Besides the example test case below, there will be 5 additional test cases, each with 100 words in the word list.  The letters of each word in those testcases were chosen independently at random from 'a' to 'z', such that every word in the given word lists is unique.


Example 1:
Input: secret = "acckzz", wordlist = ["acckzz","ccbazz","eiowzz","abcczz"]

Explanation:

master.guess("aaaaaa") returns -1, because "aaaaaa" is not in wordlist.
master.guess("acckzz") returns 6, because "acckzz" is secret and has all 6 matches.
master.guess("ccbazz") returns 3, because "ccbazz" has 3 matches.
master.guess("eiowzz") returns 2, because "eiowzz" has 2 matches.
master.guess("abcczz") returns 4, because "abcczz" has 4 matches.

We made 5 calls to master.guess and one of them was the secret, so we pass the test case.


Note:  Any solutions that attempt to circumvent the judge will result in disqualification.










## 874 - Backspace String Compare
~1~  []
Given two strings S and T, return if they are equal when both are typed into empty text editors. # means a backspace character.


Example 1:


Input: S = "ab#c", T = "ad#c"
Output: true
Explanation: Both S and T become "ac".



Example 2:


Input: S = "ab##", T = "c#d#"
Output: true
Explanation: Both S and T become "".



Example 3:


Input: S = "a##c", T = "#a#c"
Output: true
Explanation: Both S and T become "c".



Example 4:


Input: S = "a#c", T = "b"
Output: false
Explanation: S becomes "c" while T becomes "b".


Note:


	1 <= S.length <= 200
	1 <= T.length <= 200
	S and T only contain lowercase letters and '#' characters.


Follow up:


	Can you solve it in O(N) time and O(1) space?










## 875 - Longest Mountain in Array
~2~  []
Let's call any (contiguous) subarray B (of A) a mountain if the following properties hold:


	B.length >= 3
	There exists some 0 < i < B.length - 1 such that B[0] < B[1] < ... B[i-1] < B[i] > B[i+1] > ... > B[B.length - 1]


(Note that B could be any subarray of A, including the entire array A.)

Given an array A of integers, return the length of the longest mountain. 

Return 0 if there is no mountain.

Example 1:


Input: [2,1,4,7,3,2,5]
Output: 5
Explanation: The largest mountain is [1,4,7,3,2] which has length 5.


Example 2:


Input: [2,2,2]
Output: 0
Explanation: There is no mountain.


Note:


	0 <= A.length <= 10000
	0 <= A[i] <= 10000


Follow up:


	Can you solve it using only one pass?
	Can you solve it in O(1) space?










## 876 - Hand of Straights
~2~  []
Alice has a hand of cards, given as an array of integers.

Now she wants to rearrange the cards into groups so that each group is size W, and consists of W consecutive cards.

Return true if and only if she can.

 




Example 1:


Input: hand = [1,2,3,6,2,3,4,7,8], W = 3
Output: true
Explanation: Alice's hand can be rearranged as [1,2,3],[2,3,4],[6,7,8].

Example 2:


Input: hand = [1,2,3,4,5], W = 4
Output: false
Explanation: Alice's hand can't be rearranged into groups of 4.

 

Note:


	1 <= hand.length <= 10000
	0 <= hand[i] <= 10^9
	1 <= W <= hand.length










## 877 - Shortest Path Visiting All Nodes
~3~  []
An undirected, connected graph of N nodes (labeled 0, 1, 2, ..., N-1) is given as graph.

graph.length = N, and j != i is in the list graph[i] exactly once, if and only if nodes i and j are connected.

Return the length of the shortest path that visits every node. You may start and stop at any node, you may revisit nodes multiple times, and you may reuse edges.

 




Example 1:


Input: [[1,2,3],[0],[0],[0]]
Output: 4
Explanation: One possible path is [1,0,2,0,3]

Example 2:


Input: [[1],[0,2,4],[1,3,4],[2],[1,2]]
Output: 4
Explanation: One possible path is [0,1,4,2,3]


 

Note:


	1 <= graph.length <= 12
	0 <= graph[i].length < graph.length










## 878 - Shifting Letters
~2~  []
We have a string S of lowercase letters, and an integer array shifts.

Call the shift of a letter, the next letter in the alphabet, (wrapping around so that 'z' becomes 'a'). 

For example, shift('a') = 'b', shift('t') = 'u', and shift('z') = 'a'.

Now for each shifts[i] = x, we want to shift the first i+1 letters of S, x times.

Return the final string after all such shifts to S are applied.

Example 1:


Input: S = "abc", shifts = [3,5,9]
Output: "rpl"
Explanation: 
We start with "abc".
After shifting the first 1 letters of S by 3, we have "dbc".
After shifting the first 2 letters of S by 5, we have "igc".
After shifting the first 3 letters of S by 9, we have "rpl", the answer.


Note:


	1 <= S.length = shifts.length <= 20000
	0 <= shifts[i] <= 10 ^ 9










## 879 - Maximize Distance to Closest Person
~1~  []
In a row of seats, 1 represents a person sitting in that seat, and 0 represents that the seat is empty. 

There is at least one empty seat, and at least one person sitting.

Alex wants to sit in the seat such that the distance between him and the closest person to him is maximized. 

Return that maximum distance to closest person.


Example 1:


Input: [1,0,0,0,1,0,1]
Output: 2
Explanation: 
If Alex sits in the second open seat (seats[2]), then the closest person has distance 2.
If Alex sits in any other open seat, the closest person has distance 1.
Thus, the maximum distance to the closest person is 2.


Example 2:


Input: [1,0,0,0]
Output: 3
Explanation: 
If Alex sits in the last seat, the closest person is 3 seats away.
This is the maximum distance possible, so the answer is 3.


Note:


	1 <= seats.length <= 20000
	seats contains only 0s or 1s, at least one 0, and at least one 1.










## 880 - Rectangle Area II
~3~  []
We are given a list of (axis-aligned) rectangles.  Each rectangle[i] = [x1, y1, x2, y2] , where (x1, y1) are the coordinates of the bottom-left corner, and (x2, y2) are the coordinates of the top-right corner of the ith rectangle.

Find the total area covered by all rectangles in the plane.  Since the answer may be too large, return it modulo 10^9 + 7.



Example 1:


Input: [[0,0,2,2],[1,0,2,3],[1,0,3,1]]
Output: 6
Explanation: As illustrated in the picture.


Example 2:


Input: [[0,0,1000000000,1000000000]]
Output: 49
Explanation: The answer is 10^18 modulo (10^9 + 7), which is (10^9)^2 = (-7)^2 = 49.


Note:


	1 <= rectangles.length <= 200
	rectanges[i].length = 4
	0 <= rectangles[i][j] <= 10^9
	The total area covered by all rectangles will never exceed 2^63 - 1 and thus will fit in a 64-bit signed integer.










## 881 - Loud and Rich
~2~  []
In a group of N people (labelled 0, 1, 2, ..., N-1), each person has different amounts of money, and different levels of quietness.

For convenience, we'll call the person with label x, simply "person x".

We'll say that richer[i] = [x, y] if person x definitely has more money than person y.  Note that richer may only be a subset of valid observations.

Also, we'll say quiet[x] = q if person x has quietness q.

Now, return answer, where answer[x] = y if y is the least quiet person (that is, the person y with the smallest value of quiet[y]), among all people who definitely have equal to or more money than person x.

 


Example 1:


Input: richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]], quiet = [3,2,5,4,6,1,7,0]
Output: [5,5,2,5,4,5,6,7]
Explanation: 
answer[0] = 5.
Person 5 has more money than 3, which has more money than 1, which has more money than 0.
The only person who is quieter (has lower quiet[x]) is person 7, but
it isn't clear if they have more money than person 0.

answer[7] = 7.
Among all people that definitely have equal to or more money than person 7
(which could be persons 3, 4, 5, 6, or 7), the person who is the quietest (has lower quiet[x])
is person 7.

The other answers can be filled out with similar reasoning.



Note:


	1 <= quiet.length = N <= 500
	0 <= quiet[i] < N, all quiet[i] are different.
	0 <= richer.length <= N * (N-1) / 2
	0 <= richer[i][j] < N
	richer[i][0] != richer[i][1]
	richer[i]'s are all different.
	The observations in richer are all logically consistent.










## 882 - Peak Index in a Mountain Array
~1~  []
Let's call an array A a mountain if the following properties hold:


	A.length >= 3
	There exists some 0 < i < A.length - 1 such that A[0] < A[1] < ... A[i-1] < A[i] > A[i+1] > ... > A[A.length - 1]


Given an array that is definitely a mountain, return any i such that A[0] < A[1] < ... A[i-1] < A[i] > A[i+1] > ... > A[A.length - 1].

Example 1:


Input: [0,1,0]
Output: 1



Example 2:


Input: [0,2,1,0]
Output: 1


Note:


	3 <= A.length <= 10000
	0 <= A[i] <= 10^6
	A is a mountain, as defined above.










## 883 - Car Fleet
~2~  []
N cars are going to the same destination along a one lane road.  The destination is target miles away.

Each car i has a constant speed speed[i] (in miles per hour), and initial position position[i] miles towards the target along the road.

A car can never pass another car ahead of it, but it can catch up to it, and drive bumper to bumper at the same speed.

The distance between these two cars is ignored - they are assumed to have the same position.

A car fleet is some non-empty set of cars driving at the same position and same speed.  Note that a single car is also a car fleet.

If a car catches up to a car fleet right at the destination point, it will still be considered as one car fleet.


How many car fleets will arrive at the destination?

 

Example 1:


Input: target = 12, position = [10,8,0,5,3], speed = [2,4,1,1,3]
Output: 3
Explanation:
The cars starting at 10 and 8 become a fleet, meeting each other at 12.
The car starting at 0 doesn't catch up to any other car, so it is a fleet by itself.
The cars starting at 5 and 3 become a fleet, meeting each other at 6.
Note that no other cars meet these fleets before the destination, so the answer is 3.



Note:


	0 <= N <= 10 ^ 4
	0 < target <= 10 ^ 6
	0 < speed[i] <= 10 ^ 6
	0 <= position[i] < target
	All initial positions are different.










## 884 - K-Similar Strings
~3~  []
Strings A and B are K-similar (for some non-negative integer K) if we can swap the positions of two letters in A exactly K times so that the resulting string equals B.

Given two anagrams A and B, return the smallest K for which A and B are K-similar.

Example 1:


Input: A = "ab", B = "ba"
Output: 1



Example 2:


Input: A = "abc", B = "bca"
Output: 2



Example 3:


Input: A = "abac", B = "baca"
Output: 2



Example 4:


Input: A = "aabc", B = "abca"
Output: 2




Note:


	1 <= A.length == B.length <= 20
	A and B contain only lowercase letters from the set {'a', 'b', 'c', 'd', 'e', 'f'}










## 885 - Exam Room
~2~  []
In an exam room, there are N seats in a single row, numbered 0, 1, 2, ..., N-1.

When a student enters the room, they must sit in the seat that maximizes the distance to the closest person.  If there are multiple such seats, they sit in the seat with the lowest number.  (Also, if no one is in the room, then the student sits at seat number 0.)

Return a class ExamRoom(int N) that exposes two functions: ExamRoom.seat() returning an int representing what seat the student sat in, and ExamRoom.leave(int p) representing that the student in seat number p now leaves the room.  It is guaranteed that any calls to ExamRoom.leave(p) have a student sitting in seat p.

 

Example 1:


Input: ["ExamRoom","seat","seat","seat","seat","leave","seat"], [[10],[],[],[],[],[4],[]]
Output: [null,0,9,4,2,null,5]
Explanation:
ExamRoom(10) -> null
seat() -> 0, no one is in the room, then the student sits at seat number 0.
seat() -> 9, the student sits at the last seat number 9.
seat() -> 4, the student sits at the last seat number 4.
seat() -> 2, the student sits at the last seat number 2.
leave(4) -> null
seat() -> 5, the student​​​​​​​ sits at the last seat number 5.


​​​​​​​

Note:


	1 <= N <= 10^9
	ExamRoom.seat() and ExamRoom.leave() will be called at most 10^4 times across all test cases.
	Calls to ExamRoom.leave(p) are guaranteed to have a student currently sitting in seat number p.










## 886 - Score of Parentheses
~2~  []
Given a balanced parentheses string S, compute the score of the string based on the following rule:


	() has score 1
	AB has score A + B, where A and B are balanced parentheses strings.
	(A) has score 2 * A, where A is a balanced parentheses string.


 


Example 1:


Input: "()"
Output: 1



Example 2:


Input: "(())"
Output: 2



Example 3:


Input: "()()"
Output: 2



Example 4:


Input: "(()(()))"
Output: 6


 

Note:


	S is a balanced parentheses string, containing only ( and ).
	2 <= S.length <= 50










## 887 - Minimum Cost to Hire K Workers
~3~  []
There are N workers.  The i-th worker has a quality[i] and a minimum wage expectation wage[i].

Now we want to hire exactly K workers to form a paid group.  When hiring a group of K workers, we must pay them according to the following rules:


	Every worker in the paid group should be paid in the ratio of their quality compared to other workers in the paid group.
	Every worker in the paid group must be paid at least their minimum wage expectation.


Return the least amount of money needed to form a paid group satisfying the above conditions.

 





Example 1:


Input: quality = [10,20,5], wage = [70,50,30], K = 2
Output: 105.00000
Explanation: We pay 70 to 0-th worker and 35 to 2-th worker.



Example 2:


Input: quality = [3,1,10,10,1], wage = [4,8,2,2,7], K = 3
Output: 30.66667
Explanation: We pay 4 to 0-th worker, 13.33333 to 2-th and 3-th workers seperately. 


 

Note:


	1 <= K <= N <= 10000, where N = quality.length = wage.length
	1 <= quality[i] <= 10000
	1 <= wage[i] <= 10000
	Answers within 10^-5 of the correct answer will be considered correct.










## 888 - Mirror Reflection
~2~  []
There is a special square room with mirrors on each of the four walls.  Except for the southwest corner, there are receptors on each of the remaining corners, numbered 0, 1, and 2.

The square room has walls of length p, and a laser ray from the southwest corner first meets the east wall at a distance q from the 0th receptor.

Return the number of the receptor that the ray meets first.  (It is guaranteed that the ray will meet a receptor eventually.)

 


Example 1:


Input: p = 2, q = 1
Output: 2
Explanation: The ray meets receptor 2 the first time it gets reflected back to the left wall.




Note:


	1 <= p <= 1000
	0 <= q <= p










## 889 - Buddy Strings
~1~  []
Given two strings A and B of lowercase letters, return true if and only if we can swap two letters in A so that the result equals B.

 

Example 1:



Input: A = "ab", B = "ba"
Output: true



Example 2:


Input: A = "ab", B = "ab"
Output: false



Example 3:


Input: A = "aa", B = "aa"
Output: true



Example 4:


Input: A = "aaaaaaabc", B = "aaaaaaacb"
Output: true



Example 5:


Input: A = "", B = "aa"
Output: false


 

Note:


	0 <= A.length <= 20000
	0 <= B.length <= 20000
	A and B consist only of lowercase letters.










## 890 - Lemonade Change
~1~  []
At a lemonade stand, each lemonade costs $5. 

Customers are standing in a queue to buy from you, and order one at a time (in the order specified by bills).

Each customer will only buy one lemonade and pay with either a $5, $10, or $20 bill.  You must provide the correct change to each customer, so that the net transaction is that the customer pays $5.

Note that you don't have any change in hand at first.

Return true if and only if you can provide every customer with correct change.

 


Example 1:


Input: [5,5,5,10,20]
Output: true
Explanation: 
From the first 3 customers, we collect three $5 bills in order.
From the fourth customer, we collect a $10 bill and give back a $5.
From the fifth customer, we give a $10 bill and a $5 bill.
Since all customers got correct change, we output true.



Example 2:


Input: [5,5,10]
Output: true



Example 3:


Input: [10,10]
Output: false



Example 4:


Input: [5,5,10,10,20]
Output: false
Explanation: 
From the first two customers in order, we collect two $5 bills.
For the next two customers in order, we collect a $10 bill and give back a $5 bill.
For the last customer, we can't give change of $15 back because we only have two $10 bills.
Since not every customer received correct change, the answer is false.


 

Note:


	0 <= bills.length <= 10000
	bills[i] will be either 5, 10, or 20.










## 891 - Score After Flipping Matrix
~2~  []
We have a two dimensional matrix A where each value is 0 or 1.

A move consists of choosing any row or column, and toggling each value in that row or column: changing all 0s to 1s, and all 1s to 0s.

After making any number of moves, every row of this matrix is interpreted as a binary number, and the score of the matrix is the sum of these numbers.

Return the highest possible score.

 





Example 1:


Input: [[0,0,1,1],[1,0,1,0],[1,1,0,0]]
Output: 39
Explanation:
Toggled to [[1,1,1,1],[1,0,0,1],[1,1,1,1]].
0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39

 

Note:


	1 <= A.length <= 20
	1 <= A[0].length <= 20
	A[i][j] is 0 or 1.










## 892 - Shortest Subarray with Sum at Least K
~3~  []
Return the length of the shortest, non-empty, contiguous subarray of A with sum at least K.

If there is no non-empty subarray with sum at least K, return -1.

 





Example 1:


Input: A = [1], K = 1
Output: 1



Example 2:


Input: A = [1,2], K = 4
Output: -1



Example 3:


Input: A = [2,-1,2], K = 3
Output: 3


 

Note:


	1 <= A.length <= 50000
	-10 ^ 5 <= A[i] <= 10 ^ 5
	1 <= K <= 10 ^ 9










## 893 - All Nodes Distance K in Binary Tree
~2~  []
We are given a binary tree (with root node root), a target node, and an integer value K.

Return a list of the values of all nodes that have a distance K from the target node.  The answer can be returned in any order.

 





Example 1:


Input: root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, K = 2

Output: [7,4,1]

Explanation: 
The nodes that are a distance 2 from the target node (with value 5)
have values 7, 4, and 1.



Note that the inputs "root" and "target" are actually TreeNodes.
The descriptions of the inputs above are just serializations of these objects.


 

Note:


	The given tree is non-empty.
	Each node in the tree has unique values 0 <= node.val <= 500.
	The target node is a node in the tree.
	0 <= K <= 1000.










## 894 - Random Pick with Blacklist
~3~  []
Given a blacklist B containing unique integers from [0, N), write a function to return a uniform random integer from [0, N) which is NOT in B.

Optimize it such that it minimizes the call to system’s Math.random().

Note:


	1 <= N <= 1000000000
	0 <= B.length < min(100000, N)
	[0, N) does NOT include N. See interval notation.


Example 1:


Input: 
["Solution","pick","pick","pick"]
[[1,[]],[],[],[]]
Output: [null,0,0,0]


Example 2:


Input: 
["Solution","pick","pick","pick"]
[[2,[]],[],[],[]]
Output: [null,1,1,1]


Example 3:


Input: 
["Solution","pick","pick","pick"]
[[3,[1]],[],[],[]]
Output: [null,0,0,2]


Example 4:


Input: 
["Solution","pick","pick","pick"]
[[4,[2]],[],[],[]]
Output: [null,1,3,1]


Explanation of Input Syntax:

The input is two lists: the subroutines called and their arguments. Solution's constructor has two arguments, N and the blacklist B. pick has no arguments. Arguments are always wrapped with a list, even if there aren't any.










## 895 - Shortest Path to Get All Keys
~3~  []
We are given a 2-dimensional grid. "." is an empty cell, "#" is a wall, "@" is the starting point, ("a", "b", ...) are keys, and ("A", "B", ...) are locks.

We start at the starting point, and one move consists of walking one space in one of the 4 cardinal directions.  We cannot walk outside the grid, or walk into a wall.  If we walk over a key, we pick it up.  We can't walk over a lock unless we have the corresponding key.

For some 1 <= K <= 6, there is exactly one lowercase and one uppercase letter of the first K letters of the English alphabet in the grid.  This means that there is exactly one key for each lock, and one lock for each key; and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.

Return the lowest number of moves to acquire all keys.  If it's impossible, return -1.

 


Example 1:


Input: ["@.a.#","###.#","b.A.B"]
Output: 8



Example 2:


Input: ["@..aA","..B#.","....b"]
Output: 6



 

Note:


	1 <= grid.length <= 30
	1 <= grid[0].length <= 30
	grid[i][j] contains only '.', '#', '@', 'a'-'f' and 'A'-'F'
	The number of keys is in [1, 6].  Each key has a different letter and opens exactly one lock.










## 896 - Smallest Subtree with all the Deepest Nodes
~2~  []
Given a binary tree rooted at root, the depth of each node is the shortest distance to the root.

A node is deepest if it has the largest depth possible among any node in the entire tree.

The subtree of a node is that node, plus the set of all descendants of that node.

Return the node with the largest depth such that it contains all the deepest nodes in its subtree.

 

Example 1:


Input: [3,5,1,6,2,0,8,null,null,7,4]
Output: [2,7,4]
Explanation:



We return the node with value 2, colored in yellow in the diagram.
The nodes colored in blue are the deepest nodes of the tree.
The input "[3, 5, 1, 6, 2, 0, 8, null, null, 7, 4]" is a serialization of the given tree.
The output "[2, 7, 4]" is a serialization of the subtree rooted at the node with value 2.
Both the input and output have TreeNode type.


 

Note:


	The number of nodes in the tree will be between 1 and 500.
	The values of each node are unique.










## 897 - Prime Palindrome
~2~  []
Find the smallest prime palindrome greater than or equal to N.

Recall that a number is prime if it's only divisors are 1 and itself, and it is greater than 1. 

For example, 2,3,5,7,11 and 13 are primes.

Recall that a number is a palindrome if it reads the same from left to right as it does from right to left. 

For example, 12321 is a palindrome.

 


Example 1:


Input: 6
Output: 7



Example 2:


Input: 8
Output: 11



Example 3:


Input: 13
Output: 101




 

Note:


	1 <= N <= 10^8
	The answer is guaranteed to exist and be less than 2 * 10^8.










## 898 - Transpose Matrix
~1~  []
Given a matrix A, return the transpose of A.

The transpose of a matrix is the matrix flipped over it's main diagonal, switching the row and column indices of the matrix.

 


Example 1:


Input: [[1,2,3],[4,5,6],[7,8,9]]
Output: [[1,4,7],[2,5,8],[3,6,9]]



Example 2:


Input: [[1,2,3],[4,5,6]]
Output: [[1,4],[2,5],[3,6]]


 

Note:


	1 <= A.length <= 1000
	1 <= A[0].length <= 1000










## 899 - Binary Gap
~1~  []
Given a positive integer N, find and return the longest distance between two consecutive 1's in the binary representation of N.

If there aren't two consecutive 1's, return 0.

 











Example 1:


Input: 22
Output: 2
Explanation: 
22 in binary is 0b10110.
In the binary representation of 22, there are three ones, and two consecutive pairs of 1's.
The first consecutive pair of 1's have distance 2.
The second consecutive pair of 1's have distance 1.
The answer is the largest of these two distances, which is 2.



Example 2:


Input: 5
Output: 2
Explanation: 
5 in binary is 0b101.



Example 3:


Input: 6
Output: 1
Explanation: 
6 in binary is 0b110.



Example 4:


Input: 8
Output: 0
Explanation: 
8 in binary is 0b1000.
There aren't any consecutive pairs of 1's in the binary representation of 8, so we return 0.


 




Note:


	1 <= N <= 10^9










## 900 - Reordered Power of 2
~2~  []
Starting with a positive integer N, we reorder the digits in any order (including the original order) such that the leading digit is not zero.

Return true if and only if we can do this in a way such that the resulting number is a power of 2.

 





Example 1:


Input: 1
Output: true



Example 2:


Input: 10
Output: false



Example 3:


Input: 16
Output: true



Example 4:


Input: 24
Output: false



Example 5:


Input: 46
Output: true


 

Note:


	1 <= N <= 10^9










## 901 - Advantage Shuffle
~2~  []
Given two arrays A and B of equal size, the advantage of A with respect to B is the number of indices i for which A[i] > B[i].

Return any permutation of A that maximizes its advantage with respect to B.

 


Example 1:


Input: A = [2,7,11,15], B = [1,10,4,11]
Output: [2,11,7,15]



Example 2:


Input: A = [12,24,8,32], B = [13,25,32,11]
Output: [24,32,8,12]


 

Note:


	1 <= A.length = B.length <= 10000
	0 <= A[i] <= 10^9
	0 <= B[i] <= 10^9










## 902 - Minimum Number of Refueling Stops
~3~  []
A car travels from a starting position to a destination which is target miles east of the starting position.

Along the way, there are gas stations.  Each station[i] represents a gas station that is station[i][0] miles east of the starting position, and has station[i][1] liters of gas.

The car starts with an infinite tank of gas, which initially has startFuel liters of fuel in it.  It uses 1 liter of gas per 1 mile that it drives.

When the car reaches a gas station, it may stop and refuel, transferring all the gas from the station into the car.

What is the least number of refueling stops the car must make in order to reach its destination?  If it cannot reach the destination, return -1.

Note that if the car reaches a gas station with 0 fuel left, the car can still refuel there.  If the car reaches the destination with 0 fuel left, it is still considered to have arrived.

 


Example 1:


Input: target = 1, startFuel = 1, stations = []
Output: 0
Explanation: We can reach the target without refueling.



Example 2:


Input: target = 100, startFuel = 1, stations = [[10,100]]
Output: -1
Explanation: We can't reach the target (or even the first gas station).



Example 3:


Input: target = 100, startFuel = 10, stations = [[10,60],[20,30],[30,30],[60,40]]
Output: 2
Explanation: 
We start with 10 liters of fuel.
We drive to position 10, expending 10 liters of fuel.  We refuel from 0 liters to 60 liters of gas.
Then, we drive from position 10 to position 60 (expending 50 liters of fuel),
and refuel from 10 liters to 50 liters of gas.  We then drive to and reach the target.
We made 2 refueling stops along the way, so we return 2.


 

Note:


	1 <= target, startFuel, stations[i][1] <= 10^9
	0 <= stations.length <= 500
	0 < stations[0][0] < stations[1][0] < ... < stations[stations.length-1][0] < target










## 903 - Implement Rand10() Using Rand7()
~2~  []
Given a function rand7 which generates a uniform random integer in the range 1 to 7, write a function rand10 which generates a uniform random integer in the range 1 to 10.

Do NOT use system's Math.random().




 


Example 1:


Input: 1
Output: [7]



Example 2:


Input: 2
Output: [8,4]



Example 3:


Input: 3
Output: [8,1,10]


 

Note:


	rand7 is predefined.
	Each testcase has one argument: n, the number of times that rand10 is called.


 

Follow up:


	What is the expected value for the number of calls to rand7() function?
	Could you minimize the number of calls to rand7()?










## 904 - Leaf-Similar Trees
~1~  ['Tree', 'Depth-first Search']
Consider all the leaves of a binary tree.  From left to right order, the
values of those leaves form a _leaf value sequence._

![](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/16/tree.png)

For example, in the given tree above, the leaf value sequence is `(6, 7, 4, 9,
8)`.

Two binary trees are considered _leaf-similar_  if their leaf value sequence
is the same.

Return `true` if and only if the two given trees with head nodes `root1` and
`root2` are leaf-similar.



**Note:**

  * Both of the given trees will have between `1` and `100` nodes.










## 905 - Length of Longest Fibonacci Subsequence
~2~  ['Array', 'Dynamic Programming']
A sequence `X_1, X_2, ..., X_n` is _fibonacci-like_ if:

  * `n >= 3`
  * `X_i + X_{i+1} = X_{i+2}` for all `i + 2 <= n`

Given a **strictly increasing**  array `A` of positive integers forming a
sequence, find the **length** of the longest fibonacci-like subsequence of
`A`.  If one does not exist, return 0.

( _Recall that a subsequence is derived from another sequence`A` by deleting
any number of elements (including none) from `A`, without changing the order
of the remaining elements.  For example, `[3, 5, 8]` is a subsequence of `[3,
4, 5, 6, 7, 8]`._ )



**Example 1:**

    
    
    **Input:** [1,2,3,4,5,6,7,8]
    **Output:** 5
    **Explanation:** The longest subsequence that is fibonacci-like: [1,2,3,5,8].
    

**Example 2:**

    
    
    **Input:** [1,3,7,11,12,14,18]
    **Output:** 3
    **Explanation** :
    The longest subsequence that is fibonacci-like:
    [1,11,12], [3,11,14] or [7,11,18].
    



**Note:**

  * `3 <= A.length <= 1000`
  * `1 <= A[0] < A[1] < ... < A[A.length - 1] <= 10^9`
  * _(The time limit has been reduced by 50% for submissions in Java, C, and C++.)_










## 906 - Walking Robot Simulation
~1~  ['Greedy']
A robot on an infinite grid starts at point (0, 0) and faces north.  The robot
can receive one of three possible types of commands:

  * `-2`: turn left 90 degrees
  * `-1`: turn right 90 degrees
  * `1 <= x <= 9`: move forward `x` units

Some of the grid squares are obstacles.

The `i`-th obstacle is at grid point `(obstacles[i][0], obstacles[i][1])`

If the robot would try to move onto them, the robot stays on the previous grid
square instead (but still continues following the rest of the route.)

Return the **square** of the maximum Euclidean distance that the robot will be
from the origin.



**Example 1:**

    
    
    **Input:** commands = [4,-1,3], obstacles = []
    **Output:** 25
    Explanation: robot will go to (3, 4)
    

**Example 2:**

    
    
    **Input:** commands = [4,-1,4,-2,4], obstacles = [[2,4]]
    **Output:** 65
    **Explanation** : robot will be stuck at (1, 4) before turning left and going to (1, 8)
    



**Note:**

  1. `0 <= commands.length <= 10000`
  2. `0 <= obstacles.length <= 10000`
  3. `-30000 <= obstacle[i][0] <= 30000`
  4. `-30000 <= obstacle[i][1] <= 30000`
  5. The answer is guaranteed to be less than `2 ^ 31`.










## 907 - Koko Eating Bananas
~2~  ['Binary Search']
Koko loves to eat bananas.  There are `N` piles of bananas, the `i`-th pile
has `piles[i]` bananas.  The guards have gone and will come back in `H` hours.

Koko can decide her bananas-per-hour eating speed of `K`.  Each hour, she
chooses some pile of bananas, and eats K bananas from that pile.  If the pile
has less than `K` bananas, she eats all of them instead, and won't eat any
more bananas during this hour.

Koko likes to eat slowly, but still wants to finish eating all the bananas
before the guards come back.

Return the minimum integer `K` such that she can eat all the bananas within
`H` hours.



**Example 1:**

    
    
    **Input:** piles = [3,6,7,11], H = 8
    **Output:** 4
    

**Example 2:**

    
    
    **Input:** piles = [30,11,23,4,20], H = 5
    **Output:** 30
    

**Example 3:**

    
    
    **Input:** piles = [30,11,23,4,20], H = 6
    **Output:** 23
    



**Note:**

  * `1 <= piles.length <= 10^4`
  * `piles.length <= H <= 10^9`
  * `1 <= piles[i] <= 10^9`










## 908 - Middle of the Linked List
~1~  ['Linked List']
Given a non-empty, singly linked list with head node `head`, return a middle
node of linked list.

If there are two middle nodes, return the second middle node.



**Example 1:**

    
    
    **Input:** [1,2,3,4,5]
    **Output:** Node 3 from this list (Serialization: [3,4,5])
    The returned node has value 3.  (The judge's serialization of this node is [3,4,5]).
    Note that we returned a ListNode object ans, such that:
    ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, and ans.next.next.next = NULL.
    

**Example 2:**

    
    
    **Input:** [1,2,3,4,5,6]
    **Output:** Node 4 from this list (Serialization: [4,5,6])
    Since the list has two middle nodes with values 3 and 4, we return the second one.
    



**Note:**

  * The number of nodes in the given list will be between `1` and `100`.










## 909 - Stone Game
~2~  ['Math', 'Dynamic Programming']
Alex and Lee play a game with piles of stones.  There are an even number of
piles **arranged in a row** , and each pile has a positive integer number of
stones `piles[i]`.

The objective of the game is to end with the most stones.  The total number of
stones is odd, so there are no ties.

Alex and Lee take turns, with Alex starting first.  Each turn, a player takes
the entire pile of stones from either the beginning or the end of the row.
This continues until there are no more piles left, at which point the person
with the most stones wins.

Assuming Alex and Lee play optimally, return `True` if and only if Alex wins
the game.



**Example 1:**

    
    
    **Input:** [5,3,4,5]
    **Output:** true
    **Explanation:**
    Alex starts first, and can only take the first 5 or the last 5.
    Say he takes the first 5, so that the row becomes [3, 4, 5].
    If Lee takes 3, then the board is [4, 5], and Alex takes 5 to win with 10 points.
    If Lee takes the last 5, then the board is [3, 4], and Alex takes 4 to win with 9 points.
    This demonstrated that taking the first 5 was a winning move for Alex, so we return true.
    



**Note:**

  1. `2 <= piles.length <= 500`
  2. `piles.length` is even.
  3. `1 <= piles[i] <= 500`
  4. `sum(piles)` is odd.










## 910 - Nth Magical Number
~3~  ['Math', 'Binary Search']
A positive integer is _magical_  if it is divisible by either A or B.

Return the N-th magical number.  Since the answer may be very large, **return
it modulo**`10^9 + 7`.



**Example 1:**

    
    
    **Input:** N = 1, A = 2, B = 3
    **Output:** 2
    

**Example 2:**

    
    
    **Input:** N = 4, A = 2, B = 3
    **Output:** 6
    

**Example 3:**

    
    
    **Input:** N = 5, A = 2, B = 4
    **Output:** 10
    

**Example 4:**

    
    
    **Input:** N = 3, A = 6, B = 4
    **Output:** 8
    



**Note:**

  1. `1 <= N <= 10^9`
  2. `2 <= A <= 40000`
  3. `2 <= B <= 40000`










## 911 - Profitable Schemes
~3~  ['Dynamic Programming']
There are G people in a gang, and a list of various crimes they could commit.

The `i`-th crime generates a `profit[i]` and requires `group[i]` gang members
to participate.

If a gang member participates in one crime, that member can't participate in
another crime.

Let's call a _profitable  scheme_ any subset of these crimes that generates at
least `P` profit, and the total number of gang members participating in that
subset of crimes is at most G.

How many schemes can be chosen?  Since the answer may be very large, **return
it modulo** `10^9 + 7`.



**Example 1:**

    
    
    **Input:** G = 5, P = 3, group = [2,2], profit = [2,3]
    **Output:** 2
    **Explanation:**
    To make a profit of at least 3, the gang could either commit crimes 0 and 1, or just crime 1.
    In total, there are 2 schemes.
    

**Example 2:**

    
    
    **Input:** G = 10, P = 5, group = [2,3,5], profit = [6,7,8]
    **Output:** 7
    **Explanation:**
    To make a profit of at least 5, the gang could commit any crimes, as long as they commit one.
    There are 7 possible schemes: (0), (1), (2), (0,1), (0,2), (1,2), and (0,1,2).
    



**Note:**

  1. `1 <= G <= 100`
  2. `0 <= P <= 100`
  3. `1 <= group[i] <= 100`
  4. `0 <= profit[i] <= 100`
  5. `1 <= group.length = profit.length <= 100`










## 912 - Random Pick with Weight
~2~  ['Binary Search', 'Random']
Given an array `w` of positive integers, where `w[i]` describes the weight of
index `i`, write a function `pickIndex` which randomly picks an index in
proportion to its weight.

Note:

  1. `1 <= w.length <= 10000`
  2. `1 <= w[i] <= 10^5`
  3. `pickIndex` will be called at most `10000` times.

**Example 1:**

    
    
    **Input:** ["Solution","pickIndex"]
    [[[1]],[]]
    **Output:** [null,0]
    

**Example 2:**

    
    
    **Input:** ["Solution","pickIndex","pickIndex","pickIndex","pickIndex","pickIndex"]
    [[[1,3]],[],[],[],[],[]]
    **Output:** [null,0,1,1,1,0]

**Explanation of Input Syntax:**

The input is two lists: the subroutines called and their arguments.
`Solution`'s constructor has one argument, the array `w`. `pickIndex` has no
arguments. Arguments are always wrapped with a list, even if there aren't any.










## 913 - Random Flip Matrix
~2~  ['Random']
You are given the number of rows `n_rows` and number of columns `n_cols` of a
2D binary matrix where all values are initially 0. Write a function `flip`
which chooses a 0 value [uniformly at
random](https://en.wikipedia.org/wiki/Discrete_uniform_distribution), changes
it to 1, and then returns the position `[row.id, col.id]` of that value. Also,
write a function `reset` which sets all values back to 0.  **Try to minimize
the number of calls to system 's Math.random()** and optimize the time and
space complexity.

Note:

  1. `1 <= n_rows, n_cols <= 10000`
  2. `0 <= row.id < n_rows` and `0 <= col.id < n_cols`
  3. `flip` will not be called when the matrix has no 0 values left.
  4. the total number of calls to `flip` and `reset` will not exceed 1000.

**Example 1:**

    
    
    **Input:** ["Solution","flip","flip","flip","flip"]
    [[2,3],[],[],[],[]]
    **Output:** [null,[0,1],[1,2],[1,0],[1,1]]
    

**Example 2:**

    
    
    **Input:** ["Solution","flip","flip","reset","flip"]
    [[1,2],[],[],[],[]]
    **Output:** [null,[0,0],[0,1],null,[0,0]]

**Explanation of Input Syntax:**

The input is two lists: the subroutines called and their arguments.
`Solution`'s constructor has two arguments, `n_rows` and `n_cols`. `flip` and
`reset` have no arguments. Arguments are always wrapped with a list, even if
there aren't any.










## 914 - Random Point in Non-overlapping Rectangles
~2~  ['Binary Search', 'Random']
Given a list of **non-overlapping**  axis-aligned rectangles `rects`, write a
function `pick` which randomly and uniformily picks an **integer point** in
the space  covered by the rectangles.

Note:

  1. An **integer point**  is a point that has integer coordinates. 
  2. A point on the perimeter of a rectangle is  **included** in the space covered by the rectangles.  
  3. `i`th rectangle = `rects[i]` = `[x1,y1,x2,y2]`, where `[x1, y1]` are the integer coordinates of the bottom-left corner, and `[x2, y2]` are the integer coordinates of the top-right corner.
  4. length and width of each rectangle does not exceed `2000`.
  5. `1 <= rects.length <= 100`
  6. `pick` return a point as an array of integer coordinates `[p_x, p_y]`
  7. `pick` is called at most `10000` times.

**Example 1:**

    
    
    **Input:** ["Solution","pick","pick","pick"]
    [[[[1,1,5,5]]],[],[],[]]
    **Output:** [null,[4,1],[4,1],[3,3]]
    

**Example 2:**

    
    
    **Input:** ["Solution","pick","pick","pick","pick","pick"]
    [[[[-2,-2,-1,-1],[1,0,3,0]]],[],[],[],[],[]]
    **Output:** [null,[-1,-2],[2,0],[-2,-1],[3,0],[-2,-2]]

**Explanation of Input Syntax:**

The input is two lists: the subroutines called and their arguments.
`Solution`'s constructor has one argument, the array of rectangles `rects`.
`pick` has no arguments. Arguments are always wrapped with a list, even if
there aren't any.










## 915 - Generate Random Point in a Circle
~2~  ['Math', 'Random', 'Rejection Sampling']
Given the radius and x-y positions of the center of a circle, write a function
`randPoint` which generates a uniform random point in the circle.

Note:

  1. input and output values are in [floating-point](https://www.webopedia.com/TERM/F/floating_point_number.html).
  2. radius and x-y position of the center of the circle is passed into the class constructor.
  3. a point on the circumference of the circle is considered to be in the circle.
  4. `randPoint` returns a size 2 array containing x-position and y-position of the random point, in that order.

**Example 1:**

    
    
    **Input:** ["Solution","randPoint","randPoint","randPoint"]
    [[1,0,0],[],[],[]]
    **Output:** [null,[-0.72939,-0.65505],[-0.78502,-0.28626],[-0.83119,-0.19803]]
    

**Example 2:**

    
    
    **Input:** ["Solution","randPoint","randPoint","randPoint"]
    [[10,5,-7.5],[],[],[]]
    **Output:** [null,[11.52438,-8.33273],[2.46992,-16.21705],[11.13430,-12.42337]]

**Explanation of Input Syntax:**

The input is two lists: the subroutines called and their arguments.
`Solution`'s constructor has three arguments, the radius, x-position of the
center, and y-position of the center of the circle. `randPoint` has no
arguments. Arguments are always wrapped with a list, even if there aren't any.










## 916 - Decoded String at Index
~2~  ['Stack']
An encoded string `S` is given.  To find and write the _decoded_ string to a
tape, the encoded string is read **one character at a time**  and the
following steps are taken:

  * If the character read is a letter, that letter is written onto the tape.
  * If the character read is a digit (say `d`), the entire current tape is repeatedly written `d-1` more times in total.

Now for some encoded string `S`, and an index `K`, find and return the `K`-th
letter (1 indexed) in the decoded string.



**Example 1:**

    
    
    **Input:** S = "leet2code3", K = 10
    **Output:** "o"
    **Explanation:**
    The decoded string is  "leetleetcodeleetleetcodeleetleetcode".
    The 10th letter in the string is "o".
    

**Example 2:**

    
    
    **Input:** S = "ha22", K = 5
    **Output:** "h"
    **Explanation:**
    The decoded string is  "hahahaha".  The 5th letter is "h".
    

**Example 3:**

    
    
    **Input:** S = "a2345678999999999999999", K = 1
    **Output:** "a"
    **Explanation:**
    The decoded string is  "a" repeated 8301530446056247680 times.  The 1st letter is "a".
    



**Note:**

  1. `2 <= S.length <= 100`
  2. `S` will only contain lowercase letters and digits `2` through `9`.
  3. `S` starts with a letter.
  4. `1 <= K <= 10^9`
  5. The decoded string is guaranteed to have less than `2^63` letters.










## 917 - Boats to Save People
~2~  ['Two Pointers', 'Greedy']
The `i`-th person has weight `people[i]`, and each boat can carry a maximum
weight of `limit`.

Each boat carries at most 2 people at the same time, provided the sum of the
weight of those people is at most `limit`.

Return the minimum number of boats to carry every given person.  (It is
guaranteed each person can be carried by a boat.)



**Example 1:**

    
    
    **Input:** people = [1,2], limit = 3
    **Output:** 1
    **Explanation:** 1 boat (1, 2)
    

**Example 2:**

    
    
    **Input:** people = [3,2,2,1], limit = 3
    **Output:** 3
    **Explanation** : 3 boats (1, 2), (2) and (3)
    

**Example 3:**

    
    
    **Input:** people = [3,5,3,4], limit = 5
    **Output:** 4
    **Explanation** : 4 boats (3), (3), (4), (5)

**Note** :

  * `1 <= people.length <= 50000`
  * `1 <= people[i] <= limit <= 30000`










## 918 - Reachable Nodes In Subdivided Graph
~3~  ['Heap']
Starting with an  **undirected** graph (the  "original graph") with nodes from
`0` to `N-1`, subdivisions are made to some of the edges.

The graph is given as follows: `edges[k]` is a list of integer pairs `(i, j,
n)` such that `(i, j)` is an edge of the original graph,

and `n` is the total number of **new** nodes on that edge.  

Then, the edge `(i, j)` is deleted from the original graph, `n` new nodes
`(x_1, x_2, ..., x_n)` are added to the original graph,

and `n+1` new edges `(i, x_1), (x_1, x_2), (x_2, x_3), ..., (x_{n-1}, x_n),
(x_n, j)` are added to the original graph.

Now, you start at node `0` from the original graph, and in each move, you
travel along one edge.

Return how many nodes you can reach in at most `M` moves.



**Example 1:**

    
    
    **Input:**edges =  [[0,1,10],[0,2,1],[1,2,2]], M = 6, N = 3
    **Output:** 13
    **Explanation:**
    The nodes that are reachable in the final graph after M = 6 moves are indicated below.
    ![](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/08/01/origfinal.png)
    

**Example 2:**

    
    
    **Input:**edges =  [[0,1,4],[1,2,6],[0,2,8],[1,3,1]], M = 10, N = 4
    **Output:** 23



**Note:**

  1. `0 <= edges.length <= 10000`
  2. `0 <= edges[i][0] < edges[i][1] < N`
  3. There does not exist any `i != j` for which `edges[i][0] == edges[j][0]` and `edges[i][1] == edges[j][1]`.
  4. The original graph has no parallel edges.
  5. `0 <= edges[i][2] <= 10000`
  6. `0 <= M <= 10^9`
  7. `1 <= N <= 3000`
  8. A reachable node is a node that can be travelled to using at most M moves starting from node 0.










## 919 - Projection Area of 3D Shapes
~1~  ['Math']
On a `N * N` grid, we place some `1 * 1 * 1 `cubes that are axis-aligned with
the x, y, and z axes.

Each value `v = grid[i][j]` represents a tower of `v` cubes placed on top of
grid cell `(i, j)`.

Now we view the  _projection_  of these cubes onto the xy, yz, and zx planes.

A projection is like a shadow, that maps our 3 dimensional figure to a 2
dimensional plane.

Here, we are viewing the "shadow" when looking at the cubes from the top, the
front, and the side.

Return the total area of all three projections.



**Example 1:**

    
    
    **Input:** [[2]]
    **Output:** 5
    

**Example 2:**

    
    
    **Input:** [[1,2],[3,4]]
    **Output:** 17
    **Explanation:**
    Here are the three projections ( "shadows") of the shape made with each axis-aligned plane.
    ![](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/08/02/shadow.png)
    

**Example 3:**

    
    
    **Input:** [[1,0],[0,2]]
    **Output:** 8
    

**Example 4:**

    
    
    **Input:** [[1,1,1],[1,0,1],[1,1,1]]
    **Output:** 14
    

**Example 5:**

    
    
    **Input:** [[2,2,2],[2,1,2],[2,2,2]]
    **Output:** 21
    



**Note:**

  * `1 <= grid.length = grid[0].length <= 50`
  * `0 <= grid[i][j] <= 50`










## 920 - Uncommon Words from Two Sentences
~1~  ['Hash Table']
We are given two sentences `A` and `B`.  (A _sentence_  is a string of space
separated words.  Each _word_ consists only of lowercase letters.)

A word is _uncommon_  if it appears exactly once in one of the sentences, and
does not appear in the other sentence.

Return a list of all uncommon words.

You may return the list in any order.



**Example 1:**

    
    
    **Input:** A = "this apple is sweet", B = "this apple is sour"
    **Output:** ["sweet","sour"]
    

**Example 2:**

    
    
    **Input:** A = "apple apple", B = "banana"
    **Output:** ["banana"]
    



**Note:**

  1. `0 <= A.length <= 200`
  2. `0 <= B.length <= 200`
  3. `A` and `B` both contain only spaces and lowercase letters.










## 921 - Spiral Matrix III
~2~  ['Math']
On a 2 dimensional grid with `R` rows and `C` columns, we start at `(r0, c0)`
facing east.

Here, the north-west corner of the grid is at the first row and column, and
the south-east corner of the grid is at the last row and column.

Now, we walk in a clockwise spiral shape to visit every position in this grid.

Whenever we would move outside the boundary of the grid, we continue our walk
outside the grid (but may return to the grid boundary later.)

Eventually, we reach all `R * C` spaces of the grid.

Return a list of coordinates representing the positions of the grid in the
order they were visited.



**Example 1:**

    
    
    **Input:** R = 1, C = 4, r0 = 0, c0 = 0
    **Output:** [[0,0],[0,1],[0,2],[0,3]]
    
    ![](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/08/24/example_1.png)
    



**Example 2:**

    
    
    **Input:** R = 5, C = 6, r0 = 1, c0 = 4
    **Output:** [[1,4],[1,5],[2,5],[2,4],[2,3],[1,3],[0,3],[0,4],[0,5],[3,5],[3,4],[3,3],[3,2],[2,2],[1,2],[0,2],[4,5],[4,4],[4,3],[4,2],[4,1],[3,1],[2,1],[1,1],[0,1],[4,0],[3,0],[2,0],[1,0],[0,0]]
    
    ![](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/08/24/example_2.png)
    



**Note:**

  1. `1 <= R <= 100`
  2. `1 <= C <= 100`
  3. `0 <= r0 < R`
  4. `0 <= c0 < C`










## 922 - Possible Bipartition
~2~  ['Depth-first Search']
Given a set of `N` people (numbered `1, 2, ..., N`), we would like to split
everyone into two groups of **any** size.

Each person may dislike some other people, and they should not go into the
same group.

Formally, if `dislikes[i] = [a, b]`, it means it is not allowed to put the
people numbered `a` and `b` into the same group.

Return `true` if and only if it is possible to split everyone into two groups
in this way.



**Example 1:**

    
    
    **Input:** N = 4, dislikes = [[1,2],[1,3],[2,4]]
    **Output:** true
    **Explanation** : group1 [1,4], group2 [2,3]
    

**Example 2:**

    
    
    **Input:** N = 3, dislikes = [[1,2],[1,3],[2,3]]
    **Output:** false
    

**Example 3:**

    
    
    **Input:** N = 5, dislikes = [[1,2],[2,3],[3,4],[4,5],[1,5]]
    **Output:** false
    



**Note:**

  1. `1 <= N <= 2000`
  2. `0 <= dislikes.length <= 10000`
  3. `1 <= dislikes[i][j] <= N`
  4. `dislikes[i][0] < dislikes[i][1]`
  5. There does not exist `i != j` for which `dislikes[i] == dislikes[j]`.










## 923 - Super Egg Drop
~3~  ['Math', 'Binary Search', 'Dynamic Programming']
You are given `K` eggs, and you have access to a building with `N` floors from
`1` to `N`.

Each egg is identical in function, and if an egg breaks, you cannot drop it
again.

You know that there exists a floor `F` with `0 <= F <= N` such that any egg
dropped at a floor higher than `F` will break, and any egg dropped at or below
floor `F` will not break.

Each _move_ , you may take an egg (if you have an unbroken one) and drop it
from any floor `X` (with `1 <= X <= N`).

Your goal is to know  **with certainty**  what the value of `F` is.

What is the minimum number of moves that you need to know with certainty what
`F` is, regardless of the initial value of `F`?



**Example 1:**

    
    
    **Input:** K = 1, N = 2
    **Output:** 2
    **Explanation:**
    Drop the egg from floor 1.  If it breaks, we know with certainty that F = 0.
    Otherwise, drop the egg from floor 2.  If it breaks, we know with certainty that F = 1.
    If it didn 't break, then we know with certainty F = 2.
    Hence, we needed 2 moves in the worst case to know what F is with certainty.
    

**Example 2:**

    
    
    **Input:** K = 2, N = 6
    **Output:** 3
    

**Example 3:**

    
    
    **Input:** K = 3, N = 14
    **Output:** 4
    



**Note:**

  1. `1 <= K <= 100`
  2. `1 <= N <= 10000`










## 924 - Fair Candy Swap
~1~  ['Array']
Alice and Bob have candy bars of different sizes: `A[i]` is the size of the
`i`-th bar of candy that Alice has, and `B[j]` is the size of the `j`-th bar
of candy that Bob has.

Since they are friends, they would like to exchange one candy bar each so that
after the exchange, they both have the same total amount of candy.  ( _The
total amount of candy  a person has is the sum of the sizes of candy bars they
have._)

Return an integer array `ans` where `ans[0]` is the size of the candy bar that
Alice must exchange, and `ans[1]` is the size of the candy bar that Bob must
exchange.

If there are multiple answers, you may return any one of them.  It is
guaranteed an answer exists.



**Example 1:**

    
    
    **Input:** A = [1,1], B = [2,2]
    **Output:** [1,2]
    

**Example 2:**

    
    
    **Input:** A = [1,2], B = [2,3]
    **Output:** [1,2]
    

**Example 3:**

    
    
    **Input:** A = [2], B = [1,3]
    **Output:** [2,3]
    

**Example 4:**

    
    
    **Input:** A = [1,2,5], B = [2,4]
    **Output:** [5,4]
    



**Note:**

  * `1 <= A.length <= 10000`
  * `1 <= B.length <= 10000`
  * ` 1 <= A[i] <= 100000`
  * `1 <= B[i] <= 100000`
  * It is guaranteed that Alice and Bob have different total amounts of candy.
  * It is guaranteed there exists an answer.










## 925 - Construct Binary Tree from Preorder and Postorder Traversal
~2~  ['Tree']
Return any binary tree that matches the given preorder and postorder
traversals.

Values in the traversals `pre` and `post` are distinct positive integers.



**Example 1:**

    
    
    **Input:** pre = [1,2,4,5,3,6,7], post = [4,5,2,6,7,3,1]
    **Output:** [1,2,3,4,5,6,7]
    



**Note:**

  * `1 <= pre.length == post.length <= 30`
  * `pre[]` and `post[]` are both permutations of `1, 2, ..., pre.length`.
  * It is guaranteed an answer exists. If there exists multiple answers, you can return any of them.










## 926 - Find and Replace Pattern
~2~  ['String']
You have a list of `words` and a `pattern`, and you want to know which words
in `words` matches the pattern.

A word matches the pattern if there exists a permutation of letters `p` so
that after replacing every letter `x` in the pattern with `p(x)`, we get the
desired word.

( _Recall that a permutation of letters is a bijection from letters to
letters: every letter maps to another letter, and no two letters map to the
same letter._ )

Return a list of the words in `words` that match the given pattern.

You may return the answer in any order.



**Example 1:**

    
    
    **Input:** words = ["abc","deq","mee","aqq","dkd","ccc"], pattern = "abb"
    **Output:** ["mee","aqq"]
    **Explanation:** "mee" matches the pattern because there is a permutation {a -> m, b -> e, ...}. 
    "ccc" does not match the pattern because {a -> c, b -> c, ...} is not a permutation,
    since a and b map to the same letter.



**Note:**

  * `1 <= words.length <= 50`
  * `1 <= pattern.length = words[i].length <= 20`










## 927 - Sum of Subsequence Widths
~3~  ['Array', 'Math']
Given an array of integers `A`, consider all non-empty subsequences of `A`.

For any sequence S, let the  _width_  of S be the difference between the
maximum and minimum element of S.

Return the sum of the widths of all subsequences of A.

As the answer may be very large, **return the answer modulo 10^9 + 7**.



**Example 1:**

    
    
    **Input:** [2,1,3]
    **Output:** 6
    **Explanation:** Subsequences are [1], [2], [3], [2,1], [2,3], [1,3], [2,1,3].
    The corresponding widths are 0, 0, 0, 1, 1, 2, 2.
    The sum of these widths is 6.
    



**Note:**

  * `1 <= A.length <= 20000`
  * `1 <= A[i] <= 20000`










## 928 - Surface Area of 3D Shapes
~1~  ['Math', 'Geometry']
On a `N * N` grid, we place some `1 * 1 * 1 `cubes.

Each value `v = grid[i][j]` represents a tower of `v` cubes placed on top of
grid cell `(i, j)`.

Return the total surface area of the resulting shapes.



**Example 1:**

    
    
    **Input:** [[2]]
    **Output:** 10
    

**Example 2:**

    
    
    **Input:** [[1,2],[3,4]]
    **Output:** 34
    

**Example 3:**

    
    
    **Input:** [[1,0],[0,2]]
    **Output:** 16
    

**Example 4:**

    
    
    **Input:** [[1,1,1],[1,0,1],[1,1,1]]
    **Output:** 32
    

**Example 5:**

    
    
    **Input:** [[2,2,2],[2,1,2],[2,2,2]]
    **Output:** 46
    



**Note:**

  * `1 <= N <= 50`
  * `0 <= grid[i][j] <= 50`










## 929 - Groups of Special-Equivalent Strings
~1~  ['String']
You are given an array `A` of strings.

Two strings `S` and `T` are  _special-equivalent_  if after any number of
_moves_ , S == T.

A _move_ consists of choosing two indices `i` and `j` with `i % 2 == j % 2`,
and swapping `S[i]` with `S[j]`.

Now, a _group of special-equivalent strings from`A`_  is a non-empty subset S
of `A` such that any string not in S is not special-equivalent with any string
in S.

Return the number of groups of special-equivalent strings from `A`.



**Example 1:**

    
    
    **Input:** ["a","b","c","a","c","c"]
    **Output:** 3
    **Explanation** : 3 groups ["a","a"], ["b"], ["c","c","c"]
    

**Example 2:**

    
    
    **Input:** ["aa","bb","ab","ba"]
    **Output:** 4
    **Explanation** : 4 groups ["aa"], ["bb"], ["ab"], ["ba"]
    

**Example 3:**

    
    
    **Input:** ["abc","acb","bac","bca","cab","cba"]
    **Output:** 3
    **Explanation** : 3 groups ["abc","cba"], ["acb","bca"], ["bac","cab"]
    

**Example 4:**

    
    
    **Input:** ["abcd","cdab","adcb","cbad"]
    **Output:** 1
    **Explanation** : 1 group ["abcd","cdab","adcb","cbad"]
    



**Note:**

  * `1 <= A.length <= 1000`
  * `1 <= A[i].length <= 20`
  * All `A[i]` have the same length.
  * All `A[i]` consist of only lowercase letters.










## 930 - All Possible Full Binary Trees
~2~  ['Tree', 'Recursion']
A _full binary tree_  is a binary tree where each node has exactly 0 or 2
children.

Return a list of all possible full binary trees with `N` nodes.  Each element
of the answer is the root node of one possible tree.

Each `node` of each tree in the answer **must** have `node.val = 0`.

You may return the final list of trees in any order.



**Example 1:**

    
    
    **Input:** 7
    **Output:** [[0,0,0,null,null,0,0,null,null,0,0],[0,0,0,null,null,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,null,null,null,null,0,0],[0,0,0,0,0,null,null,0,0]]
    **Explanation:**
    ![](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/08/22/fivetrees.png)
    



**Note:**

  * `1 <= N <= 20`










## 931 - Maximum Frequency Stack
~3~  ['Hash Table', 'Stack']
Implement `FreqStack`, a class which simulates the operation of a stack-like
data structure.

`FreqStack` has two functions:

  * `push(int x)`, which pushes an integer `x` onto the stack.
  * `pop()`, which **removes** and returns the most frequent element in the stack. 
    * If there is a tie for most frequent element, the element closest to the top of the stack is removed and returned.



**Example 1:**

    
    
    **Input:**
     ["FreqStack","push","push","push","push","push","push","pop","pop","pop","pop"],
    [[],[5],[7],[5],[7],[4],[5],[],[],[],[]]
    **Output:** [null,null,null,null,null,null,null,5,7,5,4]
    **Explanation** :
    After making six .push operations, the stack is [5,7,5,7,4,5] from bottom to top.  Then:
    
    pop() -> returns 5, as 5 is the most frequent.
    The stack becomes [5,7,5,7,4].
    
    pop() -> returns 7, as 5 and 7 is the most frequent, but 7 is closest to the top.
    The stack becomes [5,7,5,4].
    
    pop() -> returns 5.
    The stack becomes [5,7,4].
    
    pop() -> returns 4.
    The stack becomes [5,7].
    



**Note:**

  * Calls to `FreqStack.push(int x)` will be such that `0 <= x <= 10^9`.
  * It is guaranteed that `FreqStack.pop()` won't be called if the stack has zero elements.
  * The total number of `FreqStack.push` calls will not exceed `10000` in a single test case.
  * The total number of `FreqStack.pop` calls will not exceed `10000` in a single test case.
  * The total number of `FreqStack.push` and `FreqStack.pop` calls will not exceed `150000` across all test cases.










## 932 - Monotonic Array
~1~  ['Array']
An array is _monotonic_ if it is either monotone increasing or monotone
decreasing.

An array `A` is monotone increasing if for all `i <= j`, `A[i] <= A[j]`.  An
array `A` is monotone decreasing if for all `i <= j`, `A[i] >= A[j]`.

Return `true` if and only if the given array `A` is monotonic.



**Example 1:**

    
    
    **Input:** [1,2,2,3]
    **Output:** true
    

**Example 2:**

    
    
    **Input:** [6,5,4,4]
    **Output:** true
    

**Example 3:**

    
    
    **Input:** [1,3,2]
    **Output:** false
    

**Example 4:**

    
    
    **Input:** [1,2,4,5]
    **Output:** true
    

**Example 5:**

    
    
    **Input:** [1,1,1]
    **Output:** true
    



**Note:**

  1. `1 <= A.length <= 50000`
  2. `-100000 <= A[i] <= 100000`










## 933 - Increasing Order Search Tree
~1~  ['Tree', 'Depth-first Search']
Given a tree, rearrange the tree in **in-order** so that the leftmost node in
the tree is now the root of the tree, and every node has no left child and
only 1 right child.

    
    
    **Example 1:**
    **Input:** [5,3,6,2,4,null,8,1,null,null,null,7,9]
    
           5
          / \
        3    6
       / \    \
      2   4    8
      /        / \ 
    1        7   9
    
    **Output:** [1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]
    
     1
       \
       2
        \
         3
          \
           4
            \
             5
              \
               6
                \
                 7
                  \
                   8
                    \
                     9  

**Note:**

  1. The number of nodes in the given tree will be between 1 and 100.
  2. Each node will have a unique integer value from 0 to 1000.










## 934 - Bitwise ORs of Subarrays
~2~  ['Dynamic Programming', 'Bit Manipulation']
We have an array `A` of non-negative integers.

For every (contiguous) subarray `B = [A[i], A[i+1], ..., A[j]]` (with `i <=
j`), we take the bitwise OR of all the elements in `B`, obtaining a result
`A[i] | A[i+1] | ... | A[j]`.

Return the number of possible results.  (Results that occur more than once are
only counted once in the final answer.)



**Example 1:**

    
    
    **Input:** [0]
    **Output:** 1
    **Explanation:**
    There is only one possible result: 0.
    

**Example 2:**

    
    
    **Input:** [1,1,2]
    **Output:** 3
    **Explanation:**
    The possible subarrays are [1], [1], [2], [1, 1], [1, 2], [1, 1, 2].
    These yield the results 1, 1, 2, 1, 3, 3.
    There are 3 unique values, so the answer is 3.
    

**Example 3:**

    
    
    **Input:** [1,2,4]
    **Output:** 6
    **Explanation:**
    The possible results are 1, 2, 3, 4, 6, and 7.
    



**Note:**

  1. `1 <= A.length <= 50000`
  2. `0 <= A[i] <= 10^9`










## 935 - Orderly Queue
~3~  ['Math', 'String']
A string `S` of lowercase letters is given.  Then, we may make any number of
_moves_.

In each move, we choose one of the first `K` letters (starting from the left),
remove it, and place it at the end of the string.

Return the lexicographically smallest string we could have after any number of
moves.



**Example 1:**

    
    
    **Input:** S = "cba", K = 1
    **Output:** "acb"
    **Explanation:**
    In the first move, we move the 1st character ( "c") to the end, obtaining the string "bac".
    In the second move, we move the 1st character ("b") to the end, obtaining the final result "acb".
    

**Example 2:**

    
    
    **Input:** S = "baaca", K = 3
    **Output:** "aaabc"
    **Explanation:**
    In the first move, we move the 1st character ( "b") to the end, obtaining the string "aacab".
    In the second move, we move the 3rd character ("c") to the end, obtaining the final result "aaabc".
    



**Note:**

  1. `1 <= K <= S.length <= 1000`
  2. `S` consists of lowercase letters only.










## 936 - RLE Iterator
~2~  ['Array']
Write an iterator that iterates through a run-length encoded sequence.

The iterator is initialized by `RLEIterator(int[] A)`, where `A` is a run-
length encoding of some sequence.  More specifically, for all even `i`, `A[i]`
tells us the number of times that the non-negative integer value `A[i+1]` is
repeated in the sequence.

The iterator supports one function: `next(int n)`, which exhausts the next `n`
elements (`n >= 1`) and returns the last element exhausted in this way.  If
there is no element left to exhaust, `next` returns `-1` instead.

For example, we start with `A = [3,8,0,9,2,5]`, which is a run-length encoding
of the sequence `[8,8,8,5,5]`.  This is because the sequence can be read as
"three eights, zero nines, two fives".



**Example 1:**

    
    
    **Input:** ["RLEIterator","next","next","next","next"], [[[3,8,0,9,2,5]],[2],[1],[1],[2]]
    **Output:** [null,8,8,5,-1]
    **Explanation:**
    RLEIterator is initialized with RLEIterator([3,8,0,9,2,5]).
    This maps to the sequence [8,8,8,5,5].
    RLEIterator.next is then called 4 times:
    
    .next(2) exhausts 2 terms of the sequence, returning 8.  The remaining sequence is now [8, 5, 5].
    
    .next(1) exhausts 1 term of the sequence, returning 8.  The remaining sequence is now [5, 5].
    
    .next(1) exhausts 1 term of the sequence, returning 5.  The remaining sequence is now [5].
    
    .next(2) exhausts 2 terms, returning -1.  This is because the first term exhausted was 5,
    but the second term did not exist.  Since the last term exhausted does not exist, we return -1.
    
    

**Note:**

  1. `0 <= A.length <= 1000`
  2. `A.length` is an even integer.
  3. `0 <= A[i] <= 10^9`
  4. There are at most `1000` calls to `RLEIterator.next(int n)` per test case.
  5. Each call to `RLEIterator.next(int n)` will have `1 <= n <= 10^9`.










## 937 - Online Stock Span
~2~  ['Stack']
Write a class `StockSpanner` which collects daily price quotes for some stock,
and returns the _span_  of that stock's price for the current day.

The span of the stock's price today is defined as the maximum number of
consecutive days (starting from today and going backwards) for which the price
of the stock was less than or equal to today's price.

For example, if the price of a stock over the next 7 days were `[100, 80, 60,
70, 60, 75, 85]`, then the stock spans would be `[1, 1, 1, 2, 1, 4, 6]`.



**Example 1:**

    
    
    **Input:** ["StockSpanner","next","next","next","next","next","next","next"], [[],[100],[80],[60],[70],[60],[75],[85]]
    **Output:** [null,1,1,1,2,1,4,6]
    **Explanation:**
    First, S = StockSpanner() is initialized.  Then:
    S.next(100) is called and returns 1,
    S.next(80) is called and returns 1,
    S.next(60) is called and returns 1,
    S.next(70) is called and returns 2,
    S.next(60) is called and returns 1,
    S.next(75) is called and returns 4,
    S.next(85) is called and returns 6.
    
    Note that (for example) S.next(75) returned 4, because the last 4 prices
    (including today 's price of 75) were less than or equal to today's price.
    



**Note:**

  1. Calls to `StockSpanner.next(int price)` will have `1 <= price <= 10^5`.
  2. There will be at most `10000` calls to `StockSpanner.next` per test case.
  3. There will be at most `150000` calls to `StockSpanner.next` across all test cases.
  4. The total time limit for this problem has been reduced by 75% for C++, and 50% for all other languages.










## 938 - Numbers At Most N Given Digit Set
~3~  ['Math', 'Dynamic Programming']
We have a **sorted** set of digits `D`, a non-empty subset of
`{'1','2','3','4','5','6','7','8','9'}`.  (Note that `'0'` is not included.)

Now, we write numbers using these digits, using each digit as many times as we
want.  For example, if `D = {'1','3','5'}`, we may write numbers such as
`'13', '551', '1351315'`.

Return the number of positive integers that can be written (using the digits
of `D`) that are less than or equal to `N`.



**Example 1:**

    
    
    **Input:** D = ["1","3","5","7"], N = 100
    **Output:** 20
    **Explanation:**
    The 20 numbers that can be written are:
    1, 3, 5, 7, 11, 13, 15, 17, 31, 33, 35, 37, 51, 53, 55, 57, 71, 73, 75, 77.
    

**Example 2:**

    
    
    **Input:** D = ["1","4","9"], N = 1000000000
    **Output:** 29523
    **Explanation:**
    We can write 3 one digit numbers, 9 two digit numbers, 27 three digit numbers,
    81 four digit numbers, 243 five digit numbers, 729 six digit numbers,
    2187 seven digit numbers, 6561 eight digit numbers, and 19683 nine digit numbers.
    In total, this is 29523 integers that can be written using the digits of D.



**Note:**

  1. `D` is a subset of digits `'1'-'9'` in sorted order.
  2. `1 <= N <= 10^9`










## 939 - Valid Permutations for DI Sequence
~3~  ['Divide and Conquer', 'Dynamic Programming']
We are given `S`, a length `n` string of characters from the set `{'D', 'I'}`.
(These letters stand for "decreasing" and "increasing".)

A  _valid permutation_  is a permutation `P[0], P[1], ..., P[n]` of integers
`{0, 1, ..., n}`, such that for all `i`:

  * If `S[i] == 'D'`, then `P[i] > P[i+1]`, and;
  * If `S[i] == 'I'`, then `P[i] < P[i+1]`.

How many valid permutations are there?  Since the answer may be large,
**return your answer modulo`10^9 + 7`**.



**Example 1:**

    
    
    **Input:** "DID"
    **Output:** 5
    **Explanation:**
    The 5 valid permutations of (0, 1, 2, 3) are:
    (1, 0, 3, 2)
    (2, 0, 3, 1)
    (2, 1, 3, 0)
    (3, 0, 2, 1)
    (3, 1, 2, 0)
    



**Note:**

  1. `1 <= S.length <= 200`
  2. `S` consists only of characters from the set `{'D', 'I'}`.










## 940 - Fruit Into Baskets
~2~  ['Two Pointers']
In a row of trees, the `i`-th tree produces fruit with type `tree[i]`.

You **start at any tree  of your choice**, then repeatedly perform the
following steps:

  1. Add one piece of fruit from this tree to your baskets.  If you cannot, stop.
  2. Move to the next tree to the right of the current tree.  If there is no tree to the right, stop.

Note that you do not have any choice after the initial choice of starting
tree: you must perform step 1, then step 2, then back to step 1, then step 2,
and so on until you stop.

You have two baskets, and each basket can carry any quantity of fruit, but you
want each basket to only carry one type of fruit each.

What is the total amount of fruit you can collect with this procedure?



**Example 1:**

    
    
    **Input:** [1,2,1]
    **Output:** 3
    **Explanation:** We can collect [1,2,1].
    

**Example 2:**

    
    
    **Input:** [0,1,2,2]
    **Output:** 3
    **Explanation:** We can collect [1,2,2].
    If we started at the first tree, we would only collect [0, 1].
    

**Example 3:**

    
    
    **Input:** [1,2,3,2,2]
    **Output:** 4
    **Explanation:** We can collect [2,3,2,2].
    If we started at the first tree, we would only collect [1, 2].
    

**Example 4:**

    
    
    **Input:** [3,3,3,1,2,1,1,2,3,3,4]
    **Output:** 5
    **Explanation:** We can collect [1,2,1,1,2].
    If we started at the first tree or the eighth tree, we would only collect 4 fruits.
    



**Note:**

  1. `1 <= tree.length <= 40000`
  2. `0 <= tree[i] < tree.length`










## 941 - Sort Array By Parity
~1~  ['Array']
Given an array `A` of non-negative integers, return an array consisting of all
the even elements of `A`, followed by all the odd elements of `A`.

You may return any answer array that satisfies this condition.



**Example 1:**

    
    
    **Input:** [3,1,2,4]
    **Output:** [2,4,3,1]
    The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted.
    



**Note:**

  1. `1 <= A.length <= 5000`
  2. `0 <= A[i] <= 5000`










## 942 - Super Palindromes
~3~  ['Math']
Let's say a positive integer is a  _superpalindrome_  if it is a palindrome,
and it is also the square of a palindrome.

Now, given two positive integers `L` and `R` (represented as strings), return
the number of superpalindromes in the inclusive range `[L, R]`.



**Example 1:**

    
    
    **Input:** L = "4", R = "1000"
    **Output:** 4
    **Explanation** : 4, 9, 121, and 484 are superpalindromes.
    Note that 676 is not a superpalindrome: 26 * 26 = 676, but 26 is not a palindrome.



**Note:**

  1. `1 <= len(L) <= 18`
  2. `1 <= len(R) <= 18`
  3. `L` and `R` are strings representing integers in the range `[1, 10^18)`.
  4. `int(L) <= int(R)`










## 943 - Sum of Subarray Minimums
~2~  ['Array', 'Stack']
Given an array of integers `A`, find the sum of `min(B)`, where `B` ranges
over every (contiguous) subarray of `A`.

Since the answer may be large, **return the answer modulo`10^9 + 7`.**



**Example 1:**

    
    
    **Input:** [3,1,2,4]
    **Output:** 17
    **Explanation:** Subarrays are [3], [1], [2], [4], [3,1], [1,2], [2,4], [3,1,2], [1,2,4], [3,1,2,4]. 
    Minimums are 3, 1, 2, 4, 1, 1, 2, 1, 1, 1.   Sum is 17.



**Note:**

  1. `1 <= A.length <= 30000`
  2. `1 <= A[i] <= 30000`










## 944 - Smallest Range I
~1~  []
Given an array `A` of integers, for each integer `A[i]` we may choose any `x`
with `-K <= x <= K`, and add `x` to `A[i]`.

After this process, we have some array `B`.

Return the smallest possible difference between the maximum value of `B` and
the minimum value of `B`.



**Example 1:**

    
    
    **Input:** A = [1], K = 0
    **Output:** 0
    **Explanation** : B = [1]
    

**Example 2:**

    
    
    **Input:** A = [0,10], K = 2
    **Output:** 6
    **Explanation** : B = [2,8]
    

**Example 3:**

    
    
    **Input:** A = [1,3,6], K = 3
    **Output:** 0
    **Explanation** : B = [3,3,3] or B = [4,4,4]
    



**Note:**

  1. `1 <= A.length <= 10000`
  2. `0 <= A[i] <= 10000`
  3. `0 <= K <= 10000`










## 945 - Snakes and Ladders
~2~  []
On an N x N `board`, the numbers from `1` to `N*N` are written
_boustrophedonically_   **starting from the bottom  left of the board**, and
alternating direction each row.  For example, for a 6 x 6 board, the numbers
are written as follows:

    
    
    ![](https://assets.leetcode.com/uploads/2018/09/23/snakes.png)
    

You start on square `1` of the board (which is always in the last row and
first column).  Each move, starting from square `x`, consists of the
following:

  * You choose a destination square `S` with number `x+1`, `x+2`, `x+3`, `x+4`, `x+5`, or `x+6`, provided this number is `<= N*N`. 
    * (This choice simulates the result of a standard 6-sided die roll: ie., there are always at most 6 destinations.)
  * If `S` has a snake or ladder, you move to the destination of that snake or ladder.  Otherwise, you move to `S`.

A board square on row `r` and column `c` has a "snake or ladder" if
`board[r][c] != -1`.  The destination of that snake or ladder is
`board[r][c]`.

Note that you only take a snake or ladder at most once per move: if the
destination to a snake or ladder is the start of another snake or ladder, you
do **not** continue moving.   (For example, if the board is `[[4,-1],[-1,3]]`,
and on the first move your destination square is `2`, then you finish your
first move at `3`, because you do **not** continue moving to `4`.)

Return the least number of moves required to reach square N*N.  If it is not
possible, return `-1`.

**Example 1:**

    
    
    **Input:** [
    [-1,-1,-1,-1,-1,-1],
    [-1,-1,-1,-1,-1,-1],
    [-1,-1,-1,-1,-1,-1],
    [-1,35,-1,-1,13,-1],
    [-1,-1,-1,-1,-1,-1],
    [-1,15,-1,-1,-1,-1]]
    **Output:** 4
    **Explanation:**
    At the beginning, you start at square 1 [at row 5, column 0].
    You decide to move to square 2, and must take the ladder to square 15.
    You then decide to move to square 17 (row 3, column 5), and must take the snake to square 13.
    You then decide to move to square 14, and must take the ladder to square 35.
    You then decide to move to square 36, ending the game.
    It can be shown that you need at least 4 moves to reach the N*N-th square, so the answer is 4.
    

**Note:**

  1. `2 <= board.length = board[0].length <= 20`
  2. `board[i][j]` is between `1` and `N*N` or is equal to `-1`.
  3. The board square with number `1` has no snake or ladder.
  4. The board square with number `N*N` has no snake or ladder.










## 946 - Smallest Range II
~2~  []
Given an array `A` of integers, for each integer `A[i]` we need to choose
**either  `x = -K` or `x = K`**, and add `x` to `A[i] **(only once)**`.

After this process, we have some array `B`.

Return the smallest possible difference between the maximum value of `B` and
the minimum value of `B`.



**Example 1:**

    
    
    **Input:** A = [1], K = 0
    **Output:** 0
    **Explanation** : B = [1]
    

**Example 2:**

    
    
    **Input:** A = [0,10], K = 2
    **Output:** 6
    **Explanation** : B = [2,8]
    

**Example 3:**

    
    
    **Input:** A = [1,3,6], K = 3
    **Output:** 3
    **Explanation** : B = [4,6,3]
    



**Note:**

  1. `1 <= A.length <= 10000`
  2. `0 <= A[i] <= 10000`
  3. `0 <= K <= 10000`










## 947 - Online Election
~2~  []
In an election, the `i`-th vote was cast for `persons[i]` at time `times[i]`.

Now, we would like to implement the following query function:
`TopVotedCandidate.q(int t)` will return the number of the person that was
leading the election at time `t`.  

Votes cast at time `t` will count towards our query.  In the case of a tie,
the most recent vote (among tied candidates) wins.



**Example 1:**

    
    
    **Input:** ["TopVotedCandidate","q","q","q","q","q","q"], [[[0,1,1,0,0,1,0],[0,5,10,15,20,25,30]],[3],[12],[25],[15],[24],[8]]
    **Output:** [null,0,1,1,0,0,1]
    **Explanation:**
    At time 3, the votes are [0], and 0 is leading.
    At time 12, the votes are [0,1,1], and 1 is leading.
    At time 25, the votes are [0,1,1,0,0,1], and 1 is leading (as ties go to the most recent vote.)
    This continues for 3 more queries at time 15, 24, and 8.
    



**Note:**

  1. `1 <= persons.length = times.length <= 5000`
  2. `0 <= persons[i] <= persons.length`
  3. `times` is a strictly increasing array with all elements in `[0, 10^9]`.
  4. `TopVotedCandidate.q` is called at most `10000` times per test case.
  5. `TopVotedCandidate.q(int t)` is always called with `t >= times[0]`.










## 949 - Cat and Mouse
~3~  ['Breadth-first Search', 'Minimax']
A game on an **undirected** graph is played by two players, Mouse and Cat, who
alternate turns.

The graph is given as follows: `graph[a]` is a list of all nodes `b` such that
`ab` is an edge of the graph.

Mouse starts at node 1 and goes first, Cat starts at node 2 and goes second,
and there is a Hole at node 0.

During each player's turn, they **must** travel along one  edge of the graph
that meets where they are.  For example, if the Mouse is at node `1`, it
**must** travel to any node in `graph[1]`.

Additionally, it is not allowed for the Cat to travel to the Hole (node 0.)

Then, the game can end in 3 ways:

  * If ever the Cat occupies the same node as the Mouse, the Cat wins.
  * If ever the Mouse reaches the Hole, the Mouse wins.
  * If ever a position is repeated (ie. the players are in the same position as a previous turn, and it is the same player's turn to move), the game is a draw.

Given a `graph`, and assuming both players play optimally, return `1` if the
game is won by Mouse, `2` if the game is won by Cat, and `0` if the game is a
draw.



**Example 1:**

    
    
    **Input:** [[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]]
    **Output:** 0
    **Explanation:**
     4---3---1
    |   |
    2---5
     \ /
      0
    



**Note:**

  1. `3 <= graph.length <= 50`
  2. It is guaranteed that `graph[1]` is non-empty.
  3. It is guaranteed that `graph[2]` contains a non-zero element.










## 950 - X of a Kind in a Deck of Cards
~1~  ['Array', 'Math']
In a deck of cards, each card has an integer written on it.

Return `true` if and only if you can choose `X >= 2` such that it is possible
to split the entire deck into 1 or more groups of cards, where:

  * Each group has exactly `X` cards.
  * All the cards in each group have the same integer.



**Example 1:**

    
    
    **Input:** [1,2,3,4,4,3,2,1]
    **Output:** true
    **Explanation** : Possible partition [1,1],[2,2],[3,3],[4,4]
    

**Example 2:**

    
    
    **Input:** [1,1,1,2,2,2,3,3]
    **Output:** false
    **Explanation** : No possible partition.
    

**Example 3:**

    
    
    **Input:** [1]
    **Output:** false
    **Explanation** : No possible partition.
    

**Example 4:**

    
    
    **Input:** [1,1]
    **Output:** true
    **Explanation** : Possible partition [1,1]
    

**Example 5:**

    
    
    **Input:** [1,1,2,2,2,2]
    **Output:** true
    **Explanation** : Possible partition [1,1],[2,2],[2,2]
    

  
**Note:**

  1. `1 <= deck.length <= 10000`
  2. `0 <= deck[i] < 10000`










## 951 - Partition Array into Disjoint Intervals
~2~  ['Array']
Given an array `A`, partition it into two (contiguous) subarrays `left` and
`right` so that:

  * Every element in `left` is less than or equal to every element in `right`.
  * `left` and `right` are non-empty.
  * `left` has the smallest possible size.

Return the **length** of `left` after such a partitioning.  It is guaranteed
that such a partitioning exists.



**Example 1:**

    
    
    **Input:** [5,0,3,8,6]
    **Output:** 3
    **Explanation:** left = [5,0,3], right = [8,6]
    

**Example 2:**

    
    
    **Input:** [1,1,1,0,6,12]
    **Output:** 4
    **Explanation:** left = [1,1,1,0], right = [6,12]
    



**Note:**

  1. `2 <= A.length <= 30000`
  2. `0 <= A[i] <= 10^6`
  3. It is guaranteed there is at least one way to partition `A` as described.










## 952 - Word Subsets
~2~  ['String']
We are given two arrays `A` and `B` of words.  Each word is a string of
lowercase letters.

Now, say that word `b` is a subset of word `a` ** ** if every letter in `b`
occurs in `a`, **including multiplicity**.   For example, `"wrr"` is a subset
of `"warrior"`, but is not a subset of `"world"`.

Now say a word `a` from `A` is _universal_ if for every `b` in `B`, `b` is a
subset of `a`.

Return a list of all universal words in `A`.  You can return the words in any
order.



**Example 1:**

    
    
    **Input:** A = ["amazon","apple","facebook","google","leetcode"], B = ["e","o"]
    **Output:** ["facebook","google","leetcode"]
    

**Example 2:**

    
    
    **Input:** A = ["amazon","apple","facebook","google","leetcode"], B = ["l","e"]
    **Output:** ["apple","google","leetcode"]
    

**Example 3:**

    
    
    **Input:** A = ["amazon","apple","facebook","google","leetcode"], B = ["e","oo"]
    **Output:** ["facebook","google"]
    

**Example 4:**

    
    
    **Input:** A = ["amazon","apple","facebook","google","leetcode"], B = ["lo","eo"]
    **Output:** ["google","leetcode"]
    

**Example 5:**

    
    
    **Input:** A = ["amazon","apple","facebook","google","leetcode"], B = ["ec","oc","ceo"]
    **Output:** ["facebook","leetcode"]
    



**Note:**

  1. `1 <= A.length, B.length <= 10000`
  2. `1 <= A[i].length, B[i].length <= 10`
  3. `A[i]` and `B[i]` consist only of lowercase letters.
  4. All words in `A[i]` are unique: there isn't `i != j` with `A[i] == A[j]`.










## 953 - Reverse Only Letters
~1~  []
Given a string `S`, return the "reversed" string where all characters that are
not a letter stay in the same place, and all letters reverse their positions.



**Example 1:**

    
    
    **Input:** "ab-cd"
    **Output:** "dc-ba"
    

**Example 2:**

    
    
    **Input:** "a-bC-dEf-ghIj"
    **Output:** "j-Ih-gfE-dCba"
    

**Example 3:**

    
    
    **Input:** "Test1ng-Leet=code-Q!"
    **Output:** "Qedo1ct-eeLg=ntse-T!"
    



**Note:**

  1. `S.length <= 100`
  2. `33 <= S[i].ASCIIcode <= 122` 
  3. `S` doesn't contain `\` or `"`










## 954 - Maximum Sum Circular Subarray
~2~  []
Given a **circular  array**  **C** of integers represented by  `A`, find the
maximum possible sum of a non-empty subarray of **C**.

Here, a  _circular  array_ means the end of the array connects to the
beginning of the array.  (Formally, `C[i] = A[i]` when `0 <= i < A.length`,
and `C[i+A.length] = C[i]` when `i >= 0`.)

Also, a subarray may only include each element of the fixed buffer `A` at most
once.  (Formally, for a subarray `C[i], C[i+1], ..., C[j]`, there does not
exist `i <= k1, k2 <= j` with `k1 % A.length = k2 % A.length`.)



**Example 1:**

    
    
    **Input:** [1,-2,3,-2]
    **Output:** 3
    **Explanation:** Subarray [3] has maximum sum 3
    

**Example 2:**

    
    
    **Input:** [5,-3,5]
    **Output:** 10
    **Explanation:**  Subarray [5,5] has maximum sum 5 + 5 = 10
    

**Example 3:**

    
    
    **Input:** [3,-1,2,-1]
    **Output:** 4
    **Explanation:**  Subarray [2,-1,3] has maximum sum 2 + (-1) + 3 = 4
    

**Example 4:**

    
    
    **Input:** [3,-2,2,-3]
    **Output:** 3
    **Explanation:**  Subarray [3] and [3,-2,2] both have maximum sum 3
    

**Example 5:**

    
    
    **Input:** [-2,-3,-1]
    **Output:** -1
    **Explanation:**  Subarray [-1] has maximum sum -1
    



**Note:**

  1. `-30000 <= A[i] <= 30000`
  2. `1 <= A.length <= 30000`










## 955 - Complete Binary Tree Inserter
~2~  []
A _complete_ binary tree is a binary tree in which every level, except
possibly the last, is completely filled, and all nodes are as far left as
possible.

Write a data structure `CBTInserter` that is initialized with a complete
binary tree and supports the following operations:

  * `CBTInserter(TreeNode root)` initializes the data structure on a given tree with head node `root`;
  * `CBTInserter.insert(int v)` will insert a `TreeNode` into the tree with value `node.val = v` so that the tree remains complete, **and returns the value of the parent of the inserted`TreeNode`** ;
  * `CBTInserter.get_root()` will return the head node of the tree.



**Example 1:**

    
    
    **Input:** inputs = ["CBTInserter","insert","get_root"], inputs = [[[1]],[2],[]]
    **Output:** [null,1,[1,2]]
    

**Example 2:**

    
    
    **Input:** inputs = ["CBTInserter","insert","insert","get_root"], inputs = [[[1,2,3,4,5,6]],[7],[8],[]]
    **Output:** [null,3,4,[1,2,3,4,5,6,7,8]]



**Note:**

  1. The initial given tree is complete and contains between `1` and `1000` nodes.
  2. `CBTInserter.insert` is called at most `10000` times per test case.
  3. Every value of a given or inserted node is between `0` and `5000`.










## 956 - Number of Music Playlists
~3~  []
Your music player contains `N` different songs and she wants to listen to `L`
**** (not necessarily different) songs during your trip.  You create a
playlist so that:

  * Every song is played at least once
  * A song can only be played again only if `K` other songs have been played

Return the number of possible playlists.  **As the answer can be very large,
return it modulo`10^9 + 7`**.



**Example 1:**

    
    
    **Input:** N = 3, L = 3, K = 1
    **Output:** 6
    **Explanation** : There are 6 possible playlists. [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1].
    

**Example 2:**

    
    
    **Input:** N = 2, L = 3, K = 0
    **Output:** 6
    **Explanation** : There are 6 possible playlists. [1, 1, 2], [1, 2, 1], [2, 1, 1], [2, 2, 1], [2, 1, 2], [1, 2, 2]
    

**Example 3:**

    
    
    **Input:** N = 2, L = 3, K = 1
    **Output:** 2
    **Explanation** : There are 2 possible playlists. [1, 2, 1], [2, 1, 2]
    



**Note:**

  1. `0 <= K < N <= L <= 100`










## 957 - Minimum Add to Make Parentheses Valid
~2~  ['Stack', 'Greedy']
Given a string `S` of `'('` and `')'` parentheses, we add the minimum number
of parentheses ( `'('` or `')'`, and in any positions ) so that the resulting
parentheses string is valid.

Formally, a parentheses string is valid if and only if:

  * It is the empty string, or
  * It can be written as `AB` (`A` concatenated with `B`), where `A` and `B` are valid strings, or
  * It can be written as `(A)`, where `A` is a valid string.

Given a parentheses string, return the minimum number of parentheses we must
add to make the resulting string valid.



**Example 1:**

    
    
    **Input:** "())"
    **Output:** 1
    

**Example 2:**

    
    
    **Input:** "((("
    **Output:** 3
    

**Example 3:**

    
    
    **Input:** "()"
    **Output:** 0
    

**Example 4:**

    
    
    **Input:** "()))(("
    **Output:** 4



**Note:**

  1. `S.length <= 1000`
  2. `S` only consists of `'('` and `')'` characters.










## 958 - Sort Array By Parity II
~1~  ['Array', 'Sort']
Given an array `A` of non-negative integers, half of the integers in A are
odd, and half of the integers are even.

Sort the array so that whenever `A[i]` is odd, `i` is odd; and whenever `A[i]`
is even, `i` is even.

You may return any answer array that satisfies this condition.



**Example 1:**

    
    
    **Input:** [4,2,5,7]
    **Output:** [4,5,2,7]
    **Explanation:** [4,7,2,5], [2,5,4,7], [2,7,4,5] would also have been accepted.
    



**Note:**

  1. `2 <= A.length <= 20000`
  2. `A.length % 2 == 0`
  3. `0 <= A[i] <= 1000`










## 959 - 3Sum With Multiplicity
~2~  ['Two Pointers']
Given an integer array `A`, and an integer `target`, return the number of
tuples `i, j, k`  such that `i < j < k` and `A[i] + A[j] + A[k] == target`.

**As the answer can be very large, return it modulo  `10^9 + 7`**.



**Example 1:**

    
    
    **Input:** A = [1,1,2,2,3,3,4,4,5,5], target = 8
    **Output:** 20
    **Explanation:**
    Enumerating by the values (A[i], A[j], A[k]):
    (1, 2, 5) occurs 8 times;
    (1, 3, 4) occurs 8 times;
    (2, 2, 4) occurs 2 times;
    (2, 3, 3) occurs 2 times.
    

**Example 2:**

    
    
    **Input:** A = [1,1,2,2,2,2], target = 5
    **Output:** 12
    **Explanation:**
    A[i] = 1, A[j] = A[k] = 2 occurs 12 times:
    We choose one 1 from [1,1] in 2 ways,
    and two 2s from [2,2,2,2] in 6 ways.
    



**Note:**

  1. `3 <= A.length <= 3000`
  2. `0 <= A[i] <= 100`
  3. `0 <= target <= 300`










## 960 - Minimize Malware Spread
~3~  ['Depth-first Search', 'Union Find']
In a network of nodes, each node `i` is directly connected to another node `j`
if and only if `graph[i][j] = 1`.

Some nodes `initial` are initially infected by malware.  Whenever two nodes
are directly connected and at least one of those two nodes is infected by
malware, both nodes will be infected by malware.  This spread of malware will
continue until no more nodes can be infected in this manner.

Suppose `M(initial)` is the final number of nodes infected with malware in the
entire network, after the spread of malware stops.

We will remove one node from the initial list.  Return the node that if
removed, would minimize `M(initial)`.  If multiple nodes could be removed to
minimize `M(initial)`, return such a node with the smallest index.

Note that if a node was removed from the `initial` list of infected nodes, it
may still be infected later as a result of the malware spread.



**Example 1:**

    
    
    **Input:** graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
    **Output:** 0
    

**Example 2:**

    
    
    **Input:** graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]
    **Output:** 0
    

**Example 3:**

    
    
    **Input:** graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]
    **Output:** 1
    



**Note:**

  1. `1 < graph.length = graph[0].length <= 300`
  2. `0 <= graph[i][j] == graph[j][i] <= 1`
  3. `graph[i][i] = 1`
  4. `1 <= initial.length < graph.length`
  5. `0 <= initial[i] < graph.length`










## 961 - Long Pressed Name
~1~  ['Two Pointers', 'String']
Your friend is typing his `name` into a keyboard.  Sometimes, when typing a
character `c`, the key might get _long pressed_ , and the character will be
typed 1 or more times.

You examine the `typed` characters of the keyboard.  Return `True` if it is
possible that it was your friends name, with some characters (possibly none)
being long pressed.



**Example 1:**

    
    
    **Input:** name = "alex", typed = "aaleex"
    **Output:** true
    **Explanation:** 'a' and 'e' in 'alex' were long pressed.
    

**Example 2:**

    
    
    **Input:** name = "saeed", typed = "ssaaedd"
    **Output:** false
    **Explanation:** 'e' must have been pressed twice, but it wasn't in the typed output.
    

**Example 3:**

    
    
    **Input:** name = "leelee", typed = "lleeelee"
    **Output:** true
    

**Example 4:**

    
    
    **Input:** name = "laiden", typed = "laiden"
    **Output:** true
    **Explanation:** It's not necessary to long press any character.
    



**Note:**

  1. `name.length <= 1000`
  2. `typed.length <= 1000`
  3. The characters of `name` and `typed` are lowercase letters.










## 962 - Flip String to Monotone Increasing
~2~  ['Array']
A string of `'0'`s and `'1'`s is _monotone increasing_ if it consists of some
number of `'0'`s (possibly 0), followed by some number of `'1'`s (also
possibly 0.)

We are given a string `S` of `'0'`s and `'1'`s, and we may flip any `'0'` to a
`'1'` or a `'1'` to a `'0'`.

Return the minimum number of flips to make `S` monotone increasing.



**Example 1:**

    
    
    **Input:** "00110"
    **Output:** 1
    **Explanation:** We flip the last digit to get 00111.
    

**Example 2:**

    
    
    **Input:** "010110"
    **Output:** 2
    **Explanation:** We flip to get 011111, or alternatively 000111.
    

**Example 3:**

    
    
    **Input:** "00011000"
    **Output:** 2
    **Explanation:** We flip to get 00000000.
    



**Note:**

  1. `1 <= S.length <= 20000`
  2. `S` only consists of `'0'` and `'1'` characters.










## 963 - Three Equal Parts
~3~  ['Math', 'Binary Search', 'Greedy']
Given an array `A` of `0`s and `1`s, divide the array into 3 non-empty parts
such that all of these parts represent the same binary value.

If it is possible, return **any** `[i, j]` with `i+1 < j`, such that:

  * `A[0], A[1], ..., A[i]` is the first part;
  * `A[i+1], A[i+2], ..., A[j-1]` is the second part, and
  * `A[j], A[j+1], ..., A[A.length - 1]` is the third part.
  * All three parts have equal binary value.

If it is not possible, return `[-1, -1]`.

Note that the entire part is used when considering what binary value it
represents.  For example, `[1,1,0]` represents `6` in decimal, not `3`.  Also,
leading zeros are allowed, so `[0,1,1]` and `[1,1]` represent the same value.



**Example 1:**

    
    
    **Input:** [1,0,1,0,1]
    **Output:** [0,3]
    

**Example 2:**

    
    
    **Input:** [1,1,0,1,1]
    **Output:** [-1,-1]



**Note:**

  1. `3 <= A.length <= 30000`
  2. `A[i] == 0` or `A[i] == 1`










## 964 - Minimize Malware Spread II
~3~  ['Depth-first Search', 'Union Find', 'Graph']
(This problem is the same as _Minimize Malware Spread_ , with the differences
bolded.)

In a network of nodes, each node `i` is directly connected to another node `j`
if and only if `graph[i][j] = 1`.

Some nodes `initial` are initially infected by malware.  Whenever two nodes
are directly connected and at least one of those two nodes is infected by
malware, both nodes will be infected by malware.  This spread of malware will
continue until no more nodes can be infected in this manner.

Suppose `M(initial)` is the final number of nodes infected with malware in the
entire network, after the spread of malware stops.

We will remove one node from the initial list, **completely removing it and
any connections from this node to any other node**.   Return the node that if
removed, would minimize `M(initial)`.  If multiple nodes could be removed to
minimize `M(initial)`, return such a node with the smallest index.



**Example 1:**

    
    
    **Input:** graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
    **Output:** 0
    

**Example 2:**

    
    
    **Input:** graph = [[1,1,0],[1,1,1],[0,1,1]], initial = [0,1]
    **Output:** 1
    

**Example 3:**

    
    
    **Input:** graph = [[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]], initial = [0,1]
    **Output:** 1
    



**Note:**

  1. `1 < graph.length = graph[0].length <= 300`
  2. `0 <= graph[i][j] == graph[j][i] <= 1`
  3. `graph[i][i] = 1`
  4. `1 <= initial.length < graph.length`
  5. `0 <= initial[i] < graph.length`










## 965 - Unique Email Addresses
~1~  ['String']
Every email consists of a local name and a domain name, separated by the @
sign.

For example, in `alice@leetcode.com`, `alice` is the local name, and
`leetcode.com` is the domain name.

Besides lowercase letters, these emails may contain `'.'`s or `'+'`s.

If you add periods (`'.'`) between some characters in the **local name** part
of an email address, mail sent there will be forwarded to the same address
without dots in the local name.   For example, `"alice.z@leetcode.com"` and
`"alicez@leetcode.com"` forward to the same email address.  (Note that this
rule does not apply for domain names.)

If you add a plus (`'+'`) in the **local name** , everything after the first
plus sign will be  **ignored**. This allows certain emails to be filtered, for
example  `m.y+name@email.com` will be forwarded to `my@email.com`.  (Again,
this rule does not apply for domain names.)

It is possible to use both of these rules at the same time.

Given a list of `emails`, we send one email to each address in the list.  How
many different addresses actually receive mails?



**Example 1:**

    
    
    **Input:** ["test.email+alex@leetcode.com","test.e.mail+bob.cathy@leetcode.com","testemail+david@lee.tcode.com"]
    **Output:** 2
    **Explanation:**  "testemail@leetcode.com" and "testemail@lee.tcode.com" actually receive mails
    



**Note:**

  * `1 <= emails[i].length <= 100`
  * `1 <= emails.length <= 100`
  * Each `emails[i]` contains exactly one `'@'` character.










## 966 - Binary Subarrays With Sum
~2~  ['Hash Table', 'Two Pointers']
In an array `A` of `0`s and `1`s, how many **non-empty** subarrays have sum
`S`?



**Example 1:**

    
    
    **Input:** A = [1,0,1,0,1], S = 2
    **Output:** 4
    **Explanation:**
    The 4 subarrays are bolded below:
    [ **1,0,1** ,0,1]
    [ **1,0,1,0** ,1]
    [1, **0,1,0,1** ]
    [1,0, **1,0,1** ]
    



**Note:**

  1. `A.length <= 30000`
  2. `0 <= S <= A.length`
  3. `A[i]` is either `0` or `1`.










## 967 - Minimum Falling Path Sum
~2~  ['Dynamic Programming']
Given a **square** array of integers `A`, we want the **minimum** sum of a
_falling path_ through `A`.

A falling path starts at any element in the first row, and chooses one element
from each row.  The next row's choice must be in a column that is different
from the previous row's column by at most one.



**Example 1:**

    
    
    **Input:** [[1,2,3],[4,5,6],[7,8,9]]
    **Output:** 12
    **Explanation:**
    The possible falling paths are:
    

  * `[1,4,7], [1,4,8], [1,5,7], [1,5,8], [1,5,9]`
  * `[2,4,7], [2,4,8], [2,5,7], [2,5,8], [2,5,9], [2,6,8], [2,6,9]`
  * `[3,5,7], [3,5,8], [3,5,9], [3,6,8], [3,6,9]`

The falling path with the smallest sum is `[1,4,7]`, so the answer is `12`.



**Note:**

  1. `1 <= A.length == A[0].length <= 100`
  2. `-100 <= A[i][j] <= 100`










## 968 - Beautiful Array
~2~  ['Divide and Conquer']
For some fixed `N`, an array `A` is _beautiful_ if it is a permutation of the
integers `1, 2, ..., N`, such that:

For every `i < j`, there is **no**  `k` with `i < k < j` such that `A[k] * 2 =
A[i] + A[j]`.

Given `N`, return **any** beautiful array `A`.  (It is guaranteed that one
exists.)



**Example 1:**

    
    
    **Input:** 4
    **Output:** [2,1,4,3]
    

**Example 2:**

    
    
    **Input:** 5
    **Output:** [3,1,2,5,4]



**Note:**

  * `1 <= N <= 1000`










## 969 - Number of Recent Calls
~1~  ['Queue']
Write a class `RecentCounter` to count recent requests.

It has only one method: `ping(int t)`, where t represents some time in
milliseconds.

Return the number of `ping`s that have been made from 3000 milliseconds ago
until now.

Any ping with time in `[t - 3000, t]` will count, including the current ping.

It is guaranteed that every call to `ping` uses a strictly larger value of `t`
than before.



**Example 1:**

    
    
    **Input:** inputs = ["RecentCounter","ping","ping","ping","ping"], inputs = [[],[1],[100],[3001],[3002]]
    **Output:** [null,1,2,3,3]



**Note:**

  1. Each test case will have at most `10000` calls to `ping`.
  2. Each test case will call `ping` with strictly increasing values of `t`.
  3. Each call to ping will have `1 <= t <= 10^9`.










## 971 - Shortest Bridge
~2~  ['Depth-first Search', 'Breadth-first Search']
In a given 2D binary array `A`, there are two islands.  (An island is a
4-directionally connected group of `1`s not connected to any other 1s.)

Now, we may change `0`s to `1`s so as to connect the two islands together to
form 1 island.

Return the smallest number of `0`s that must be flipped.  (It is guaranteed
that the answer is at least 1.)



**Example 1:**

    
    
    **Input:** [[0,1],[1,0]]
    **Output:** 1
    

**Example 2:**

    
    
    **Input:** [[0,1,0],[0,0,0],[0,0,1]]
    **Output:** 2
    

**Example 3:**

    
    
    **Input:** [[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]
    **Output:** 1



**Note:**

  1. `1 <= A.length = A[0].length <= 100`
  2. `A[i][j] == 0` or `A[i][j] == 1`










## 972 - Knight Dialer
~2~  ['Dynamic Programming']
A chess knight can move as indicated in the chess diagram below:

![](https://assets.leetcode.com/uploads/2018/10/12/knight.png) .
![](https://assets.leetcode.com/uploads/2018/10/30/keypad.png)



This time, we place our chess knight on any numbered key of a phone pad
(indicated above), and the knight makes `N-1` hops.  Each hop must be from one
key to another numbered key.

Each time it lands on a key (including the initial placement of the knight),
it presses the number of that key, pressing `N` digits total.

How many distinct numbers can you dial in this manner?

Since the answer may be large, **output the answer  modulo `10^9 + 7`**.



**Example 1:**

    
    
    **Input:** 1
    **Output:** 10
    

**Example 2:**

    
    
    **Input:** 2
    **Output:** 20
    

**Example 3:**

    
    
    **Input:** 3
    **Output:** 46
    



**Note:**

  * `1 <= N <= 5000`










## 973 - Stamping The Sequence
~3~  ['String', 'Greedy']
You want to form a `target` string of **lowercase letters**.

At the beginning, your sequence is `target.length` `'?'` marks.  You also have
a `stamp` of lowercase letters.

On each turn, you may place the stamp over the sequence, and replace every
letter in the sequence with the corresponding letter from the stamp.  You can
make up to `10 * target.length` turns.

For example, if the initial sequence is "?????", and your stamp is `"abc"`,
then you may make "abc??", "?abc?", "??abc" in the first turn.  (Note that the
stamp must be fully contained in the boundaries of the sequence in order to
stamp.)

If the sequence is possible to stamp, then return an array of the index of the
left-most letter being stamped at each turn.  If the sequence is not possible
to stamp, return an empty array.

For example, if the sequence is "ababc", and the stamp is `"abc"`, then we
could return the answer `[0, 2]`, corresponding to the moves "?????" ->
"abc??" -> "ababc".

Also, if the sequence is possible to stamp, it is guaranteed it is possible to
stamp within `10 * target.length` moves.  Any answers specifying more than
this number of moves will not be accepted.



**Example 1:**

    
    
    **Input:** stamp = "abc", target = "ababc"
    **Output:** [0,2]
    ([1,0,2] would also be accepted as an answer, as well as some other answers.)
    

**Example 2:**

    
    
    **Input:** stamp = "abca", target = "aabcaca"
    **Output:** [3,0,1]
    



**Note:**

  1. `1 <= stamp.length <= target.length <= 1000`
  2. `stamp` and `target` only contain lowercase letters.










## 974 - Reorder Log Files
~1~  ['String']
You have an array of `logs`.  Each log is a space delimited string of words.

For each log, the first word in each log is an alphanumeric _identifier_.
Then, either:

  * Each word after the identifier will consist only of lowercase letters, or;
  * Each word after the identifier will consist only of digits.

We will call these two varieties of logs _letter-logs_ and _digit-logs_.   It
is guaranteed that each log has at least one word after its identifier.

Reorder the logs so that all of the letter-logs come before any digit-log.
The letter-logs are ordered lexicographically ignoring identifier, with the
identifier used in case of ties.  The digit-logs should be put in their
original order.

Return the final order of the logs.



**Example 1:**

    
    
    **Input:** ["a1 9 2 3 1","g1 act car","zo4 4 7","ab1 off key dog","a8 act zoo"]
    **Output:** ["g1 act car","a8 act zoo","ab1 off key dog","a1 9 2 3 1","zo4 4 7"]
    



**Note:**

  1. `0 <= logs.length <= 100`
  2. `3 <= logs[i].length <= 100`
  3. `logs[i]` is guaranteed to have an identifier, and a word after the identifier.










## 975 - Range Sum of BST
~2~  ['Binary Search Tree']
Given the `root` node of a binary search tree, return the sum of values of all
nodes with value between `L` and `R` (inclusive).

The binary search tree is guaranteed to have unique values.



**Example 1:**

    
    
    **Input:** root = [10,5,15,3,7,null,18], L = 7, R = 15
    **Output:** 32
    

**Example 2:**

    
    
    **Input:** root = [10,5,15,3,7,13,18,1,null,6], L = 6, R = 10
    **Output:** 23
    



**Note:**

  1. The number of nodes in the tree is at most `10000`.
  2. The final answer is guaranteed to be less than `2^31`.










## 976 - Minimum Area Rectangle
~2~  ['Hash Table']
Given a set of points in the xy-plane, determine the minimum area of a
rectangle formed from these points, with sides parallel to the x and y axes.

If there isn't any rectangle, return 0.



**Example 1:**

    
    
    **Input:** [[1,1],[1,3],[3,1],[3,3],[2,2]]
    **Output:** 4
    

**Example 2:**

    
    
    **Input:** [[1,1],[1,3],[3,1],[3,3],[4,1],[4,3]]
    **Output:** 2
    



**Note** :

  1. `1 <= points.length <= 500`
  2. `0 <= points[i][0] <= 40000`
  3. `0 <= points[i][1] <= 40000`
  4. All points are distinct.










## 977 - Distinct Subsequences II
~3~  ['Dynamic Programming']
Given a string `S`, count the number of distinct, non-empty subsequences of
`S` .

Since the result may be large, **return the answer modulo`10^9 + 7`**.



**Example 1:**

    
    
    **Input:** "abc"
    **Output:** 7
    **Explanation** : The 7 distinct subsequences are "a", "b", "c", "ab", "ac", "bc", and "abc".
    

**Example 2:**

    
    
    **Input:** "aba"
    **Output:** 6
    **Explanation** : The 6 distinct subsequences are "a", "b", "ab", "ba", "aa" and "aba".
    

**Example 3:**

    
    
    **Input:** "aaa"
    **Output:** 3
    **Explanation** : The 3 distinct subsequences are "a", "aa" and "aaa".
    





**Note:**

  1. `S` contains only lowercase letters.
  2. `1 <= S.length <= 2000`










## 978 - Valid Mountain Array
~1~  ['Array']
Given an array `A` of integers, return `true` if and only if it is a _valid
mountain array_.

Recall that A is a mountain array if and only if:

  * `A.length >= 3`
  * There exists some `i` with `0 < i < A.length - 1` such that: 
    * `A[0] < A[1] < ... A[i-1] < A[i] `
    * `A[i] > A[i+1] > ... > A[B.length - 1]`



**Example 1:**

    
    
    **Input:** [2,1]
    **Output:** false
    

**Example 2:**

    
    
    **Input:** [3,5,5]
    **Output:** false
    

**Example 3:**

    
    
    **Input:** [0,3,2,1]
    **Output:** true



**Note:**

  1. `0 <= A.length <= 10000`
  2. `0 <= A[i] <= 10000 `










## 979 - DI String Match
~1~  ['Math']
Given a string `S` that **only** contains  "I" (increase) or "D" (decrease),
let `N = S.length`.

Return **any** permutation `A` of `[0, 1, ..., N]` such that for all `i = 0,
..., N-1`:

  * If `S[i] == "I"`, then `A[i] < A[i+1]`
  * If `S[i] == "D"`, then `A[i] > A[i+1]`



**Example 1:**

    
    
    **Input:** "IDID"
    **Output:** [0,4,1,3,2]
    

**Example 2:**

    
    
    **Input:** "III"
    **Output:** [0,1,2,3]
    

**Example 3:**

    
    
    **Input:** "DDI"
    **Output:** [3,2,0,1]



**Note:**

  1. `1 <= S.length <= 10000`
  2. `S` only contains characters `"I"` or `"D"`.










## 980 - Find the Shortest Superstring
~3~  ['Dynamic Programming']
Given an array A of strings, find any smallest string that contains each
string in `A` as a substring.

We may assume that no string in `A` is substring of another string in `A`.



**Example 1:**

    
    
    **Input:** ["alex","loves","leetcode"]
    **Output:** "alexlovesleetcode"
    **Explanation:** All permutations of "alex","loves","leetcode" would also be accepted.
    

**Example 2:**

    
    
    **Input:** ["catg","ctaagt","gcta","ttca","atgcatc"]
    **Output:** "gctaagttcatgcatc"



**Note:**

  1. `1 <= A.length <= 12`
  2. `1 <= A[i].length <= 20`










## 981 - Delete Columns to Make Sorted
~1~  ['Greedy']
We are given an array `A` of `N` lowercase letter strings, all of the same
length.

Now, we may choose any set of deletion indices, and for each string, we delete
all the characters in those indices.

For example, if we have an array `A = ["``abcdef``","uvwxyz"]` and deletion
indices `{0, 2, 3}`, then the final array after deletions is `["bef", "vyz"]`,
and the remaining columns of `A` are `["b"``,"``v"]`, `["e","y"]`, and
`["f","z"]`.  (Formally, the `c`-th column is `[A[0][c], A[1][c], ...,
A[A.length-1][c]]`.)

Suppose we chose a set of deletion indices `D` such that after deletions, each
remaining column in A is in **non-decreasing** sorted order.

Return the minimum possible value of `D.length`.



**Example 1:**

    
    
    **Input:** ["cba","daf","ghi"]
    **Output:** 1
    **Explanation:**
    After choosing D = {1}, each column [ "c","d","g"] and ["a","f","i"] are in non-decreasing sorted order.
    If we chose D = {}, then a column ["b","a","h"] would not be in non-decreasing sorted order.
    

**Example 2:**

    
    
    **Input:** ["a","b"]
    **Output:** 0
    **Explanation:** D = {}
    

**Example 3:**

    
    
    **Input:** ["zyx","wvu","tsr"]
    **Output:** 3
    **Explanation:** D = {0, 1, 2}
    



**Note:**

  1. `1 <= A.length <= 100`
  2. `1 <= A[i].length <= 1000`










## 982 - Minimum Increment to Make Array Unique
~2~  ['Array']
Given an array of integers A, a _move_ consists of choosing any `A[i]`, and
incrementing it by `1`.

Return the least number of moves to make every value in `A` unique.



**Example 1:**

    
    
    **Input:** [1,2,2]
    **Output:** 1
    **Explanation:** After 1 move, the array could be [1, 2, 3].
    

**Example 2:**

    
    
    **Input:** [3,2,1,2,1,7]
    **Output:** 6
    **Explanation:** After 6 moves, the array could be [3, 4, 1, 2, 5, 7].
    It can be shown with 5 or less moves that it is impossible for the array to have all unique values.
    



**Note:**

  1. `0 <= A.length <= 40000`
  2. `0 <= A[i] < 40000`










## 983 - Validate Stack Sequences
~2~  ['Stack']
Given two sequences `pushed` and `popped`  **with distinct values** , return
`true` if and only if this could have been the result of a sequence of push
and pop operations on an initially empty stack.



**Example 1:**

    
    
    **Input:** pushed = [1,2,3,4,5], popped = [4,5,3,2,1]
    **Output:** true
    **Explanation:** We might do the following sequence:
    push(1), push(2), push(3), push(4), pop() -> 4,
    push(5), pop() -> 5, pop() -> 3, pop() -> 2, pop() -> 1
    

**Example 2:**

    
    
    **Input:** pushed = [1,2,3,4,5], popped = [4,3,5,1,2]
    **Output:** false
    **Explanation:** 1 cannot be popped before 2.
    



**Note:**

  1. `0 <= pushed.length == popped.length <= 1000`
  2. `0 <= pushed[i], popped[i] < 1000`
  3. `pushed` is a permutation of `popped`.
  4. `pushed` and `popped` have distinct values.










## 984 - Most Stones Removed with Same Row or Column
~2~  ['Depth-first Search', 'Union Find']
On a 2D plane, we place stones at some integer coordinate points.  Each
coordinate point may have at most one stone.

Now, a _move_ consists of removing a stone  that shares a column or row with
another stone on the grid.

What is the largest possible number of moves we can make?



**Example 1:**

    
    
    **Input:** stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]
    **Output:** 5
    

**Example 2:**

    
    
    **Input:** stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]
    **Output:** 3
    

**Example 3:**

    
    
    **Input:** stones = [[0,0]]
    **Output:** 0
    



**Note:**

  1. `1 <= stones.length <= 1000`
  2. `0 <= stones[i][j] < 10000`










## 985 - Bag of Tokens
~2~  ['Greedy']
You have an initial power `P`, an initial score of `0` points, and a bag of
tokens.

Each token can be used at most once, has a value `token[i]`, and has
potentially two ways to use it.

  * If we have at least `token[i]` power, we may play the token face up, losing `token[i]` power, and gaining `1` point.
  * If we have at least `1` point, we may play the token face down, gaining `token[i]` power, and losing `1` point.

Return the largest number of points we can have after playing any number of
tokens.



**Example 1:**

    
    
    **Input:** tokens = [100], P = 50
    **Output:** 0
    

**Example 2:**

    
    
    **Input:** tokens = [100,200], P = 150
    **Output:** 1
    

**Example 3:**

    
    
    **Input:** tokens = [100,200,300,400], P = 200
    **Output:** 2
    



**Note:**

  1. `tokens.length <= 1000`
  2. `0 <= tokens[i] < 10000`
  3. `0 <= P < 10000`










## 986 - Largest Time for Given Digits
~1~  ['Math']
Given an array of 4 digits, return the largest 24 hour time that can be made.

The smallest 24 hour time is 00:00, and the largest is 23:59.  Starting from
00:00, a time is larger if more time has elapsed since midnight.

Return the answer as a string of length 5.  If no valid time can be made,
return an empty string.



**Example 1:**

    
    
    **Input:** [1,2,3,4]
    **Output:** "23:41"
    

**Example 2:**

    
    
    **Input:** [5,5,5,5]
    **Output:** ""
    



**Note:**

  1. `A.length == 4`
  2. `0 <= A[i] <= 9`










## 987 - Reveal Cards In Increasing Order
~2~  ['Array']
In a deck of cards, every card has a unique integer.  You can order the deck
in any order you want.

Initially, all the cards start face down (unrevealed) in one deck.

Now, you do the following steps repeatedly, until all cards are revealed:

  1. Take the top card of the deck, reveal it, and take it out of the deck.
  2. If there are still cards in the deck, put the next top card of the deck at the bottom of the deck.
  3. If there are still unrevealed cards, go back to step 1.  Otherwise, stop.

Return an ordering of the deck that would reveal the cards in **increasing
order.**

The first entry in the answer is considered to be the top of the deck.



**Example 1:**

    
    
    **Input:** [17,13,11,2,3,5,7]
    **Output:** [2,13,3,11,5,17,7]
    **Explanation:**
    We get the deck in the order [17,13,11,2,3,5,7] (this order doesn't matter), and reorder it.
    After reordering, the deck starts as [2,13,3,11,5,17,7], where 2 is the top of the deck.
    We reveal 2, and move 13 to the bottom.  The deck is now [3,11,5,17,7,13].
    We reveal 3, and move 11 to the bottom.  The deck is now [5,17,7,13,11].
    We reveal 5, and move 17 to the bottom.  The deck is now [7,13,11,17].
    We reveal 7, and move 13 to the bottom.  The deck is now [11,17,13].
    We reveal 11, and move 17 to the bottom.  The deck is now [13,17].
    We reveal 13, and move 17 to the bottom.  The deck is now [17].
    We reveal 17.
    Since all the cards revealed are in increasing order, the answer is correct.
    



**Note:**

  1. `1 <= A.length <= 1000`
  2. `1 <= A[i] <= 10^6`
  3. `A[i] != A[j]` for all `i != j`










## 988 - Flip Equivalent Binary Trees
~2~  ['Tree']
For a binary tree T, we can define a flip operation as follows: choose any
node, and swap the left and right child subtrees.

A binary tree X is _flip equivalent_ to a binary tree Y if and only if we can
make X equal to Y after some number of flip operations.

Write a function that determines whether two binary trees are _flip
equivalent_.   The trees are given by root nodes `root1` and `root2`.



**Example 1:**

    
    
    **Input:** root1 = [1,2,3,4,5,6,null,null,null,7,8], root2 = [1,3,2,null,6,4,5,null,null,null,null,8,7]
    **Output:** true
    **Explanation:** We flipped at nodes with values 1, 3, and 5.
    ![Flipped Trees Diagram](https://assets.leetcode.com/uploads/2018/11/29/tree_ex.png)
    



**Note:**

  1. Each tree will have at most `100` nodes.
  2. Each value in each tree will be a unique integer in the range `[0, 99]`.










## 989 - Largest Component Size by Common Factor
~3~  ['Math', 'Union Find']
Given a non-empty array of unique positive integers `A`, consider the
following graph:

  * There are `A.length` nodes, labelled `A[0]` to `A[A.length - 1];`
  * There is an edge between `A[i]` and `A[j]` if and only if `A[i]` and `A[j]` share a common factor greater than 1.

Return the size of the largest connected component in the graph.



**Example 1:**

    
    
    **Input:** [4,6,15,35]
    **Output:** 4
    ![](https://assets.leetcode.com/uploads/2018/12/01/ex1.png)
    

**Example 2:**

    
    
    **Input:** [20,50,9,63]
    **Output:** 2
    ![](https://assets.leetcode.com/uploads/2018/12/01/ex2.png)
    

**Example 3:**

    
    
    **Input:** [2,3,6,7,4,12,21,39]
    **Output:** 8
    ![](https://assets.leetcode.com/uploads/2018/12/01/ex3.png)
    

**Note:**

  1. `1 <= A.length <= 20000`
  2. `1 <= A[i] <= 100000`










## 990 - Verifying an Alien Dictionary
~1~  ['Hash Table']
In an alien language, surprisingly they also use english lowercase letters,
but possibly in a different `order`. The `order` of the alphabet is some
permutation of lowercase letters.

Given a sequence of `words` written in the alien language, and the `order` of
the alphabet, return `true` if and only if the given `words` are sorted
lexicographicaly in this alien language.



**Example 1:**

    
    
    **Input:** words = ["hello","leetcode"], order = "hlabcdefgijkmnopqrstuvwxyz"
    **Output:** true
    **Explanation:** As 'h' comes before 'l' in this language, then the sequence is sorted.
    

**Example 2:**

    
    
    **Input:** words = ["word","world","row"], order = "worldabcefghijkmnpqstuvxyz"
    **Output:** false
    **Explanation:** As 'd' comes after 'l' in this language, then words[0] > words[1], hence the sequence is unsorted.
    

**Example 3:**

    
    
    **Input:** words = ["apple","app"], order = "abcdefghijklmnopqrstuvwxyz"
    **Output:** false
    **Explanation:** The first three characters "app" match, and the second string is shorter (in size.) According to lexicographical rules "apple" > "app", because 'l' > '∅', where '∅' is defined as the blank character which is less than any other character ([More info](https://en.wikipedia.org/wiki/Lexicographical_order)).
    



**Note:**

  1. `1 <= words.length <= 100`
  2. `1 <= words[i].length <= 20`
  3. `order.length == 26`
  4. All characters in `words[i]` and `order` are english lowercase letters.










## 991 - Array of Doubled Pairs
~2~  ['Array', 'Hash Table']
Given an array of integers `A` with even length, return `true` if and only if
it is possible to reorder it such that `A[2 * i + 1] = 2 * A[2 * i]` for every
`0 <= i < len(A) / 2`.



**Example 1:**

    
    
    **Input:** [3,1,3,6]
    **Output:** false
    

**Example 2:**

    
    
    **Input:** [2,1,2,6]
    **Output:** false
    

**Example 3:**

    
    
    **Input:** [4,-2,2,-4]
    **Output:** true
    **Explanation:** We can take two groups, [-2,-4] and [2,4] to form [-2,-4,2,4] or [2,4,-2,-4].
    

**Example 4:**

    
    
    **Input:** [1,2,4,16,8,4]
    **Output:** false
    



**Note:**

  1. `0 <= A.length <= 30000`
  2. `A.length` is even
  3. `-100000 <= A[i] <= 100000`










## 992 - Delete Columns to Make Sorted II
~2~  ['Greedy']
We are given an array `A` of `N` lowercase letter strings, all of the same
length.

Now, we may choose any set of deletion indices, and for each string, we delete
all the characters in those indices.

For example, if we have an array `A = ["abcdef","uvwxyz"]` and deletion
indices `{0, 2, 3}`, then the final array after deletions is `["bef","vyz"]`.

Suppose we chose a set of deletion indices `D` such that after deletions, the
final array has its elements in **lexicographic** order (`A[0] <= A[1] <= A[2]
... <= A[A.length - 1]`).

Return the minimum possible value of `D.length`.



**Example 1:**

    
    
    **Input:** ["ca","bb","ac"]
    **Output:** 1
    **Explanation:**
    After deleting the first column, A = [ "a", "b", "c"].
    Now A is in lexicographic order (ie. A[0] <= A[1] <= A[2]).
    We require at least 1 deletion since initially A was not in lexicographic order, so the answer is 1.
    

**Example 2:**

    
    
    **Input:** ["xc","yb","za"]
    **Output:** 0
    **Explanation:**
    A is already in lexicographic order, so we don 't need to delete anything.
    Note that the rows of A are not necessarily in lexicographic order:
    ie. it is NOT necessarily true that (A[0][0] <= A[0][1] <= ...)
    

**Example 3:**

    
    
    **Input:** ["zyx","wvu","tsr"]
    **Output:** 3
    **Explanation:**
    We have to delete every column.
    



**Note:**

  1. `1 <= A.length <= 100`
  2. `1 <= A[i].length <= 100`










## 993 - Tallest Billboard
~3~  ['Dynamic Programming']
You are installing a billboard and want it to have the largest height.  The
billboard will have two steel supports, one on each side.  Each steel support
must be an equal height.

You have a collection of `rods` which can be welded together.  For example, if
you have rods of lengths 1, 2, and 3, you can weld them together to make a
support of length 6.

Return the largest possible height of your billboard installation.  If you
cannot support the billboard, return 0.



**Example 1:**

    
    
    **Input:** [1,2,3,6]
    **Output:** 6
    **Explanation:** We have two disjoint subsets {1,2,3} and {6}, which have the same sum = 6.
    

**Example 2:**

    
    
    **Input:** [1,2,3,4,5,6]
    **Output:** 10
    **Explanation:** We have two disjoint subsets {2,3,5} and {4,6}, which have the same sum = 10.
    

**Example 3:**

    
    
    **Input:** [1,2]
    **Output:** 0
    **Explanation:** The billboard cannot be supported, so we return 0.
    



**Note:**

  1. `0 <= rods.length <= 20`
  2. `1 <= rods[i] <= 1000`
  3. `The sum of rods is at most 5000.`










## 994 - Prison Cells After N Days
~2~  ['Hash Table']
There are 8 prison cells in a row, and each cell is either occupied or vacant.

Each day, whether the cell is occupied or vacant changes according to the
following rules:

  * If a cell has two adjacent neighbors that are both occupied or both vacant, then the cell becomes occupied.
  * Otherwise, it becomes vacant.

(Note that because the prison is a row, the first and the last cells in the
row can't have two adjacent neighbors.)

We describe the current state of the prison in the following way: `cells[i] ==
1` if the `i`-th cell is occupied, else `cells[i] == 0`.

Given the initial state of the prison, return the state of the prison after
`N` days (and `N` such changes described above.)



**Example 1:**

    
    
    **Input:** cells = [0,1,0,1,1,0,0,1], N = 7
    **Output:** [0,0,1,1,0,0,0,0]
    **Explanation:** The following table summarizes the state of the prison on each day:
    Day 0: [0, 1, 0, 1, 1, 0, 0, 1]
    Day 1: [0, 1, 1, 0, 0, 0, 0, 0]
    Day 2: [0, 0, 0, 0, 1, 1, 1, 0]
    Day 3: [0, 1, 1, 0, 0, 1, 0, 0]
    Day 4: [0, 0, 0, 0, 0, 1, 0, 0]
    Day 5: [0, 1, 1, 1, 0, 1, 0, 0]
    Day 6: [0, 0, 1, 0, 1, 1, 0, 0]
    Day 7: [0, 0, 1, 1, 0, 0, 0, 0]
    
    

**Example 2:**

    
    
    **Input:** cells = [1,0,0,1,0,0,1,0], N = 1000000000
    **Output:** [0,0,1,1,1,1,1,0]
    



**Note:**

  1. `cells.length == 8`
  2. `cells[i]` is in `{0, 1}`
  3. `1 <= N <= 10^9`










## 998 - Check Completeness of a Binary Tree
~2~  ['Tree']
Given a binary tree, determine if it is a _complete binary tree_.

_**Definition of a complete binary tree
from[Wikipedia](http://en.wikipedia.org/wiki/Binary_tree#Types_of_binary_trees):**_  
In a complete binary tree every level, except possibly the last, is completely
filled, and all nodes in the last level are as far left as possible. It can
have between 1 and 2 h nodes inclusive at the last level h.



**Example 1:**

**![](https://assets.leetcode.com/uploads/2018/12/15/complete-binary-
tree-1.png)**

    
    
    **Input:** [1,2,3,4,5,6]
    **Output:** true
    **Explanation:** Every level before the last is full (ie. levels with node-values {1} and {2, 3}), and all nodes in the last level ({4, 5, 6}) are as far left as possible.
    

**Example 2:**

**![](https://assets.leetcode.com/uploads/2018/12/15/complete-binary-
tree-2.png)**

    
    
    **Input:** [1,2,3,4,5,null,7]
    **Output:** false
    **Explanation:** The node with value 7 isn't as far left as possible.
    



**Note:**

  1. The tree will have between 1 and 100 nodes.










## 999 - Regions Cut By Slashes
~2~  ['Depth-first Search', 'Union Find', 'Graph']
In a N x N `grid` composed of 1 x 1 squares, each 1 x 1 square consists of a
`/`, `\`, or blank space.  These characters divide the square into contiguous
regions.

(Note that backslash characters are escaped, so a `\` is represented as
`"\\"`.)

Return the number of regions.



**Example 1:**

    
    
    **Input:** [
      " /",
      "/ "
    ]
    **Output:** 2
    **Explanation:** The 2x2 grid is as follows:
    ![](https://assets.leetcode.com/uploads/2018/12/15/1.png)
    

**Example 2:**

    
    
    **Input:** [
      " /",
      "  "
    ]
    **Output:** 1
    **Explanation:** The 2x2 grid is as follows:
    ![](https://assets.leetcode.com/uploads/2018/12/15/2.png)
    

**Example 3:**

    
    
    **Input:** [
      "\\/",
      "/\\"
    ]
    **Output:** 4
    **Explanation:** (Recall that because \ characters are escaped, "\\/" refers to \/, and "/\\" refers to /\.)
    The 2x2 grid is as follows:
    ![](https://assets.leetcode.com/uploads/2018/12/15/3.png)
    

**Example 4:**

    
    
    **Input:** [
      "/\\",
      "\\/"
    ]
    **Output:** 5
    **Explanation:** (Recall that because \ characters are escaped, "/\\" refers to /\, and "\\/" refers to \/.)
    The 2x2 grid is as follows:
    ![](https://assets.leetcode.com/uploads/2018/12/15/4.png)
    

**Example 5:**

    
    
    **Input:** [
      "//",
      "/ "
    ]
    **Output:** 3
    **Explanation:** The 2x2 grid is as follows:
    ![](https://assets.leetcode.com/uploads/2018/12/15/5.png)
    



**Note:**

  1. `1 <= grid.length == grid[0].length <= 30`
  2. `grid[i][j]` is either `'/'`, `'\'`, or `' '`.










## 1000 - Delete Columns to Make Sorted III
~3~  ['Dynamic Programming']
We are given an array `A` of `N` lowercase letter strings, all of the same
length.

Now, we may choose any set of deletion indices, and for each string, we delete
all the characters in those indices.

For example, if we have an array `A = ["babca","bbazb"]` and deletion indices
`{0, 1, 4}`, then the final array after deletions is `["bc","az"]`.

Suppose we chose a set of deletion indices `D` such that after deletions, the
final array has **every element (row) in  lexicographic** order.

For clarity, `A[0]` is in lexicographic order (ie. `A[0][0] <= A[0][1] <= ...
<= A[0][A[0].length - 1]`), `A[1]` is in lexicographic order (ie. `A[1][0] <=
A[1][1] <= ... <= A[1][A[1].length - 1]`), and so on.

Return the minimum possible value of `D.length`.



**Example 1:**

    
    
    **Input:** ["babca","bbazb"]
    **Output:** 3
    **Explanation:** After deleting columns 0, 1, and 4, the final array is A = ["bc", "az"].
    Both these rows are individually in lexicographic order (ie. A[0][0] <= A[0][1] and A[1][0] <= A[1][1]).
    Note that A[0] > A[1] - the array A isn't necessarily in lexicographic order.
    

**Example 2:**

    
    
    **Input:** ["edcba"]
    **Output:** 4
    **Explanation:** If we delete less than 4 columns, the only row won't be lexicographically sorted.
    

**Example 3:**

    
    
    **Input:** ["ghi","def","abc"]
    **Output:** 0
    **Explanation:** All rows are already lexicographically sorted.
    



**Note:**

  1. `1 <= A.length <= 100`
  2. `1 <= A[i].length <= 100`










## 1001 - N-Repeated Element in Size 2N Array
~1~  ['Hash Table']
In a array `A` of size `2N`, there are `N+1` unique elements, and exactly one
of these elements is repeated N times.

Return the element repeated `N` times.



**Example 1:**

    
    
    **Input:** [1,2,3,3]
    **Output:** 3
    

**Example 2:**

    
    
    **Input:** [2,1,2,5,3,2]
    **Output:** 2
    

**Example 3:**

    
    
    **Input:** [5,1,5,2,5,3,5,4]
    **Output:** 5
    



**Note:**

  1. `4 <= A.length <= 10000`
  2. `0 <= A[i] < 10000`
  3. `A.length` is even










## 1002 - Maximum Width Ramp
~2~  ['Array']
Given an array `A` of integers, a _ramp_  is a tuple `(i, j)` for which `i <
j` and `A[i] <= A[j]`.  The width of such a ramp is `j - i`.

Find the maximum width of a ramp in `A`.  If one doesn't exist, return 0.



**Example 1:**

    
    
    **Input:** [6,0,8,2,1,5]
    **Output:** 4
    **Explanation:**
    The maximum width ramp is achieved at (i, j) = (1, 5): A[1] = 0 and A[5] = 5.
    

**Example 2:**

    
    
    **Input:** [9,8,1,0,1,9,4,0,4,1]
    **Output:** 7
    **Explanation:**
    The maximum width ramp is achieved at (i, j) = (2, 9): A[2] = 1 and A[9] = 1.
    



**Note:**

  1. `2 <= A.length <= 50000`
  2. `0 <= A[i] <= 50000`










## 1003 - Minimum Area Rectangle II
~2~  ['Math', 'Geometry']
Given a set of points in the xy-plane, determine the minimum area of **any**
rectangle formed from these points, with sides **not necessarily parallel** to
the x and y axes.

If there isn't any rectangle, return 0.



**Example 1:**

![](https://assets.leetcode.com/uploads/2018/12/21/1a.png)

    
    
    **Input:** [[1,2],[2,1],[1,0],[0,1]]
    **Output:** 2.00000
    **Explanation:**  The minimum area rectangle occurs at [1,2],[2,1],[1,0],[0,1], with an area of 2.
    

**Example 2:**

![](https://assets.leetcode.com/uploads/2018/12/22/2.png)

    
    
    **Input:** [[0,1],[2,1],[1,1],[1,0],[2,0]]
    **Output:** 1.00000
    **Explanation:** The minimum area rectangle occurs at [1,0],[1,1],[2,1],[2,0], with an area of 1.
    

**Example 3:**

![](https://assets.leetcode.com/uploads/2018/12/22/3.png)

    
    
    **Input:** [[0,3],[1,2],[3,1],[1,3],[2,1]]
    **Output:** 0
    **Explanation:** There is no possible rectangle to form from these points.
    

**Example 4:**

![](https://assets.leetcode.com/uploads/2018/12/21/4c.png)

    
    
    **Input:** [[3,1],[1,1],[0,1],[2,1],[3,3],[3,2],[0,2],[2,3]]
    **Output:** 2.00000
    **Explanation:** The minimum area rectangle occurs at [2,1],[2,3],[3,3],[3,1], with an area of 2.
    



**Note:**

  1. `1 <= points.length <= 50`
  2. `0 <= points[i][0] <= 40000`
  3. `0 <= points[i][1] <= 40000`
  4. All points are distinct.
  5. Answers within `10^-5` of the actual value will be accepted as correct.










## 1004 - Least Operators to Express Number
~3~  ['Math', 'Dynamic Programming']
Given a single positive integer `x`, we will write an expression of the form
`x (op1) x (op2) x (op3) x ...` where each operator `op1`, `op2`, etc. is
either addition, subtraction, multiplication, or division (`+`, `-`, `*`, or
`/)`.  For example, with `x = 3`, we might write `3 * 3 / 3 + 3 - 3` which is
a value of 3.

When writing such an expression, we adhere to the following conventions:

  1. The division operator (`/`) returns rational numbers.
  2. There are no parentheses placed anywhere.
  3. We use the usual order of operations: multiplication and division happens before addition and subtraction.
  4. It's not allowed to use the unary negation operator (`-`).  For example, "`x - x`" is a valid expression as it only uses subtraction, but "`-x + x`" is not because it uses negation.

We would like to write an expression with the least number of operators such
that the expression equals the given `target`.  Return the least number of
operators used.



**Example 1:**

    
    
    **Input:** x = 3, target = 19
    **Output:** 5
    **Explanation:** 3 * 3 + 3 * 3 + 3 / 3.  The expression contains 5 operations.
    

**Example 2:**

    
    
    **Input:** x = 5, target = 501
    **Output:** 8
    **Explanation:** 5 * 5 * 5 * 5 - 5 * 5 * 5 + 5 / 5.  The expression contains 8 operations.
    

**Example 3:**

    
    
    **Input:** x = 100, target = 100000000
    **Output:** 3
    **Explanation:** 100 * 100 * 100 * 100.  The expression contains 3 operations.



**Note:**

  * `2 <= x <= 100`
  * `1 <= target <= 2 * 10^8`










## 1005 - Univalued Binary Tree
~1~  ['Tree']
A binary tree is _univalued_ if every node in the tree has the same value.

Return `true` if and only if the given tree is univalued.



**Example 1:**

![](https://assets.leetcode.com/uploads/2018/12/28/unival_bst_1.png)

    
    
    **Input:** [1,1,1,1,1,null,1]
    **Output:** true
    

**Example 2:**

![](https://assets.leetcode.com/uploads/2018/12/28/unival_bst_2.png)

    
    
    **Input:** [2,2,2,5,2]
    **Output:** false
    



**Note:**

  1. The number of nodes in the given tree will be in the range `[1, 100]`.
  2. Each node's value will be an integer in the range `[0, 99]`.










## 1006 - Vowel Spellchecker
~2~  ['Hash Table', 'String']
Given a `wordlist`, we want to implement a spellchecker that converts a query
word into a correct word.

For a given `query` word, the spell checker handles two categories of spelling
mistakes:

  * Capitalization: If the query matches a word in the wordlist ( **case-insensitive** ), then the query word is returned with the same case as the case in the wordlist. 
    * Example: `wordlist = ["yellow"]`, `query = "YellOw"`: `correct = "yellow"`
    * Example: `wordlist = ["Yellow"]`, `query = "yellow"`: `correct = "Yellow"`
    * Example: `wordlist = ["yellow"]`, `query = "yellow"`: `correct = "yellow"`
  * Vowel Errors: If after replacing the vowels ('a', 'e', 'i', 'o', 'u') of the query word with any vowel individually, it matches a word in the wordlist ( **case-insensitive** ), then the query word is returned with the same case as the match in the wordlist. 
    * Example: `wordlist = ["YellOw"]`, `query = "yollow"`: `correct = "YellOw"`
    * Example: `wordlist = ["YellOw"]`, `query = "yeellow"`: `correct = ""` (no match)
    * Example: `wordlist = ["YellOw"]`, `query = "yllw"`: `correct = ""` (no match)

In addition, the spell checker operates under the following precedence rules:

  * When the query exactly matches a word in the wordlist ( **case-sensitive** ), you should return the same word back.
  * When the query matches a word up to capitlization, you should return the first such match in the wordlist.
  * When the query matches a word up to vowel errors, you should return the first such match in the wordlist.
  * If the query has no matches in the wordlist, you should return the empty string.

Given some `queries`, return a list of words `answer`, where `answer[i]` is
the correct word for `query = queries[i]`.



**Example 1:**

    
    
    **Input:** wordlist = ["KiTe","kite","hare","Hare"], queries = ["kite","Kite","KiTe","Hare","HARE","Hear","hear","keti","keet","keto"]
    **Output:** ["kite","KiTe","KiTe","Hare","hare","","","KiTe","","KiTe"]



**Note:**

  * `1 <= wordlist.length <= 5000`
  * `1 <= queries.length <= 5000`
  * `1 <= wordlist[i].length <= 7`
  * `1 <= queries[i].length <= 7`
  * All strings in `wordlist` and `queries` consist only of **english**  letters.










## 1007 - Numbers With Same Consecutive Differences
~2~  ['Dynamic Programming']
Return all **non-negative** integers of length `N` such that the absolute
difference between every two consecutive digits is `K`.

Note that **every** number in the answer **must not** have leading zeros
**except** for the number `0` itself. For example, `01` has one leading zero
and is invalid, but `0` is valid.

You may return the answer in any order.



**Example 1:**

    
    
    **Input:** N = 3, K = 7
    **Output:** [181,292,707,818,929]
    **Explanation:** Note that 070 is not a valid number, because it has leading zeroes.
    

**Example 2:**

    
    
    **Input:** N = 2, K = 1
    **Output:** [10,12,21,23,32,34,43,45,54,56,65,67,76,78,87,89,98]



**Note:**

  1. `1 <= N <= 9`
  2. `0 <= K <= 9`










## 1008 - Binary Tree Cameras
~3~  ['Dynamic Programming', 'Tree', 'Depth-first Search']
Given a binary tree, we install cameras on the nodes of the tree.

Each camera at a node can monitor **its parent, itself, and its immediate
children**.

Calculate the minimum number of cameras needed to monitor all nodes of the
tree.



**Example 1:**

![](https://assets.leetcode.com/uploads/2018/12/29/bst_cameras_01.png)

    
    
    **Input:** [0,0,null,0,0]
    **Output:** 1
    **Explanation:** One camera is enough to monitor all nodes if placed as shown.
    

**Example 2:**

![](https://assets.leetcode.com/uploads/2018/12/29/bst_cameras_02.png)

    
    
    **Input:** [0,0,null,0,null,0,null,null,0]
    **Output:** 2
    **Explanation:** At least two cameras are needed to monitor all nodes of the tree. The above image shows one of the valid configurations of camera placement.
    

  
**Note:**

  1. The number of nodes in the given tree will be in the range `[1, 1000]`.
  2. **Every** node has value 0.










## 1009 - Pancake Sorting
~2~  ['Array', 'Sort']
Given an array `A`, we can perform a  _pancake flip_ : We choose some positive
integer ` **k** <= A.length`, then reverse the order of the first **k**
elements of `A`.  We want to perform zero or more pancake flips (doing them
one after another in succession) to sort the array `A`.

Return the k-values corresponding to a sequence of pancake flips that sort
`A`.  Any valid answer that sorts the array within `10 * A.length` flips will
be judged as correct.



**Example 1:**

    
    
    **Input:** [3,2,4,1]
    **Output:** [4,2,4,3]
    **Explanation:**
    We perform 4 pancake flips, with k values 4, 2, 4, and 3.
    Starting state: A = [3, 2, 4, 1]
    After 1st flip (k=4): A = [1, 4, 2, 3]
    After 2nd flip (k=2): A = [4, 1, 2, 3]
    After 3rd flip (k=4): A = [3, 2, 1, 4]
    After 4th flip (k=3): A = [1, 2, 3, 4], which is sorted. 
    

**Example 2:**

    
    
    **Input:** [1,2,3]
    **Output:** []
    **Explanation:** The input is already sorted, so there is no need to flip anything.
    Note that other answers, such as [3, 3], would also be accepted.
    



**Note:**

  1. `1 <= A.length <= 100`
  2. `A[i]` is a permutation of `[1, 2, ..., A.length]`










## 1010 - Powerful Integers
~1~  ['Math']
Given two non-negative integers `x` and `y`, an integer is _powerful_  if it
is equal to `x^i + y^j` for some integers `i >= 0` and `j >= 0`.

Return a list of all _powerful_ integers that have value less than or equal to
`bound`.

You may return the answer in any order.  In your answer, each value should
occur at most once.



**Example 1:**

    
    
    **Input:** x = 2, y = 3, bound = 10
    **Output:** [2,3,4,5,7,9,10]
    **Explanation:**
    2 = 2^0 + 3^0
    3 = 2^1 + 3^0
    4 = 2^0 + 3^1
    5 = 2^1 + 3^1
    7 = 2^2 + 3^1
    9 = 2^3 + 3^0
    10 = 2^0 + 3^2
    

**Example 2:**

    
    
    **Input:** x = 3, y = 5, bound = 15
    **Output:** [2,4,6,8,10,14]
    



**Note:**

  * `1 <= x <= 100`
  * `1 <= y <= 100`
  * `0 <= bound <= 10^6`










## 1011 - Flip Binary Tree To Match Preorder Traversal
~2~  ['Tree', 'Depth-first Search']
Given a binary tree with `N` nodes, each node has a different value from `{1,
..., N}`.

A node in this binary tree can be _flipped_  by swapping the left child and
the right child of that node.

Consider the sequence of `N` values reported by a preorder traversal starting
from the root.  Call such a sequence of `N` values the  _voyage_  of the tree.

(Recall that a _preorder traversal_  of a node means we report the current
node's value, then preorder-traverse the left child, then preorder-traverse
the right child.)

Our goal is to flip the **least number** of nodes in the tree so that the
voyage of the tree matches the `voyage` we are given.

If we can do so, then return a list of the values of all nodes flipped.  You
may return the answer in any order.

If we cannot do so, then return the list `[-1]`.



**Example 1:**

**![](https://assets.leetcode.com/uploads/2019/01/02/1219-01.png)**

    
    
    **Input:** root = [1,2], voyage = [2,1]
    **Output:** [-1]
    

**Example 2:**

**![](https://assets.leetcode.com/uploads/2019/01/02/1219-02.png)**

    
    
    **Input:** root = [1,2,3], voyage = [1,3,2]
    **Output:** [1]
    

**Example 3:**

**![](https://assets.leetcode.com/uploads/2019/01/02/1219-02.png)**

    
    
    **Input:** root = [1,2,3], voyage = [1,2,3]
    **Output:** []
    



**Note:**

  1. `1 <= N <= 100`










## 1012 - Equal Rational Numbers
~3~  ['Math']
Given two strings `S` and `T`, each of which represents a non-negative
rational number, return **True** if and only if they represent the same
number. The strings may use parentheses to denote the repeating part of the
rational number.

In general a rational number can be represented using up to three parts: an
_integer part_ , a  _non-repeating part,_ and a   _repeating part_. The number
will be represented  in one of the following three ways:

  * `<IntegerPart>` (e.g. 0, 12, 123)
  * `<IntegerPart><.><NonRepeatingPart>`  (e.g. 0.5, 1., 2.12, 2.0001)
  * `<IntegerPart><.><NonRepeatingPart><(><RepeatingPart><)>` (e.g. 0.1(6), 0.9(9), 0.00(1212))

The repeating portion of a decimal expansion is conventionally denoted within
a pair of round brackets.  For example:

1 / 6 = 0.16666666... = 0.1(6) = 0.1666(6) = 0.166(66)

Both 0.1(6) or 0.1666(6) or 0.166(66) are correct representations of 1 / 6.



**Example 1:**

    
    
    **Input:** S = "0.(52)", T = "0.5(25)"
    **Output:** true
    **Explanation:** Because "0.(52)" represents 0.52525252..., and "0.5(25)" represents 0.52525252525..... , the strings represent the same number.
    

**Example 2:**

    
    
    **Input:** S = "0.1666(6)", T = "0.166(66)"
    **Output:** true
    

**Example 3:**

    
    
    **Input:** S = "0.9(9)", T = "1."
    **Output:** true
    **Explanation:**
     "0.9(9)" represents 0.999999999... repeated forever, which equals 1.  [[See this link for an explanation.](https://en.wikipedia.org/wiki/0.999...)]
    "1." represents the number 1, which is formed correctly: (IntegerPart) = "1" and (NonRepeatingPart) = "".



**Note:**

  1. Each part consists only of digits.
  2. The `<IntegerPart>` will not begin with 2 or more zeros.  (There is no other restriction on the digits of each part.)
  3. `1 <= <IntegerPart>.length <= 4 `
  4. `0 <= <NonRepeatingPart>.length <= 4 `
  5. `1 <= <RepeatingPart>.length <= 4`










## 1013 - Fibonacci Number
~1~  ['Array']
The  **Fibonacci numbers** , commonly denoted `F(n)` form a sequence, called
the  **Fibonacci sequence** , such that each number is the sum of the two
preceding ones, starting from `0` and `1`. That is,

    
    
    F(0) = 0,   F(1) = 1
    F(N) = F(N - 1) + F(N - 2), for N > 1.
    

Given `N`, calculate `F(N)`.



**Example 1:**

    
    
    **Input:** 2
    **Output:** 1
    **Explanation:** F(2) = F(1) + F(0) = 1 + 0 = 1.
    

**Example 2:**

    
    
    **Input:** 3
    **Output:** 2
    **Explanation:** F(3) = F(2) + F(1) = 1 + 1 = 2.
    

**Example 3:**

    
    
    **Input:** 4
    **Output:** 3
    **Explanation:** F(4) = F(3) + F(2) = 2 + 1 = 3.
    



**Note:**

0 ≤ `N` ≤ 30.










## 1014 - K Closest Points to Origin
~1~  ['Math', 'Divide and Conquer', 'Sort']
We have a list of `points` on the plane.  Find the `K` closest points to the
origin `(0, 0)`.

(Here, the distance between two points on a plane is the Euclidean distance.)

You may return the answer in any order.  The answer is guaranteed to be unique
(except for the order that it is in.)



**Example 1:**

    
    
    **Input:** points = [[1,3],[-2,2]], K = 1
    **Output:** [[-2,2]]
    **Explanation:**
    The distance between (1, 3) and the origin is sqrt(10).
    The distance between (-2, 2) and the origin is sqrt(8).
    Since sqrt(8)  < sqrt(10), (-2, 2) is closer to the origin.
    We only want the closest K = 1 points from the origin, so the answer is just [[-2,2]].
    

**Example 2:**

    
    
    **Input:** points = [[3,3],[5,-1],[-2,4]], K = 2
    **Output:** [[3,3],[-2,4]]
    (The answer [[-2,4],[3,3]] would also be accepted.)
    



**Note:**

  1. `1 <= K <= points.length <= 10000`
  2. `-10000 < points[i][0] < 10000`
  3. `-10000 < points[i][1] < 10000`










## 1016 - Subarray Sums Divisible by K
~2~  ['Array']
Given an array `A` of integers, return the number of (contiguous, non-empty)
subarrays that have a sum divisible by `K`.



**Example 1:**

    
    
    **Input:** A = [4,5,0,-2,-3,1], K = 5
    **Output:** 7
    **Explanation:** There are 7 subarrays with a sum divisible by K = 5:
    [4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]
    



**Note:**

  1. `1 <= A.length <= 30000`
  2. `-10000 <= A[i] <= 10000`
  3. `2 <= K <= 10000`










## 1017 - Odd Even Jump
~3~  ['Dynamic Programming', 'Stack']
You are given an integer array `A`.  From some starting index, you can make a
series of jumps.  The (1st, 3rd, 5th, ...) jumps in the series are called _odd
numbered jumps_ , and the (2nd, 4th, 6th, ...) jumps in the series are called
_even numbered jumps_.

You may from index `i` jump forward to index `j` (with `i < j`) in the
following way:

  * During odd numbered jumps (ie. jumps 1, 3, 5, ...), you jump to the index j such that `A[i] <= A[j]` and `A[j]` is the smallest possible value.  If there are multiple such indexes `j`, you can only jump to the **smallest** such index ` j`.
  * During even numbered jumps (ie. jumps 2, 4, 6, ...), you jump to the index j such that `A[i] >= A[j]` and `A[j]` is the largest possible value.  If there are multiple such indexes `j`, you can only jump to the **smallest** such index ` j`.
  * (It may be the case that for some index `i,` there are no legal jumps.)

A starting index is _good_ if, starting from that index, you can reach the end
of the array (index `A.length - 1`) by jumping some number of times (possibly
0 or more than once.)

Return the number of good starting indexes.



**Example 1:**

    
    
    **Input:** [10,13,12,14,15]
    **Output:** 2
    **Explanation:**
    From starting index i = 0, we can jump to i = 2 (since A[2] is the smallest among A[1], A[2], A[3], A[4] that is greater or equal to A[0]), then we can 't jump any more.
    From starting index i = 1 and i = 2, we can jump to i = 3, then we can't jump any more.
    From starting index i = 3, we can jump to i = 4, so we've reached the end.
    From starting index i = 4, we've reached the end already.
    In total, there are 2 different starting indexes (i = 3, i = 4) where we can reach the end with some number of jumps.
    

**Example 2:**

    
    
    **Input:** [2,3,1,1,4]
    **Output:** 3
    **Explanation:**
    From starting index i = 0, we make jumps to i = 1, i = 2, i = 3:
    
    During our 1st jump (odd numbered), we first jump to i = 1 because A[1] is the smallest value in (A[1], A[2], A[3], A[4]) that is greater than or equal to A[0].
    
    During our 2nd jump (even numbered), we jump from i = 1 to i = 2 because A[2] is the largest value in (A[2], A[3], A[4]) that is less than or equal to A[1].  A[3] is also the largest value, but 2 is a smaller index, so we can only jump to i = 2 and not i = 3.
    
    During our 3rd jump (odd numbered), we jump from i = 2 to i = 3 because A[3] is the smallest value in (A[3], A[4]) that is greater than or equal to A[2].
    
    We can 't jump from i = 3 to i = 4, so the starting index i = 0 is not good.
    
    In a similar manner, we can deduce that:
    From starting index i = 1, we jump to i = 4, so we reach the end.
    From starting index i = 2, we jump to i = 3, and then we can't jump anymore.
    From starting index i = 3, we jump to i = 4, so we reach the end.
    From starting index i = 4, we are already at the end.
    In total, there are 3 different starting indexes (i = 1, i = 3, i = 4) where we can reach the end with some number of jumps.
    

**Example 3:**

    
    
    **Input:** [5,1,3,4,2]
    **Output:** 3
    **Explanation:**
    We can reach the end from starting indexes 1, 2, and 4.
    



**Note:**

  1. `1 <= A.length <= 20000`
  2. `0 <= A[i] < 100000`










## 1018 - Largest Perimeter Triangle
~1~  ['Array', 'Math']
Given an array `A` of positive lengths, return the largest perimeter of a
triangle with **non-zero area** , formed from 3 of these lengths.

If it is impossible to form any triangle of non-zero area, return `0`.



**Example 1:**

    
    
    **Input:** [2,1,2]
    **Output:** 5
    

**Example 2:**

    
    
    **Input:** [1,2,1]
    **Output:** 0
    

**Example 3:**

    
    
    **Input:** [3,2,3,4]
    **Output:** 10
    

**Example 4:**

    
    
    **Input:** [3,6,2,3]
    **Output:** 8
    



**Note:**

  1. `3 <= A.length <= 10000`
  2. `1 <= A[i] <= 10^6`










## 1019 - Squares of a Sorted Array
~1~  ['Array', 'Two Pointers', 'Sort']
Given an array of integers `A` sorted in non-decreasing order, return an array
of the squares of each number, also in sorted non-decreasing order.



**Example 1:**

    
    
    **Input:** [-4,-1,0,3,10]
    **Output:** [0,1,9,16,100]
    

**Example 2:**

    
    
    **Input:** [-7,-3,2,3,11]
    **Output:** [4,9,9,49,121]
    



**Note:**

  1. ` 1 <= A.length <= 10000`
  2. `-10000 <= A[i] <= 10000`
  3. `A` is sorted in non-decreasing order.










## 1020 - Longest Turbulent Subarray
~2~  ['Array']
A subarray `A[i], A[i+1], ..., A[j]` of `A` is said to be _turbulent_ if and
only if:

  * For `i <= k < j`, `A[k] > A[k+1]` when `k` is odd, and `A[k] < A[k+1]` when `k` is even;
  * **OR** , for `i <= k < j`, `A[k] > A[k+1]` when `k` is even, and `A[k] < A[k+1]` when `k` is odd.

That is, the subarray is turbulent if the comparison sign flips between each
adjacent pair of elements in the subarray.

Return the **length** of a  maximum size turbulent subarray of A.



**Example 1:**

    
    
    **Input:** [9,4,2,10,7,8,8,1,9]
    **Output:** 5
    **Explanation:** (A[1] > A[2] < A[3] > A[4] < A[5])
    

**Example 2:**

    
    
    **Input:** [4,8,12,16]
    **Output:** 2
    

**Example 3:**

    
    
    **Input:** [100]
    **Output:** 1
    



**Note:**

  1. `1 <= A.length <= 40000`
  2. `0 <= A[i] <= 10^9`










## 1021 - Distribute Coins in Binary Tree
~2~  ['Tree', 'Depth-first Search']
Given the `root` of a binary tree with `N` nodes, each `node` in the tree has
`node.val` coins, and there are `N` coins total.

In one move, we may choose two adjacent nodes and move one coin from one node
to another.  (The move may be from parent to child, or from child to parent.)

Return the number of moves required to make every node have exactly one coin.



**Example 1:**

**![](https://assets.leetcode.com/uploads/2019/01/18/tree1.png)**

    
    
    **Input:** [3,0,0]
    **Output:** 2
    **Explanation:** From the root of the tree, we move one coin to its left child, and one coin to its right child.
    

**Example 2:**

**![](https://assets.leetcode.com/uploads/2019/01/18/tree2.png)**

    
    
    **Input:** [0,3,0]
    **Output:** 3
    **Explanation:** From the left child of the root, we move two coins to the root [taking two moves].  Then, we move one coin from the root of the tree to the right child.
    

**Example 3:**

**![](https://assets.leetcode.com/uploads/2019/01/18/tree3.png)**

    
    
    **Input:** [1,0,2]
    **Output:** 2
    

**Example 4:**

**![](https://assets.leetcode.com/uploads/2019/01/18/tree4.png)**

    
    
    **Input:** [1,0,0,null,3]
    **Output:** 4
    



**Note:**

  1. `1<= N <= 100`
  2. `0 <= node.val <= N`










## 1022 - Unique Paths III
~3~  ['Dynamic Programming', 'Backtracking']
On a 2-dimensional `grid`, there are 4 types of squares:

  * `1` represents the starting square.  There is exactly one starting square.
  * `2` represents the ending square.  There is exactly one ending square.
  * `0` represents empty squares we can walk over.
  * `-1` represents obstacles that we cannot walk over.

Return the number of 4-directional walks from the starting square to the
ending square, that **walk over every non-obstacle square  exactly once**.



**Example 1:**

    
    
    **Input:** [[1,0,0,0],[0,0,0,0],[0,0,2,-1]]
    **Output:** 2
    **Explanation:** We have the following two paths: 
    1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2)
    2. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)

**Example 2:**

    
    
    **Input:** [[1,0,0,0],[0,0,0,0],[0,0,0,2]]
    **Output:** 4
    **Explanation:** We have the following four paths: 
    1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2),(2,3)
    2. (0,0),(0,1),(1,1),(1,0),(2,0),(2,1),(2,2),(1,2),(0,2),(0,3),(1,3),(2,3)
    3. (0,0),(1,0),(2,0),(2,1),(2,2),(1,2),(1,1),(0,1),(0,2),(0,3),(1,3),(2,3)
    4. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2),(2,3)

**Example 3:**

    
    
    **Input:** [[0,1],[2,0]]
    **Output:** 0
    **Explanation:**
    There is no path that walks over every empty square exactly once.
    Note that the starting and ending square can be anywhere in the grid.
    



**Note:**

  1. `1 <= grid.length * grid[0].length <= 20`










## 1023 - Time Based Key-Value Store
~2~  ['Hash Table', 'Binary Search']
Create a timebased key-value store class `TimeMap`, that supports two
operations.

1\. `set(string key, string value, int timestamp)`

  * Stores the `key` and `value`, along with the given `timestamp`.

2\. `get(string key, int timestamp)`

  * Returns a value such that `set(key, value, timestamp_prev)` was called previously, with `timestamp_prev <= timestamp`.
  * If there are multiple such values, it returns the one with the largest `timestamp_prev`.
  * If there are no values, it returns the empty string (`""`).



**Example 1:**

    
    
    **Input:** inputs = ["TimeMap","set","get","get","set","get","get"], inputs = [[],["foo","bar",1],["foo",1],["foo",3],["foo","bar2",4],["foo",4],["foo",5]]
    **Output:** [null,null,"bar","bar",null,"bar2","bar2"]
    **Explanation:**   
    TimeMap kv;   
    kv.set("foo", "bar", 1); // store the key "foo" and value "bar" along with timestamp = 1   
    kv.get("foo", 1);  // output "bar"   
    kv.get("foo", 3); // output "bar" since there is no value corresponding to foo at timestamp 3 and timestamp 2, then the only value is at timestamp 1 ie "bar"   
    kv.set("foo", "bar2", 4);   
    kv.get("foo", 4); // output "bar2"   
    kv.get("foo", 5); //output "bar2"   
    
    

**Example 2:**

    
    
    **Input:** inputs = ["TimeMap","set","set","get","get","get","get","get"], inputs = [[],["love","high",10],["love","low",20],["love",5],["love",10],["love",15],["love",20],["love",25]]
    **Output:** [null,null,null,"","high","high","low","low"]
    



**Note:**

  1. All key/value strings are lowercase.
  2. All key/value strings have length in the range `[1, 100]`
  3. The `timestamps` for all `TimeMap.set` operations are strictly increasing.
  4. `1 <= timestamp <= 10^7`
  5. `TimeMap.set` and `TimeMap.get` functions will be called a total of `120000` times (combined) per test case.










## 1024 - Triples with Bitwise AND Equal To Zero
~3~  ['Dynamic Programming']
Given an array of integers `A`, find the number of triples of indices (i, j,
k) such that:

  * `0 <= i < A.length`
  * `0 <= j < A.length`
  * `0 <= k < A.length`
  * `A[i] & A[j] & A[k] == 0`, where `&` represents the bitwise-AND operator.



**Example 1:**

    
    
    **Input:** [2,1,3]
    **Output:** 12
    **Explanation:** We could choose the following i, j, k triples:
    (i=0, j=0, k=1) : 2 & 2 & 1
    (i=0, j=1, k=0) : 2 & 1 & 2
    (i=0, j=1, k=1) : 2 & 1 & 1
    (i=0, j=1, k=2) : 2 & 1 & 3
    (i=0, j=2, k=1) : 2 & 3 & 1
    (i=1, j=0, k=0) : 1 & 2 & 2
    (i=1, j=0, k=1) : 1 & 2 & 1
    (i=1, j=0, k=2) : 1 & 2 & 3
    (i=1, j=1, k=0) : 1 & 1 & 2
    (i=1, j=2, k=0) : 1 & 3 & 2
    (i=2, j=0, k=1) : 3 & 2 & 1
    (i=2, j=1, k=0) : 3 & 1 & 2
    



**Note:**

  1. ` 1 <= A.length <= 1000`
  2. `0 <= A[i] < 2^16`










## 1025 - Minimum Cost For Tickets
~2~  ['Dynamic Programming']
In a country popular for train travel, you have planned some train travelling
one year in advance.  The days of the year that you will travel is given as an
array `days`.  Each day is an integer from `1` to `365`.

Train tickets are sold in 3 different ways:

  * a 1-day pass is sold for `costs[0]` dollars;
  * a 7-day pass is sold for `costs[1]` dollars;
  * a 30-day pass is sold for `costs[2]` dollars.

The passes allow that many days of consecutive travel.  For example, if we get
a 7-day pass on day 2, then we can travel for 7 days: day 2, 3, 4, 5, 6, 7,
and 8.

Return the minimum number of dollars you need to travel every day in the given
list of `days`.



**Example 1:**

    
    
    **Input:** days = [1,4,6,7,8,20], costs = [2,7,15]
    **Output:** 11
    **Explanation:**
    For example, here is one way to buy passes that lets you travel your travel plan:
    On day 1, you bought a 1-day pass for costs[0] = $2, which covered day 1.
    On day 3, you bought a 7-day pass for costs[1] = $7, which covered days 3, 4, ..., 9.
    On day 20, you bought a 1-day pass for costs[0] = $2, which covered day 20.
    In total you spent $11 and covered all the days of your travel.
    

**Example 2:**

    
    
    **Input:** days = [1,2,3,4,5,6,7,8,9,10,30,31], costs = [2,7,15]
    **Output:** 17
    **Explanation:**
    For example, here is one way to buy passes that lets you travel your travel plan:
    On day 1, you bought a 30-day pass for costs[2] = $15 which covered days 1, 2, ..., 30.
    On day 31, you bought a 1-day pass for costs[0] = $2 which covered day 31.
    In total you spent $17 and covered all the days of your travel.
    



**Note:**

  1. `1 <= days.length <= 365`
  2. `1 <= days[i] <= 365`
  3. `days` is in strictly increasing order.
  4. `costs.length == 3`
  5. `1 <= costs[i] <= 1000`










## 1026 - String Without AAA or BBB
~1~  ['Greedy']
Given two integers `A` and `B`, return **any** string `S` such that:

  * `S` has length `A + B` and contains exactly `A` `'a'` letters, and exactly `B` `'b'` letters;
  * The substring `'aaa'` does not occur in `S`;
  * The substring `'bbb'` does not occur in `S`.



**Example 1:**

    
    
    **Input:** A = 1, B = 2
    **Output:** "abb"
    **Explanation:**  "abb", "bab" and "bba" are all correct answers.
    

**Example 2:**

    
    
    **Input:** A = 4, B = 1
    **Output:** "aabaa"



**Note:**

  1. `0 <= A <= 100`
  2. `0 <= B <= 100`
  3. It is guaranteed such an `S` exists for the given `A` and `B`.










## 1027 - Sum of Even Numbers After Queries
~1~  ['Array']
We have an array `A` of integers, and an array `queries` of queries.

For the `i`-th query `val = queries[i][0], index = queries[i][1]`, we add val
to `A[index]`.  Then, the answer to the `i`-th query is the sum of the even
values of `A`.

_(Here, the given`index = queries[i][1]` is a 0-based index, and each query
permanently modifies the array `A`.)_

Return the answer to all queries.  Your `answer` array should have `answer[i]`
as the answer to the `i`-th query.



**Example 1:**

    
    
    **Input:** A = [1,2,3,4], queries = [[1,0],[-3,1],[-4,0],[2,3]]
    **Output:** [8,6,2,4]
    **Explanation:**
    At the beginning, the array is [1,2,3,4].
    After adding 1 to A[0], the array is [2,2,3,4], and the sum of even values is 2 + 2 + 4 = 8.
    After adding -3 to A[1], the array is [2,-1,3,4], and the sum of even values is 2 + 4 = 6.
    After adding -4 to A[0], the array is [-2,-1,3,4], and the sum of even values is -2 + 4 = 2.
    After adding 2 to A[3], the array is [-2,-1,3,6], and the sum of even values is -2 + 6 = 4.
    



**Note:**

  1. `1 <= A.length <= 10000`
  2. `-10000 <= A[i] <= 10000`
  3. `1 <= queries.length <= 10000`
  4. `-10000 <= queries[i][0] <= 10000`
  5. `0 <= queries[i][1] < A.length`










## 1028 - Interval List Intersections
~2~  ['Two Pointers']
Given two lists of **closed** intervals, each list of intervals is pairwise
disjoint and in sorted order.

Return the intersection of these two interval lists.

_(Formally, a closed interval`[a, b]` (with `a <= b`) denotes the set of real
numbers `x` with `a <= x <= b`.  The intersection of two closed intervals is a
set of real numbers that is either empty, or can be represented as a closed
interval.  For example, the intersection of [1, 3] and [2, 4] is [2, 3].)_



**Example 1:**

**![](https://assets.leetcode.com/uploads/2019/01/30/interval1.png)**

    
    
    **Input:** A = [[0,2],[5,10],[13,23],[24,25]], B = [[1,5],[8,12],[15,24],[25,26]]
    **Output:** [[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]]
    **Reminder:** The inputs and the desired output are lists of Interval objects, and not arrays or lists.
    



**Note:**

  1. `0 <= A.length < 1000`
  2. `0 <= B.length < 1000`
  3. `0 <= A[i].start, A[i].end, B[i].start, B[i].end < 10^9`










## 1029 - Vertical Order Traversal of a Binary Tree
~2~  ['Hash Table', 'Tree']
Given a binary tree, return the _vertical order_ traversal of its nodes
values.

For each node at position `(X, Y)`, its left and right children respectively
will be at positions `(X-1, Y-1)` and `(X+1, Y-1)`.

Running a vertical line from `X = -infinity` to `X = +infinity`, whenever the
vertical line touches some nodes, we report the values of the nodes in order
from top to bottom (decreasing `Y` coordinates).

If two nodes have the same position, then the value of the node that is
reported first is the value that is smaller.

Return an list of non-empty reports in order of `X` coordinate.  Every report
will have a list of values of nodes.



**Example 1:**

![](https://assets.leetcode.com/uploads/2019/01/31/1236_example_1.PNG)

    
    
    **Input:** [3,9,20,null,null,15,7]
    **Output:** [[9],[3,15],[20],[7]]
    **Explanation:**
    Without loss of generality, we can assume the root node is at position (0, 0):
    Then, the node with value 9 occurs at position (-1, -1);
    The nodes with values 3 and 15 occur at positions (0, 0) and (0, -2);
    The node with value 20 occurs at position (1, -1);
    The node with value 7 occurs at position (2, -2).
    

**Example 2:**

**![](https://assets.leetcode.com/uploads/2019/01/31/tree2.png)**

    
    
    **Input:** [1,2,3,4,5,6,7]
    **Output:** [[4],[2],[1,5,6],[3],[7]]
    **Explanation:**
    The node with value 5 and the node with value 6 have the same position according to the given scheme.
    However, in the report  "[1,5,6]", the node value of 5 comes first since 5 is smaller than 6.
    



**Note:**

  1. The tree will have between 1 and `1000` nodes.
  2. Each node's value will be between `0` and `1000`.










## 1030 - Smallest String Starting From Leaf
~2~  ['Tree']
Given the `root` of a binary tree, each node has a value from `0` to `25`
representing the letters `'a'` to `'z'`: a value of `0` represents `'a'`, a
value of `1` represents `'b'`, and so on.

Find the lexicographically smallest string that starts at a leaf of this tree
and ends at the root.

_(As a reminder, any shorter prefix of a string is lexicographically smaller:
for example,`"ab"` is lexicographically smaller than `"aba"`.  A leaf of a
node is a node that has no children.)_



**Example 1:**

**![](https://assets.leetcode.com/uploads/2019/01/30/tree1.png)**

    
    
    **Input:** [0,1,2,3,4,3,4]
    **Output:** "dba"
    

**Example 2:**

**![](https://assets.leetcode.com/uploads/2019/01/30/tree2.png)**

    
    
    **Input:** [25,1,3,1,3,0,2]
    **Output:** "adz"
    

**Example 3:**

**![](https://assets.leetcode.com/uploads/2019/02/01/tree3.png)**

    
    
    **Input:** [2,2,1,null,1,0,null,0]
    **Output:** "abc"
    



**Note:**

  1. The number of nodes in the given tree will be between `1` and `1000`.
  2. Each node in the tree will have a value between `0` and `25`.










## 1031 - Add to Array-Form of Integer
~1~  ['Array']
For a non-negative integer `X`, the  _array-form of`X`_  is an array of its
digits in left to right order.  For example, if `X = 1231`, then the array
form is `[1,2,3,1]`.

Given the array-form `A` of a non-negative integer `X`, return the array-form
of the integer `X+K`.



**Example 1:**

    
    
    **Input:** A = [1,2,0,0], K = 34
    **Output:** [1,2,3,4]
    **Explanation:** 1200 + 34 = 1234
    

**Example 2:**

    
    
    **Input:** A = [2,7,4], K = 181
    **Output:** [4,5,5]
    **Explanation:** 274 + 181 = 455
    

**Example 3:**

    
    
    **Input:** A = [2,1,5], K = 806
    **Output:** [1,0,2,1]
    **Explanation:** 215 + 806 = 1021
    

**Example 4:**

    
    
    **Input:** A = [9,9,9,9,9,9,9,9,9,9], K = 1
    **Output:** [1,0,0,0,0,0,0,0,0,0,0]
    **Explanation:** 9999999999 + 1 = 10000000000
    



**Note：**

  1. `1 <= A.length <= 10000`
  2. `0 <= A[i] <= 9`
  3. `0 <= K <= 10000`
  4. If `A.length > 1`, then `A[0] != 0`










## 1032 - Satisfiability of Equality Equations
~2~  ['Union Find', 'Graph']
Given an array equations of strings that represent relationships between
variables, each string `equations[i]` has length `4` and takes one of two
different forms: `"a==b"` or `"a!=b"`.  Here, `a` and `b` are lowercase
letters (not necessarily different) that represent one-letter variable names.

Return `true` if and only if it is possible to assign integers to variable
names so as to satisfy all the given equations.



**Example 1:**

    
    
    **Input:** ["a==b","b!=a"]
    **Output:** false
    **Explanation:** If we assign say, a = 1 and b = 1, then the first equation is satisfied, but not the second.  There is no way to assign the variables to satisfy both equations.
    

**Example 2:**

    
    
    **Input:** ["b==a","a==b"]
    **Output:** true
    **Explanation:** We could assign a = 1 and b = 1 to satisfy both equations.
    

**Example 3:**

    
    
    **Input:** ["a==b","b==c","a==c"]
    **Output:** true
    

**Example 4:**

    
    
    **Input:** ["a==b","b!=c","c==a"]
    **Output:** false
    

**Example 5:**

    
    
    **Input:** ["c==c","b==d","x!=z"]
    **Output:** true
    



**Note:**

  1. `1 <= equations.length <= 500`
  2. `equations[i].length == 4`
  3. `equations[i][0]` and `equations[i][3]` are lowercase letters
  4. `equations[i][1]` is either `'='` or `'!'`
  5. `equations[i][2]` is `'='`










## 1033 - Broken Calculator
~2~  ['Math', 'Greedy']
On a broken calculator that has a number showing on its display, we can
perform two operations:

  * **Double** : Multiply the number on the display by 2, or;
  * **Decrement** : Subtract 1 from the number on the display.

Initially, the calculator is displaying the number `X`.

Return the minimum number of operations needed to display the number `Y`.



**Example 1:**

    
    
    **Input:** X = 2, Y = 3
    **Output:** 2
    **Explanation:** Use double operation and then decrement operation {2 -> 4 -> 3}.
    

**Example 2:**

    
    
    **Input:** X = 5, Y = 8
    **Output:** 2
    **Explanation:** Use decrement and then double {5 -> 4 -> 8}.
    

**Example 3:**

    
    
    **Input:** X = 3, Y = 10
    **Output:** 3
    **Explanation:** Use double, decrement and double {3 - > 6 -> 5 -> 10}.
    

**Example 4:**

    
    
    **Input:** X = 1024, Y = 1
    **Output:** 1023
    **Explanation:** Use decrement operations 1023 times.
    



**Note:**

  1. `1 <= X <= 10^9`
  2. `1 <= Y <= 10^9`










## 1034 - Subarrays with K Different Integers
~3~  ['Hash Table', 'Two Pointers', 'Sliding Window']
Given an array `A` of positive integers, call a (contiguous, not necessarily
distinct) subarray of `A` _good_ if the number of different integers in that
subarray is exactly `K`.

(For example, `[1,2,3,1,2]` has `3` different integers: `1`, `2`, and `3`.)

Return the number of good subarrays of `A`.



**Example 1:**

    
    
    **Input:** A = [1,2,1,2,3], K = 2
    **Output:** 7
    **Explanation:** Subarrays formed with exactly 2 different integers: [1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2].
    

**Example 2:**

    
    
    **Input:** A = [1,2,1,3,4], K = 3
    **Output:** 3
    **Explanation:** Subarrays formed with exactly 3 different integers: [1,2,1,3], [2,1,3], [1,3,4].
    



**Note:**

  1. `1 <= A.length <= 20000`
  2. `1 <= A[i] <= A.length`
  3. `1 <= K <= A.length`










## 1035 - Cousins in Binary Tree
~1~  ['Tree', 'Breadth-first Search']
In a binary tree, the root node is at depth `0`, and children of each depth
`k` node are at depth `k+1`.

Two nodes of a binary tree are _cousins_ if they have the same depth, but have
**different parents**.

We are given the `root` of a binary tree with unique values, and the values
`x` and `y` of two different nodes in the tree.

Return `true` if and only if the nodes corresponding to the values `x` and `y`
are cousins.



**Example 1:  
![](https://assets.leetcode.com/uploads/2019/02/12/q1248-01.png)**

    
    
    **Input:** root = [1,2,3,4], x = 4, y = 3
    **Output:** false
    

**Example 2:  
![](https://assets.leetcode.com/uploads/2019/02/12/q1248-02.png)**

    
    
    **Input:** root = [1,2,3,null,4,null,5], x = 5, y = 4
    **Output:** true
    

**Example 3:**

**![](https://assets.leetcode.com/uploads/2019/02/13/q1248-03.png)**

    
    
    **Input:** root = [1,2,3,null,4], x = 2, y = 3
    **Output:** false



**Note:**

  1. The number of nodes in the tree will be between `2` and `100`.
  2. Each node has a unique integer value from `1` to `100`.










## 1036 - Rotting Oranges
~1~  ['Breadth-first Search']
In a given grid, each cell can have one of three values:

  * the value `0` representing an empty cell;
  * the value `1` representing a fresh orange;
  * the value `2` representing a rotten orange.

Every minute, any fresh orange that is adjacent (4-directionally) to a rotten
orange becomes rotten.

Return the minimum number of minutes that must elapse until no cell has a
fresh orange.  If this is impossible, return `-1` instead.



**Example 1:**

**![](https://assets.leetcode.com/uploads/2019/02/16/oranges.png)**

    
    
    **Input:** [[2,1,1],[1,1,0],[0,1,1]]
    **Output:** 4
    

**Example 2:**

    
    
    **Input:** [[2,1,1],[0,1,1],[1,0,1]]
    **Output:** -1
    **Explanation:** The orange in the bottom left corner (row 2, column 0) is never rotten, because rotting only happens 4-directionally.
    

**Example 3:**

    
    
    **Input:** [[0,2]]
    **Output:** 0
    **Explanation:** Since there are already no fresh oranges at minute 0, the answer is just 0.
    



**Note:**

  1. `1 <= grid.length <= 10`
  2. `1 <= grid[0].length <= 10`
  3. `grid[i][j]` is only `0`, `1`, or `2`.










## 1037 - Minimum Number of K Consecutive Bit Flips
~3~  ['Greedy', 'Sliding Window']
In an array `A` containing only 0s and 1s, a _`K`-bit flip _ consists of
choosing a (contiguous) subarray of length `K` and simultaneously changing
every 0 in the subarray to 1, and every 1 in the subarray to 0.

Return the minimum number of `K`-bit flips required so that there is no 0 in
the array.  If it is not possible, return `-1`.



**Example 1:**

    
    
    **Input:** A = [0,1,0], K = 1
    **Output:** 2
    **Explanation:** Flip A[0], then flip A[2].
    

**Example 2:**

    
    
    **Input:** A = [1,1,0], K = 2
    **Output:** -1
    **Explanation:**  No matter how we flip subarrays of size 2, we can't make the array become [1,1,1].
    

**Example 3:**

    
    
    **Input:** A = [0,0,0,1,0,1,1,0], K = 3
    **Output:** 3
    **Explanation:**
    Flip A[0],A[1],A[2]:  A becomes [1,1,1,1,0,1,1,0]
    Flip A[4],A[5],A[6]: A becomes [1,1,1,1,1,0,0,0]
    Flip A[5],A[6],A[7]: A becomes [1,1,1,1,1,1,1,1]
    



**Note:**

  1. `1 <= A.length <= 30000`
  2. `1 <= K <= A.length`










## 1038 - Number of Squareful Arrays
~3~  ['Math', 'Backtracking', 'Graph']
Given an array `A` of non-negative integers, the array is _squareful_ if for
every pair of adjacent elements, their sum is a perfect square.

Return the number of permutations of A that are squareful.  Two permutations
`A1` and `A2` differ if and only if there is some index `i` such that `A1[i]
!= A2[i]`.



**Example 1:**

    
    
    **Input:** [1,17,8]
    **Output:** 2
    **Explanation:**
    [1,8,17] and [17,8,1] are the valid permutations.
    

**Example 2:**

    
    
    **Input:** [2,2,2]
    **Output:** 1
    



**Note:**

  1. `1 <= A.length <= 12`
  2. `0 <= A[i] <= 1e9`










## 1039 - Find the Town Judge
~1~  ['Graph']
In a town, there are `N` people labelled from `1` to `N`.  There is a rumor
that one of these people is secretly the town judge.

If the town judge exists, then:

  1. The town judge trusts nobody.
  2. Everybody (except for the town judge) trusts the town judge.
  3. There is exactly one person that satisfies properties 1 and 2.

You are given `trust`, an array of pairs `trust[i] = [a, b]` representing that
the person labelled `a` trusts the person labelled `b`.

If the town judge exists and can be identified, return the label of the town
judge.  Otherwise, return `-1`.



**Example 1:**

    
    
    **Input:** N = 2, trust = [[1,2]]
    **Output:** 2
    

**Example 2:**

    
    
    **Input:** N = 3, trust = [[1,3],[2,3]]
    **Output:** 3
    

**Example 3:**

    
    
    **Input:** N = 3, trust = [[1,3],[2,3],[3,1]]
    **Output:** -1
    

**Example 4:**

    
    
    **Input:** N = 3, trust = [[1,2],[2,3]]
    **Output:** -1
    

**Example 5:**

    
    
    **Input:** N = 4, trust = [[1,3],[1,4],[2,3],[2,4],[4,3]]
    **Output:** 3



**Note:**

  1. `1 <= N <= 1000`
  2. `trust.length <= 10000`
  3. `trust[i]` are all different
  4. `trust[i][0] != trust[i][1]`
  5. `1 <= trust[i][0], trust[i][1] <= N`










## 1040 - Maximum Binary Tree II
~2~  ['Tree']
We are given the `root` node of a _maximum tree:_ a tree where every node has
a value greater than any other value in its subtree.

Just as in the [previous problem](https://leetcode.com/problems/maximum-
binary-tree/), the given tree was constructed from an list `A` (`root =
Construct(A)`) recursively with the following `Construct(A)` routine:

  * If `A` is empty, return `null`.
  * Otherwise, let `A[i]` be the largest element of `A`.  Create a `root` node with value `A[i]`.
  * The left child of `root` will be `Construct([A[0], A[1], ..., A[i-1]])`
  * The right child of `root` will be `Construct([A[i+1], A[i+2], ..., A[A.length - 1]])`
  * Return `root`.

Note that we were not given A directly, only a root node `root =
Construct(A)`.

Suppose `B` is a copy of `A` with the value `val` appended to it.  It is
guaranteed that `B` has unique values.

Return `Construct(B)`.



**Example 1:**

**![](https://assets.leetcode.com/uploads/2019/02/21/maximum-binary-
tree-1-1.png)![](https://assets.leetcode.com/uploads/2019/02/21/maximum-
binary-tree-1-2.png)**

    
    
    **Input:** root = [4,1,3,null,null,2], val = 5
    **Output:** [5,4,null,1,3,null,null,2]
    **Explanation:** A =  [1,4,2,3], B = [1,4,2,3,5]
    

**Example 2:  
![](https://assets.leetcode.com/uploads/2019/02/21/maximum-binary-
tree-2-1.png)![](https://assets.leetcode.com/uploads/2019/02/21/maximum-
binary-tree-2-2.png)**

    
    
    **Input:** root = [5,2,4,null,1], val = 3
    **Output:** [5,2,4,null,1,null,3]
    **Explanation:** A =  [2,1,5,4], B = [2,1,5,4,3]
    

**Example 3:  
![](https://assets.leetcode.com/uploads/2019/02/21/maximum-binary-
tree-3-1.png)![](https://assets.leetcode.com/uploads/2019/02/21/maximum-
binary-tree-3-2.png)**

    
    
    **Input:** root = [5,2,3,null,1], val = 4
    **Output:** [5,2,4,null,1,3]
    **Explanation:** A =  [2,1,5,3], B = [2,1,5,3,4]
    



**Note:**

  1. `1 <= B.length <= 100`










## 1041 - Available Captures for Rook
~1~  ['Array']
On an 8 x 8 chessboard, there is one white rook.  There also may be empty
squares, white bishops, and black pawns.  These are given as characters 'R',
'.', 'B', and 'p' respectively. Uppercase characters represent white pieces,
and lowercase characters represent black pieces.

The rook moves as in the rules of Chess: it chooses one of four cardinal
directions (north, east, west, and south), then moves in that direction until
it chooses to stop, reaches the edge of the board, or captures an opposite
colored pawn by moving to the same square it occupies.  Also, rooks cannot
move into the same square as other friendly bishops.

Return the number of pawns the rook can capture in one move.



**Example 1:**

![](https://assets.leetcode.com/uploads/2019/02/20/1253_example_1_improved.PNG)

    
    
    **Input:** [[".",".",".",".",".",".",".","."],[".",".",".","p",".",".",".","."],[".",".",".","R",".",".",".","p"],[".",".",".",".",".",".",".","."],[".",".",".",".",".",".",".","."],[".",".",".","p",".",".",".","."],[".",".",".",".",".",".",".","."],[".",".",".",".",".",".",".","."]]
    **Output:** 3
    **Explanation:**
    In this example the rook is able to capture all the pawns.
    

**Example 2:**

![](https://assets.leetcode.com/uploads/2019/02/19/1253_example_2_improved.PNG)

    
    
    **Input:** [[".",".",".",".",".",".",".","."],[".","p","p","p","p","p",".","."],[".","p","p","B","p","p",".","."],[".","p","B","R","B","p",".","."],[".","p","p","B","p","p",".","."],[".","p","p","p","p","p",".","."],[".",".",".",".",".",".",".","."],[".",".",".",".",".",".",".","."]]
    **Output:** 0
    **Explanation:**
    Bishops are blocking the rook to capture any pawn.
    

**Example 3:**

![](https://assets.leetcode.com/uploads/2019/02/20/1253_example_3_improved.PNG)

    
    
    **Input:** [[".",".",".",".",".",".",".","."],[".",".",".","p",".",".",".","."],[".",".",".","p",".",".",".","."],["p","p",".","R",".","p","B","."],[".",".",".",".",".",".",".","."],[".",".",".","B",".",".",".","."],[".",".",".","p",".",".",".","."],[".",".",".",".",".",".",".","."]]
    **Output:** 3
    **Explanation:**
    The rook can capture the pawns at positions b5, d6 and f5.
    



**Note:**

  1. `board.length == board[i].length == 8`
  2. `board[i][j]` is either `'R'`, `'.'`, `'B'`, or `'p'`
  3. There is exactly one cell with `board[i][j] == 'R'`










## 1042 - Minimum Cost to Merge Stones
~3~  ['Dynamic Programming']
There are `N` piles of stones arranged in a row.  The `i`-th pile has
`stones[i]` stones.

A _move_ consists of merging **exactly  `K` consecutive** piles into one pile,
and the cost of this move is equal to the total number of stones in these `K`
piles.

Find the minimum cost to merge all piles of stones into one pile.  If it is
impossible, return `-1`.



**Example 1:**

    
    
    **Input:** stones = [3,2,4,1], K = 2
    **Output:** 20
    **Explanation:**
    We start with [3, 2, 4, 1].
    We merge [3, 2] for a cost of 5, and we are left with [5, 4, 1].
    We merge [4, 1] for a cost of 5, and we are left with [5, 5].
    We merge [5, 5] for a cost of 10, and we are left with [10].
    The total cost was 20, and this is the minimum possible.
    

**Example 2:**

    
    
    **Input:** stones = [3,2,4,1], K = 3
    **Output:** -1
    **Explanation:** After any merge operation, there are 2 piles left, and we can't merge anymore.  So the task is impossible.
    

**Example 3:**

    
    
    **Input:** stones = [3,5,1,2,6], K = 3
    **Output:** 25
    **Explanation:**
    We start with [3, 5, 1, 2, 6].
    We merge [5, 1, 2] for a cost of 8, and we are left with [3, 8, 6].
    We merge [3, 8, 6] for a cost of 17, and we are left with [17].
    The total cost was 25, and this is the minimum possible.
    



**Note:**

  * ` 1 <= stones.length <= 30`
  * `2 <= K <= 30`
  * `1 <= stones[i] <= 100`










## 1043 - Grid Illumination
~3~  ['Hash Table']
On a `N x N` grid of cells, each cell `(x, y)` with `0 <= x < N` and `0 <= y <
N` has a lamp.

Initially, some number of lamps are on.  `lamps[i]` tells us the location of
the `i`-th lamp that is on.  Each lamp that is on illuminates every square on
its x-axis, y-axis, and both diagonals (similar to a Queen in chess).

For the i-th query `queries[i] = (x, y)`, the answer to the query is 1 if the
cell (x, y) is illuminated, else 0.

After each query `(x, y)` [in the order given by `queries`], we turn off any
lamps that are at cell `(x, y)` or are adjacent 8-directionally (ie., share a
corner or edge with cell `(x, y)`.)

Return an array of answers.  Each value `answer[i]` should be equal to the
answer of the `i`-th query `queries[i]`.



**Example 1:**

    
    
    **Input:** N = 5, lamps = [[0,0],[4,4]], queries = [[1,1],[1,0]]
    **Output:** [1,0]
    **Explanation:**
    Before performing the first query we have both lamps [0,0] and [4,4] on.
    The grid representing which cells are lit looks like this, where [0,0] is the top left corner, and [4,4] is the bottom right corner:
    1 1 1 1 1
    1 1 0 0 1
    1 0 1 0 1
    1 0 0 1 1
    1 1 1 1 1
    Then the query at [1, 1] returns 1 because the cell is lit.  After this query, the lamp at [0, 0] turns off, and the grid now looks like this:
    1 0 0 0 1
    0 1 0 0 1
    0 0 1 0 1
    0 0 0 1 1
    1 1 1 1 1
    Before performing the second query we have only the lamp [4,4] on.  Now the query at [1,0] returns 0, because the cell is no longer lit.
    



**Note:**

  1. `1 <= N <= 10^9`
  2. `0 <= lamps.length <= 20000`
  3. `0 <= queries.length <= 20000`
  4. `lamps[i].length == queries[i].length == 2`










## 1044 - Find Common Characters
~1~  ['Array', 'Hash Table']
Given an array `A` of strings made only from lowercase letters, return a list
of all characters that show up in all strings within the list **(including
duplicates)**.   For example, if a character occurs 3 times in all strings but
not 4 times, you need to include that character three times in the final
answer.

You may return the answer in any order.



**Example 1:**

    
    
    **Input:** ["bella","label","roller"]
    **Output:** ["e","l","l"]
    

**Example 2:**

    
    
    **Input:** ["cool","lock","cook"]
    **Output:** ["c","o"]
    



**Note:**

  1. `1 <= A.length <= 100`
  2. `1 <= A[i].length <= 100`
  3. `A[i][j]` is a lowercase letter










## 1045 - Check If Word Is Valid After Substitutions
~2~  ['String', 'Stack']
We are given that the string `"abc"` is valid.

From any valid string `V`, we may split `V` into two pieces `X` and `Y` such
that `X + Y` (`X` concatenated with `Y`) is equal to `V`.  (`X` or `Y` may be
empty.)  Then, `X + "abc" + Y` is also valid.

If for example `S = "abc"`, then examples of valid strings are: `"abc",
"aabcbc", "abcabc", "abcabcababcc"`.  Examples of **invalid**  strings are:
`"abccba"`, `"ab"`, `"cababc"`, `"bac"`.

Return `true` if and only if the given string `S` is valid.



**Example 1:**

    
    
    **Input:** "aabcbc"
    **Output:** true
    **Explanation:**
    We start with the valid string  "abc".
    Then we can insert another "abc" between "a" and "bc", resulting in "a" + "abc" + "bc" which is "aabcbc".
    

**Example 2:**

    
    
    **Input:** "abcabcababcc"
    **Output:** true
    **Explanation:**
     "abcabcabc" is valid after consecutive insertings of "abc".
    Then we can insert "abc" before the last letter, resulting in "abcabcab" + "abc" + "c" which is "abcabcababcc".
    

**Example 3:**

    
    
    **Input:** "abccba"
    **Output:** false
    

**Example 4:**

    
    
    **Input:** "cababc"
    **Output:** false



**Note:**

  1. `1 <= S.length <= 20000`
  2. `S[i]` is `'a'`, `'b'`, or `'c'`










## 1046 - Max Consecutive Ones III
~2~  ['Two Pointers', 'Sliding Window']
Given an array `A` of 0s and 1s, we may change up to `K` values from 0 to 1.

Return the length of the longest (contiguous) subarray that contains only 1s.



**Example 1:**

    
    
    **Input:** A = [1,1,1,0,0,0,1,1,1,1,0], K = 2
    **Output:** 6
    **Explanation:**
    [1,1,1,0,0, _ **1** ,1,1,1,1, **1**_ ]
    Bolded numbers were flipped from 0 to 1.  The longest subarray is underlined.

**Example 2:**

    
    
    **Input:** A = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3
    **Output:** 10
    **Explanation:**
    [0,0, _1,1, **1** , **1** ,1,1,1, **1** ,1,1_,0,0,0,1,1,1,1]
    Bolded numbers were flipped from 0 to 1.  The longest subarray is underlined.
    



**Note:**

  1. `1 <= A.length <= 20000`
  2. `0 <= K <= A.length`
  3. `A[i]` is `0` or `1`










